<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Microsoft.Scripting.Core</name>
    </assembly>
    <members>
        <member name="T:System.Linq.Expressions.Compiler.LambdaCompiler">
            <summary>
            Dynamic Language Runtime Compiler.
            This part compiles lambdas.
            </summary>
            <summary>
            LambdaCompiler is responsible for compiling individual lambda (LambdaExpression). The complete tree may
            contain multiple lambdas, the Compiler class is reponsible for compiling the whole tree, individual
            lambdas are then compiled by the LambdaCompiler.
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Compiler.LambdaCompiler.EmitCatchStart(System.Linq.Expressions.CatchBlock)">
            <summary>
            Emits the start of a catch block.  The exception value that is provided by the
            CLR is stored in the variable specified by the catch block or popped if no
            variable is provided.
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Compiler.LambdaCompiler.EmitDelegateConstruction(System.Linq.Expressions.Compiler.LambdaCompiler,System.Type)">
            <summary>
            Emits code which creates new instance of the delegateType delegate.
            
            Since the delegate is getting closed over the "Closure" argument, this
            cannot be used with virtual/instance methods (inner must be static method)
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Compiler.LambdaCompiler.EmitDelegateConstruction(System.Linq.Expressions.LambdaExpression,System.Type)">
            <summary>
            Emits a delegate to the method generated for the LambdaExpression.
            May end up creating a wrapper to match the requested delegate type.
            </summary>
            <param name="lambda">Lambda for which to generate a delegate</param>
            <param name="delegateType">Type of the delegate.</param>
        </member>
        <member name="M:System.Linq.Expressions.Compiler.LambdaCompiler.ComputeSignature(System.Linq.Expressions.LambdaExpression,System.Collections.Generic.List{System.Type}@,System.Collections.Generic.List{System.String}@,System.String@,System.Type@)">
            <summary>
            Creates the signature for the lambda as list of types and list of names separately
            </summary>
        </member>
        <member name="F:System.Linq.Expressions.Compiler.LambdaCompiler._paramTypes">
            <summary>
            Argument types
            
            This list contains _all_ arguments on the underlying method builder (except for the
            "this"). There are two views on the list. First provides the raw view (shows all
            arguments), the second view provides view of the arguments which are in the original
            lambda (so first argument, which may be closure argument, is skipped in that case)
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Compiler.LambdaCompiler.CompileLambda(System.Linq.Expressions.LambdaExpression,System.Type,System.Boolean,System.Boolean,System.Reflection.MethodInfo@)">
            <summary>
            Compiler entry point
            </summary>
            <param name="lambda">LambdaExpression to compile.</param>
            <param name="method">Product of compilation</param>
            <param name="delegateType">Type of the delegate to create</param>
            <param name="emitDebugSymbols">True to emit debug symbols, false otherwise.</param>
            <param name="forceDynamic">Force dynamic method regardless of save assemblies.</param>
            <returns>The compiled delegate.</returns>
        </member>
        <member name="M:System.Linq.Expressions.Compiler.LambdaCompiler.CompileLambda(System.Linq.Expressions.LambdaExpression,System.Reflection.Emit.TypeBuilder,System.Reflection.MethodAttributes,System.Boolean)">
            <summary>
            Creates and returns a MethodBuilder
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Compiler.LambdaCompiler.GetLambdaArgument(System.Int32)">
            <summary>
            Gets the argument slot corresponding to the parameter at the given
            index. Assumes that the method takes a certain number of prefix
            arguments, followed by the real parameters stored in Parameters
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Compiler.LambdaCompiler.EmitLambdaArgument(System.Int32)">
            <summary>
            Returns the index-th argument. This method provides access to the actual arguments
            defined on the lambda itself, and excludes the possible 0-th closure argument.
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Compiler.LambdaCompiler.CreateDynamicCompiler(System.Linq.Expressions.Compiler.AnalyzedTree,System.Linq.Expressions.LambdaExpression,System.String,System.Type,System.Collections.Generic.IList{System.Type},System.Collections.Generic.IList{System.String},System.Boolean,System.Boolean)">
            <summary>
            Creates a compiler backed by dynamic method. Sometimes (when debugging is required) the dynamic
            method is actually a 'fake' dynamic method and is backed by static type created specifically for
            the one method
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Compiler.LambdaCompiler.CreateStaticCompiler(System.Linq.Expressions.Compiler.AnalyzedTree,System.Linq.Expressions.LambdaExpression,System.Reflection.Emit.TypeBuilder,System.String,System.Reflection.MethodAttributes,System.Type,System.Collections.Generic.IList{System.Type},System.Collections.Generic.IList{System.String},System.Boolean,System.Boolean)">
            <summary>
            Creates a LambdaCompiler backed by a method on a static type
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Compiler.LambdaCompiler.Significant(System.Linq.Expressions.Expression)">
            <summary>
            Expression is significant if:
              * it is not an empty expression
            == or ==
              * it is an empty expression, and 
              * it has a valid span, and
              * we are emitting debug symbols
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Compiler.LambdaCompiler.EmitExpression(System.Linq.Expressions.Expression)">
            <summary>
            Generates code for this expression in a value position.
            This method will leave the value of the expression
            on the top of the stack typed as Type.
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Compiler.LambdaCompiler.EmitExpressionAsVoid(System.Linq.Expressions.Expression)">
            <summary>
            Emits an expression and discards the result.  For some nodes this emits
            more optimial code then EmitExpression/Pop
            </summary>
        </member>
        <member name="T:System.Linq.Expressions.Expression">
            <summary>
            Factory methods.
            </summary>
            <summary>
            Factory methods.
            </summary>
            <summary>
            Factory methods.
            </summary>
            <summary>
            Factory methods.
            </summary>
            <summary>
            Factory methods.
            </summary>
            <summary>
            Factory methods.
            </summary>
            <summary>
            Factory methods.
            TODO: review which of these overloads we actually need
            </summary>
            <summary>
            Factory methods
            </summary>
            <summary>
            Factory methods.
            </summary>
            <summary>
            Expression is the base type for all nodes in Expression Trees
            </summary>
            <summary>
            Factory methods.
            </summary>
            <summary>
            Factory methods.
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Expression.Assign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
            <summary>
            Performs an assignment variable = value
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Expression.Reduce">
            <summary>
            Reduces this node to a simpler expression. If CanReduce returns
            true, this should return a valid expression. This method is
            allowed to return another node which itself must be reduced.
            </summary>
            <returns>the reduced expression</returns>
        </member>
        <member name="M:System.Linq.Expressions.Expression.VisitChildren(System.Linq.Expressions.ExpressionVisitor)">
            <summary>
            Override this to provide logic to walk the node's children. A
            typical implementation will call visitor.Visit on each of its
            children, and if any of them change, should return a new copy of
            itself with the modified children.
            
            The default implementation will reduce the node and then walk it
            This will throw an exception if the node is not reducible
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Expression.ReduceAndCheck">
            <summary>
            Reduces this node to a simpler expression. If CanReduce returns
            true, this should return a valid expression. This method is
            allowed to return another node which itself must be reduced.
            
            Unlike Reduce, this method checks that the reduced node satisfies
            certain invaraints.
            </summary>
            <returns>the reduced expression</returns>
        </member>
        <member name="M:System.Linq.Expressions.Expression.ReduceExtensions">
            <summary>
            Reduces the expression to a known node type (i.e. not an Extension node)
            or simply returns the expression if it is already a known type.
            </summary>
            <returns>the reduced expression</returns>
        </member>
        <member name="M:System.Linq.Expressions.Expression.ReturnReadOnly``1(System.Collections.Generic.IList{``0}@)">
            <summary>
            Helper used for ensuring we only return 1 instance of a ReadOnlyCollection of T.
            
            This is called from various methods where we internally hold onto an IList of T
            or a ROC of T.  We check to see if we've already returned a ROC of T and if so
            simply return the other one.  Otherwise we do a thread-safe replacement of hte
            list w/ a ROC which wraps it.
            
            Ultimately this saves us from having to allocate a ReadOnlyCollection for our
            data types because the compiler is capable of going directly to the IList of T.
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Expression.ReturnReadOnly(System.Linq.Expressions.IArgumentProvider,System.Object@)">
            <summary>
            Helper used for ensuring we only return 1 instance of a ReadOnlyCollection of T.
            
            This is similar to the ReturnReadOnly of T. This version supports nodes which hold 
            onto multiple Expressions where one is typed to object.  That object field holds either
            an expression or a ReadOnlyCollection of Expressions.  When it holds a ReadOnlyCollection
            the IList which backs it is a ListArgumentProvider which uses the Expression which
            implements IArgumentProvider to get 2nd and additional values.  The ListArgumentProvider 
            continues to hold onto the 1st expression.  
            
            This enables users to get the ReadOnlyCollection w/o it consuming more memory than if 
            it was just an array.  Meanwhile The DLR internally avoids accessing  which would force 
            the ROC to be created resulting in a typical memory savings.
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Expression.ReturnObject``1(System.Object)">
            <summary>
            Helper which is used for specialized subtypes which use ReturnReadOnly(ref object, ...). 
            This is the reverse version of ReturnReadOnly which takes an IArgumentProvider.
            
            This is used to return the 1st argument.  The 1st argument is typed as object and either
            contains a ReadOnlyCollection or the Expression.  We check for the Expression and if it's
            present we return that, otherwise we return the 1st element of the ReadOnlyCollection.
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Expression.Block(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
            <summary>
            Creates a list of expressions whose value is the value of the last expression.
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Expression.NewArrayInit(System.Type,System.Linq.Expressions.Expression[])">
            <summary>
            Creates a new array expression of the specified type from the provided initializers.
            </summary>
            <param name="type">A Type that represents the element type of the array.</param>
            <param name="initializers">The expressions used to create the array elements.</param>
        </member>
        <member name="M:System.Linq.Expressions.Expression.NewArrayInit(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
            <summary>
            Creates a new array expression of the specified type from the provided initializers.
            </summary>
            <param name="type">A Type that represents the element type of the array.</param>
            <param name="initializers">The expressions used to create the array elements.</param>
        </member>
        <member name="P:System.Linq.Expressions.Expression.CanReduce">
            <summary>
            Indicates that the node can be reduced to a simpler node. If this 
            returns true, Reduce() can be called to produce the reduced form.
            </summary>
        </member>
        <member name="T:System.Dynamic.ComInterop.SimpleArgBuilder">
            <summary>
            SimpleArgBuilder produces the value produced by the user as the argument value.  It
            also tracks information about the original parameter and is used to create extended
            methods for params arrays and param dictionary functions.
            </summary>
        </member>
        <member name="T:System.Dynamic.ComInterop.ArgBuilder">
            <summary>
            ArgBuilder provides an argument value used by the MethodBinder.  One ArgBuilder exists for each
            physical parameter defined on a method.  
            
            Contrast this with ParameterWrapper which represents the logical argument passed to the method.
            </summary>
        </member>
        <member name="M:System.Dynamic.ComInterop.ArgBuilder.Marshal(System.Linq.Expressions.Expression)">
            <summary>
            Provides the Expression which provides the value to be passed to the argument.
            </summary>
        </member>
        <member name="M:System.Dynamic.ComInterop.ArgBuilder.MarshalToRef(System.Linq.Expressions.Expression)">
            <summary>
            Provides the Expression which provides the value to be passed to the argument.
            This method is called when result is intended to be used ByRef.
            
            TODO: merge with Unwrap. They're distict because some of the variant
            magic is happening in helpers in Variant.cs, rather than in Unwrap.
            So UnwrapByRef has to duplicate this logic. The logic should just
            move into Unwrap
            </summary>
        </member>
        <member name="M:System.Dynamic.ComInterop.ArgBuilder.UnmarshalFromRef(System.Linq.Expressions.Expression)">
            <summary>
            Provides an Expression which will update the provided value after a call to the method.
            May return null if no update is required.
            </summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.CallSiteBinder">
            <summary>
            Class responsible for binding dynamic operations on the dynamic site.
            </summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.CallSiteBinder.Bind(System.Object[],System.Collections.ObjectModel.ReadOnlyCollection{System.Linq.Expressions.ParameterExpression},System.Linq.Expressions.LabelTarget)">
            <summary>
            The bind call to produce the binding.
            </summary>
            <param name="args">Array of arguments to the call</param>
            <param name="parameters">Array of ParameterExpressions that represent to parameters of the call site</param>
            <param name="returnLabel">LabelTarget used to return the result of the call site</param>
            <returns>
            An Expression that performs tests on the arguments, and
            returns a result if the test is valid. If the tests fail, Bind
            will be called again to produce a new Expression for the new
            argument types
            </returns>
        </member>
        <member name="P:System.Runtime.CompilerServices.CallSiteBinder.CacheIdentity">
            <summary>
            Key used for the DLR caching
            </summary>
        </member>
        <member name="T:System.Dynamic.Binders.DynamicObject">
            <summary>
            Provides a simple class that can be inherited from to create an object with dynamic behavior
            at runtime.  Subclasses can override the various binder methods (GetMember, SetMember, Call, etc...)
            to provide custom behavior that will be invoked at runtime.  
            
            If a method is not overridden then the Dynamic object does not directly support that behavior and 
            the call site will determine how the binder should be performed.
            </summary>
        </member>
        <member name="M:System.Dynamic.Binders.DynamicObject.#ctor">
            <summary>
            Enables derived types to create a new instance of Dynamic.  Dynamic instances cannot be
            directly instantiated because they have no implementation of dynamic behavior.
            </summary>
        </member>
        <member name="M:System.Dynamic.Binders.DynamicObject.GetMember(System.Dynamic.Binders.GetMemberBinder)">
            <summary>
            When overridden in a derived class provides the non-Meta implementation of getting a member.
            
            When not overridden the call site requesting the binder determines the behavior.
            </summary>
        </member>
        <member name="M:System.Dynamic.Binders.DynamicObject.SetMember(System.Dynamic.Binders.SetMemberBinder,System.Object)">
            <summary>
            When overridden in a derived class provides the non-Meta implementation of setting a member.
            
            When not overridden the call site requesting the binder determines the behavior.
            </summary>
        </member>
        <member name="M:System.Dynamic.Binders.DynamicObject.DeleteMember(System.Dynamic.Binders.DeleteMemberBinder)">
            <summary>
            When overridden in a derived class provides the non-Meta implementation of deleting a member.
            
            When not overridden the call site requesting the binder determines the behavior.
            </summary>
        </member>
        <member name="M:System.Dynamic.Binders.DynamicObject.InvokeMember(System.Dynamic.Binders.InvokeMemberBinder,System.Object[])">
            <summary>
            When overridden in a derived class provides the non-Meta implementation of calling a member
            in the expando.
            
            When not overridden the call site requesting the binder determines the behavior.
            </summary>
        </member>
        <member name="M:System.Dynamic.Binders.DynamicObject.Convert(System.Dynamic.Binders.ConvertBinder)">
            <summary>
            When overridden in a derived class provides the non-Meta implementation of converting the
            Dynamic object to another type.
            
            When not overridden the call site requesting the binder determines the behavior.
            </summary>
        </member>
        <member name="M:System.Dynamic.Binders.DynamicObject.CreateInstance(System.Dynamic.Binders.CreateInstanceBinder,System.Object[])">
            <summary>
            When overridden in a derived class provides the non-Meta implementation of creating an instance
            of the Dynamic object.
            
            When not overridden the call site requesting the binder determines the behavior.
            </summary>
        </member>
        <member name="M:System.Dynamic.Binders.DynamicObject.Invoke(System.Dynamic.Binders.InvokeBinder,System.Object[])">
            <summary>
            When overridden in a derived class provides the non-Meta implementation of invoking the
            Dynamic object.
            
            When not overridden the call site requesting the binder determines the behavior.
            </summary>
        </member>
        <member name="M:System.Dynamic.Binders.DynamicObject.BinaryOperation(System.Dynamic.Binders.BinaryOperationBinder,System.Object)">
            <summary>
            When overridden in a derived class provides the non-Meta implementation of
            performing a binary operation.
            
            When not overridden the call site requesting the binder determines the behavior.
            </summary>
        </member>
        <member name="M:System.Dynamic.Binders.DynamicObject.UnaryOperation(System.Dynamic.Binders.UnaryOperationBinder)">
            <summary>
            When overridden in a derived class provides the non-Meta implementation of
            performing a unary operation.
            
            When not overridden the call site requesting the binder determines the behavior.
            </summary>
        </member>
        <member name="M:System.Dynamic.Binders.DynamicObject.GetIndex(System.Dynamic.Binders.GetIndexBinder,System.Object[])">
            <summary>
            When overridden in a derived class provides the non-Meta implementation of
            performing a get index operation.
            
            When not overridden the call site requesting the binder determines the behavior.
            </summary>
        </member>
        <member name="M:System.Dynamic.Binders.DynamicObject.SetIndex(System.Dynamic.Binders.SetIndexBinder,System.Object[])">
            <summary>
            When overridden in a derived class provides the non-Meta implementation of
            performing a set index operation.
            
            When not overridden the call site requesting the binder determines the behavior.
            </summary>
        </member>
        <member name="M:System.Dynamic.Binders.DynamicObject.DeleteIndex(System.Dynamic.Binders.DeleteIndexBinder,System.Object[])">
            <summary>
            When overridden in a derived class provides the non-Meta implementation of
            performing a delete index operation.
            
            When not overridden the call site requesting the binder determines the behavior.
            </summary>
        </member>
        <member name="M:System.Dynamic.Binders.DynamicObject.OperationOnMember(System.Dynamic.Binders.OperationOnMemberBinder,System.Object)">
            <summary>
            When overridden in a derived class provides the non-Meta implementation of
            performing an operation on member "a.b (op)=c" operation.
            
            When not overridden the call site requesting the binder determines the behavior.
            </summary>
        </member>
        <member name="M:System.Dynamic.Binders.DynamicObject.OperationOnIndex(System.Dynamic.Binders.OperationOnIndexBinder,System.Object[])">
            <summary>
            When overridden in a derived class provides the non-Meta implementation of
            performing an operation on index "a[i,j,k] (op)= c" operation.
            
            When not overridden the call site requesting the binder determines the behavior.
            </summary>
        </member>
        <member name="M:System.Dynamic.Binders.DynamicObject.System#Dynamic#Binders#IDynamicObject#GetMetaObject(System.Linq.Expressions.Expression)">
            <summary>
            The provided MetaObject will dispatch to the Dynamic virtual methods.
            The object can be encapsulated inside of another MetaObject to
            provide custom behavior for individual actions.
            </summary>
        </member>
        <member name="M:System.Dynamic.Binders.MetaObject.BindOperationOnMember(System.Dynamic.Binders.OperationOnMemberBinder,System.Dynamic.Binders.MetaObject)">
            <summary>
            Binds an operation a.b (op)= c
            </summary>
            <param name="binder">Binder implementing the language semantics.</param>
            <param name="value">Meta Object representing the right-side argument.</param>
            <returns>MetaObject representing the result of the binding.</returns>
        </member>
        <member name="M:System.Dynamic.Binders.MetaObject.BindOperationOnIndex(System.Dynamic.Binders.OperationOnIndexBinder,System.Dynamic.Binders.MetaObject[])">
            <summary>
            Binds an operation a[i,j,k] (op)= c
            </summary>
            <param name="binder">Binder implementing the language semantics.</param>
            <param name="args">MetaObjects representing the indexes and the right-hand value.</param>
            <returns>MetaObject representing the result of the binding.</returns>
        </member>
        <member name="M:System.Dynamic.Binders.DynamicObject.MetaDynamic.CallMethodUnary(System.Dynamic.Binders.MetaObjectBinder,System.String)">
            <summary>
            Helper method for generating a MetaObject which calls a specific method on Dynamic
            w/o any additional parameters.
            </summary>
        </member>
        <member name="M:System.Dynamic.Binders.DynamicObject.MetaDynamic.CallMethodBinary(System.Dynamic.Binders.MetaObjectBinder,System.Dynamic.Binders.MetaObject,System.String)">
            <summary>
            Helper method for generating a MetaObject which calls a specific method declared on
            Dynamic w/ one additional parameter.
            </summary>
        </member>
        <member name="M:System.Dynamic.Binders.DynamicObject.MetaDynamic.CallMethodNAry(System.Dynamic.Binders.MetaObjectBinder,System.Dynamic.Binders.MetaObject[],System.String)">
            <summary>
            Helper method for generating a MetaObject which calls a specific method on Dynamic w/ the
            meta object array as the params.
            </summary>
        </member>
        <member name="M:System.Dynamic.Binders.DynamicObject.MetaDynamic.GetActionToArgs(System.Dynamic.Binders.MetaObjectBinder,System.Dynamic.Binders.MetaObject[])">
            <summary>
            Returns the parameters for a call to one of our helpers.  It adds the MetaAction
            first and packs the parameters into an object array.
            </summary>
        </member>
        <member name="M:System.Dynamic.Binders.DynamicObject.MetaDynamic.IsOverridden(System.String)">
            <summary>
            Checks if the derived type has overridden the specified method.  If there is no
            implementation for the method provided then Dynamic falls back to the base class
            behavior which lets the call site determine how the binder is performed.
            </summary>
        </member>
        <member name="M:System.Dynamic.Binders.DynamicObject.MetaDynamic.GetRestrictions">
            <summary>
            Returns a Restrictions object which includes our current restrictions merged
            with a restriction limiting our type
            </summary>
        </member>
        <member name="M:System.Dynamic.Binders.DynamicObject.MetaDynamic.GetLimitedSelf">
            <summary>
            Returns our Expression converted to our known LimitType
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Compiler.ILGen.BeginCatchBlock(System.Type)">
            <summary>
            Begins a catch block.
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Compiler.ILGen.BeginExceptFilterBlock">
            <summary>
            Begins an exception block for a filtered exception.
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Compiler.ILGen.BeginExceptionBlock">
            <summary>
            Begins an exception block for a non-filtered exception.
            </summary>
            <returns></returns>
        </member>
        <member name="M:System.Linq.Expressions.Compiler.ILGen.BeginFaultBlock">
            <summary>
            Begins an exception fault block
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Compiler.ILGen.BeginFinallyBlock">
            <summary>
            Begins a finally block
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Compiler.ILGen.EndExceptionBlock">
            <summary>
            Ends an exception block.
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Compiler.ILGen.BeginScope">
            <summary>
            Begins a lexical scope.
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Compiler.ILGen.EndScope">
            <summary>
            Ends a lexical scope.
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Compiler.ILGen.DeclareLocal(System.Type)">
            <summary>
            Declares a local variable of the specified type.
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Compiler.ILGen.DeclareLocal(System.Type,System.Boolean)">
            <summary>
            Declares a local variable of the specified type, optionally
            pinning the object referred to by the variable.
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Compiler.ILGen.DefineLabel">
            <summary>
            Declares a new label.
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Compiler.ILGen.MarkLabel(System.Reflection.Emit.Label)">
            <summary>
            Marks the label at the current position.
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Compiler.ILGen.Emit(System.Reflection.Emit.OpCode)">
            <summary>
            Emits an instruction.
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Compiler.ILGen.Emit(System.Reflection.Emit.OpCode,System.Byte)">
            <summary>
            Emits an instruction with a byte argument.
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Compiler.ILGen.Emit(System.Reflection.Emit.OpCode,System.Reflection.ConstructorInfo)">
            <summary>
            Emits an instruction with the metadata token for the specified contructor.
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Compiler.ILGen.Emit(System.Reflection.Emit.OpCode,System.Double)">
            <summary>
            Emits an instruction with a double argument.
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Compiler.ILGen.Emit(System.Reflection.Emit.OpCode,System.Reflection.FieldInfo)">
            <summary>
            Emits an instruction with the metadata token for the specified field.
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Compiler.ILGen.Emit(System.Reflection.Emit.OpCode,System.Single)">
            <summary>
            Emits an instruction with a float argument.
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Compiler.ILGen.Emit(System.Reflection.Emit.OpCode,System.Int32)">
            <summary>
            Emits an instruction with an int argument.
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Compiler.ILGen.Emit(System.Reflection.Emit.OpCode,System.Reflection.Emit.Label)">
            <summary>
            Emits an instruction with a label argument.
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Compiler.ILGen.Emit(System.Reflection.Emit.OpCode,System.Reflection.Emit.Label[])">
            <summary>
            Emits an instruction with multiple target labels (switch).
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Compiler.ILGen.Emit(System.Reflection.Emit.OpCode,System.Reflection.Emit.LocalBuilder)">
            <summary>
            Emits an instruction with a reference to a local variable.
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Compiler.ILGen.Emit(System.Reflection.Emit.OpCode,System.Int64)">
            <summary>
            Emits an instruction with a long argument.
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Compiler.ILGen.Emit(System.Reflection.Emit.OpCode,System.Reflection.MethodInfo)">
            <summary>
            Emits an instruction with the metadata token for a specified method.
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Compiler.ILGen.Emit(System.Reflection.Emit.OpCode,System.SByte)">
            <summary>
            Emits an instruction with a signed byte argument.
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Compiler.ILGen.Emit(System.Reflection.Emit.OpCode,System.Int16)">
            <summary>
            Emits an instruction with a short argument.
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Compiler.ILGen.Emit(System.Reflection.Emit.OpCode,System.Reflection.Emit.SignatureHelper)">
            <summary>
            Emits an instruction with a signature token.
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Compiler.ILGen.Emit(System.Reflection.Emit.OpCode,System.String)">
            <summary>
            Emits an instruction with a string argument.
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Compiler.ILGen.Emit(System.Reflection.Emit.OpCode,System.Type)">
            <summary>
            Emits an instruction with the metadata token for a specified type argument.
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Compiler.ILGen.EmitCall(System.Reflection.Emit.OpCode,System.Reflection.MethodInfo,System.Type[])">
            <summary>
            Emits a call or a virtual call to the varargs method.
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Compiler.ILGen.EmitCalli(System.Reflection.Emit.OpCode,System.Runtime.InteropServices.CallingConvention,System.Type,System.Type[])">
            <summary>
            Emits an unmanaged indirect call instruction.
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Compiler.ILGen.EmitCalli(System.Reflection.Emit.OpCode,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[])">
            <summary>
            Emits a managed indirect call instruction.
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Compiler.ILGen.MarkSequencePoint(System.Diagnostics.SymbolStore.ISymbolDocumentWriter,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Marks a sequence point.
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Compiler.ILGen.UsingNamespace(System.String)">
            <summary>
            Specifies the namespace to be used in evaluating locals and watches for the
                current active lexical scope.
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Compiler.ILGen.EmitLoadValueIndirect(System.Type)">
            <summary>
            Emits a Ldind* instruction for the appropriate type
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Compiler.ILGen.EmitStoreValueIndirect(System.Type)">
            <summary>
            Emits a Stind* instruction for the appropriate type.
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Compiler.ILGen.EmitStoreElement(System.Type)">
            <summary>
            Emits a Stelem* instruction for the appropriate type.
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Compiler.ILGen.EmitBoxing(System.Type)">
            <summary>
            Boxes the value of the stack. No-op for reference types. Void is
            converted to a null reference. For almost all value types this
            method will box them in the standard way. Int32 and Boolean are
            handled with optimized conversions that reuse the same object for
            small values. For Int32 this is purely a performance optimization.
            For Boolean this is use to ensure that True and False are always
            the same objects.
            
            TODO: do we still need this?
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Compiler.ILGen.EmitArray``1(System.Collections.Generic.IList{``0})">
            <summary>
            Emits an array of constant values provided in the given list.
            The array is strongly typed.
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Compiler.ILGen.EmitArray(System.Type,System.Int32,System.Action{System.Int32})">
            <summary>
            Emits an array of values of count size.  The items are emitted via the callback
            which is provided with the current item index to emit.
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Compiler.ILGen.EmitArray(System.Type)">
            <summary>
            Emits an array construction code.  
            The code assumes that bounds for all dimensions
            are already emitted.
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Compiler.ILGen.EmitDefault(System.Type)">
            <summary>
            Emits default(T)
            Semantics match C# compiler behavior
            </summary>
        </member>
        <member name="T:System.Linq.Expressions.Compiler.Set`1">
            <summary>
            A simple hashset, built on Dictionary{K, V}
            
            TODO: should remove this in favor of HashSet{T}
            </summary>
        </member>
        <member name="T:System.Dynamic.ComInterop.ComObject">
            <summary>
            This is a helper class for runtime-callable-wrappers of COM instances. We create one instance of this type
            for every generic RCW instance.
            </summary>
        </member>
        <member name="F:System.Dynamic.ComInterop.ComObject._rcw">
            <summary>
            The runtime-callable wrapper
            </summary>
        </member>
        <member name="M:System.Dynamic.ComInterop.ComObject.ObjectToComObject(System.Object)">
            <summary>
            This is the factory method to get the ComObject corresponding to an RCW
            </summary>
            <returns></returns>
        </member>
        <member name="M:System.Linq.Expressions.Compiler.DelegateHelpers.MakeCallSiteDelegate(System.Collections.ObjectModel.ReadOnlyCollection{System.Linq.Expressions.Expression},System.Type)">
            <summary>
            Finds a delegate type for a CallSite using the types in the ReadOnlyCollection of Expression. 
            
            We take the ROC of Expression explicitly to avoid allocating memory (an array of types) on
            lookup of delegate types.
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Compiler.DelegateHelpers.MakeDeferredSiteDelegate(System.Dynamic.Binders.MetaObject[],System.Type)">
            <summary>
            Finds a delegate type for a CallSite using the MetaObject array. 
            
            We take the array of MetaObject explicitly to avoid allocating memory (an array of types) on
            lookup of delegate types.
            </summary>
        </member>
        <member name="M:System.Dynamic.Binders.DynamicSiteHelpers.CreateDynamicMethod(System.Boolean,System.String,System.Type,System.Type[])">
            <summary>
            Dynamic code generation required by dynamic sites needs to be able to call the delegate by which the
            call site is parametrized. If the delegate type is visible, we can generate into assembly (if saving
            assemblies). With delegate types that are not visible we must generate LCG in order to skip visibility.
            </summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.CallSiteRule`1">
            <summary>
            This type is only used by CallSite internally. Do not use
            </summary>
        </member>
        <member name="F:System.Runtime.CompilerServices.CallSiteRule`1.RuleSet">
            <summary>
            The rule set that includes only this rule.
            </summary>
        </member>
        <member name="F:System.Runtime.CompilerServices.CallSiteRule`1._binding">
            <summary>
            The binding expression tree
            </summary>
        </member>
        <member name="F:System.Runtime.CompilerServices.CallSiteRule`1._template">
            <summary>
            Template data - null for methods which aren't templated.  Non-null for methods which
            have been templated.  The same template data is shared across all templated rules with
            the same target method.
            </summary>
        </member>
        <member name="P:System.Runtime.CompilerServices.CallSiteRule`1.Binding">
            <summary>
            The expression representing the bound operation
            </summary>
        </member>
        <member name="P:System.Runtime.CompilerServices.CallSiteRule`1.TemplateMethod">
            <summary>
            Gets or sets the method which is used for templating. If the rule is
            not templated then this is a nop (and returns null for the getter).
            
            The method is tracked here independently from the delegate for the
            common case of the method being a DynamicMethod.  In order to re-bind
            the existing DynamicMethod to a new set of templated parameters we need
            to have the original method.
            </summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.TemplateData`1">
            <summary>
            Data used for tracking templating information in a rule.
            
            Currently we just track the method so we can retarget to
            new constant pools.
            </summary>
        </member>
        <member name="T:System.Linq.Expressions.Compiler.StackSpiller">
            <summary>
            Expression rewriting to spill the CLR stack into temporary variables
            in order to guarantee some properties of code generation, for
            example that we always enter try block on empty stack.
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Compiler.StackSpiller.RewriteExpression(System.Linq.Expressions.Expression,System.Linq.Expressions.Compiler.StackSpiller.Stack)">
            <summary>
            Rewrite the expression
            </summary>
            
            <param name="node">Expression to rewrite</param>
            <param name="stack">State of the stack before the expression is emitted.</param>
            <returns>Rewritten expression.</returns>
        </member>
        <member name="M:System.Linq.Expressions.Compiler.StackSpiller.ToTemp(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression@)">
            <summary>
            Will perform:
                save: temp = expression
                return value: temp
            </summary>
        </member>
        <member name="F:System.Linq.Expressions.Compiler.StackSpiller._tm">
            <summary>
            The source of temporary variables
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Compiler.StackSpiller.AnalyzeLambda(System.Linq.Expressions.LambdaExpression)">
            <summary>
            Analyzes a lambda, producing a new one that has correct invariants
            for codegen. In particular, it spills the IL stack to temps in
            places where it's invalid to have a non-empty stack (for example,
            entering a try statement).
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Compiler.StackSpiller.Clone``1(System.Collections.ObjectModel.ReadOnlyCollection{``0},System.Int32)">
            <summary>
            Will clone an IList into an array of the same size, and copy
            all vaues up to (and NOT including) the max index
            </summary>
            <returns>The cloned array.</returns>
        </member>
        <member name="F:System.Linq.Expressions.Compiler.StackSpiller.TempMaker._temp">
            <summary>
            Current temporary variable
            </summary>
        </member>
        <member name="F:System.Linq.Expressions.Compiler.StackSpiller.TempMaker._freeTemps">
            <summary>
            List of free temporary variables. These can be recycled for new temps.
            </summary>
        </member>
        <member name="F:System.Linq.Expressions.Compiler.StackSpiller.TempMaker._usedTemps">
            <summary>
            Stack of currently active temporary variables.
            </summary>
        </member>
        <member name="F:System.Linq.Expressions.Compiler.StackSpiller.TempMaker._temps">
            <summary>
            List of all temps created by stackspiller for this rule/lambda
            </summary>
        </member>
        <member name="T:System.Linq.Expressions.Compiler.StackSpiller.ChildRewriter">
            <summary>
            Rewrites child expressions, spilling them into temps if needed. The
            stack starts in the inital state, and after the first subexpression
            is added it is change to non-empty. This behavior can be overriden
            by setting the stack manually between adds.
            
            When all children have been added, the caller should rewrite the 
            node if Rewrite is true. Then, it should call crFinish with etiher
            the orignal expression or the rewritten expression. Finish will call
            Expression.Comma if necessary and return a new Result.
            </summary>
        </member>
        <member name="T:System.Dynamic.ComInterop.Variant">
            <summary>
            Variant is the basic COM type for late-binding. It can contain any other COM data type.
            This type definition precisely matches the unmanaged data layout so that the struct can be passed
            to and from COM calls.
            </summary>
        </member>
        <member name="M:System.Dynamic.ComInterop.Variant.IsPrimitiveType(System.Runtime.InteropServices.VarEnum)">
            <summary>
            Primitive types are the basic COM types. It includes valuetypes like ints, but also reference tyeps
            like BStrs. It does not include composite types like arrays and user-defined COM types (IUnknown/IDispatch).
            </summary>
        </member>
        <member name="M:System.Dynamic.ComInterop.Variant.ToObject">
            <summary>
            Get the managed object representing the Variant.
            </summary>
            <returns></returns>
        </member>
        <member name="M:System.Dynamic.ComInterop.Variant.Clear">
            <summary>
            Release any unmanaged memory associated with the Variant
            </summary>
            <returns></returns>
        </member>
        <member name="T:System.Dynamic.ComInterop.IDispatchMethodIndices">
            <summary>
            Layout of the IDispatch vtable
            </summary>
        </member>
        <member name="T:System.Linq.Expressions.IArgumentProvider">
            <summary>
            Provides an internal interface for accessing the arguments that multiple tree
            nodes (DynamicExpression, ElementInit, MethodCallExpression, InvocationExpression, NewExpression,
            and InexExpression).
            
            This enables two optimizations which reduce the size of the trees.  The first is it enables
            the nodes to hold onto an IList of T instead of a ReadOnlyCollection.  This saves the cost
            of allocating the ReadOnlyCollection for each node.  The second is that it enables specialized
            subclasses to be created which hold onto a specific number of arguments.  For example Block2,
            Block3, Block4.  These nodes can therefore avoid allocating both a ReadOnlyCollection and an
            array for storing their elements saving 32 bytes per node.
            
            Meanwhile the nodes can continue to expose the original LINQ properties of ReadOnlyCollections.  They
            do this by re-using 1 field for storing both the array or an element that would normally be stored
            in the array.  
            
            For the array case the collection is typed to IList of T instead of ReadOnlyCollection of T.
            When the node is initially constructed it is an array.  When the compiler accesses the members it
            uses this interface.  If a user accesses the members the array is promoted to a ReadOnlyCollection.
            
            For the object case we store the 1st argument in a field typed to object and when the node is initially
            constructed this holds directly onto the Expression.  When the compiler accesses the members
            it again uses this interface and the accessor for the 1st argument uses Expression.ReturnObject to
            return the object which handles the Expression or ReadOnlyCollection case.  When the user accesses
            the ReadOnlyCollection then the object field is updated to hold directly onto the ReadOnlyCollection.
            
            It is important that the Expressions consistently return the same ReadOnlyCollection otherwise the
            re-writer will be broken and it would be a breaking change from LINQ v1.  The problem is that currently
            users can rely on object identity to tell if the node has changed.  Storing the ROC in an overloaded
            field enables us to both reduce memory usage as well as maintain compatibility and an easy to use external
            API.
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.MethodCallExpression.Rewrite(System.Linq.Expressions.Expression,System.Collections.Generic.IList{System.Linq.Expressions.Expression})">
            <summary>
            Returns a new MethodCallExpression replacing the existing instance/args with the
            newly provided instance and args.    Arguments can be null to use the existing
            arguments.
            
            This helper is provided to allow re-writing of nodes to not depend on the specific optimized
            subclass of MethodCallExpression which is being used. 
            </summary>
        </member>
        <member name="T:System.Linq.Expressions.MemberExpression">
            <summary>
            Member expression (statically typed) which represents 
            property or field access, both static and instance.
            For instance property/field, Expression must be != null.
            </summary>
        </member>
        <member name="T:System.Dynamic.Binders.OperationOnIndexBinder">
            <summary>
            A Binder that is responsible for runtime binding of operation:
            a[b] (op)= c
            </summary>
        </member>
        <member name="M:System.Dynamic.Binders.OperationOnIndexBinder.#ctor(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.ArgumentInfo[])">
            <summary>
            Constructor of the OperationOnIndexBinder object, representing "a[b] (op)= c" operation.
            </summary>
            <param name="operation">Binary operation to be performed.</param>
            <param name="arguments">Description of the indexes (named, positional)</param>
        </member>
        <member name="M:System.Dynamic.Binders.OperationOnIndexBinder.Equals(System.Object)">
            <summary>
            Implements Equality operation for the OperationOnIndexBinder
            </summary>
            <param name="obj">Instance to comapre equal to.</param>
            <returns>true/false</returns>
        </member>
        <member name="M:System.Dynamic.Binders.OperationOnIndexBinder.GetHashCode">
            <summary>
            Calculates hash code for the OperationOnIndexBinder
            </summary>
            <returns>The hash code.</returns>
        </member>
        <member name="M:System.Dynamic.Binders.OperationOnIndexBinder.Bind(System.Dynamic.Binders.MetaObject,System.Dynamic.Binders.MetaObject[])">
            <summary>
            Performs binding of the operation on the target (represented as meta object) and
            list of arguments (indexes and right-hand value) represented as meta objects
            </summary>
            <param name="target">Target of the operation.</param>
            <param name="args">List of indexes and right-hand value</param>
            <returns>MetaObject representing the binding.</returns>
        </member>
        <member name="M:System.Dynamic.Binders.OperationOnIndexBinder.FallbackOperation(System.Dynamic.Binders.MetaObject,System.Dynamic.Binders.MetaObject)">
            <summary>
            Implements a binding logic for the binary operation part of the binding.
            This is called by the target when the target implements the whole operation:
               a[b] += c
            as:
               a[b] = a[b] + c
            to let the language participate in the binding of the binary operation only.
            </summary>
            <param name="target">Target of the operation.</param>
            <param name="arg">Right-hand operator value</param>
            <returns>MetaObject representing the binding result.</returns>
        </member>
        <member name="M:System.Dynamic.Binders.OperationOnIndexBinder.FallbackOperation(System.Dynamic.Binders.MetaObject,System.Dynamic.Binders.MetaObject,System.Dynamic.Binders.MetaObject)">
            <summary>
            Implements a binding logic for the binary operation part of the binding.
            This is called by the target when the target implements the whole operation:
               a[b] += c
            as:
               a[b] = a[b] + c
            to let the language participate in the binding of the binary operation only.
            </summary>
            <param name="target">Target of the operation.</param>
            <param name="arg">Right-hand operator value</param>
            <param name="errorSuggestion">The representaiton of the binding error that the target meta object recommends the language to use if the language cannot bind. This allows the target meta object to participate in the error handling process.</param>
            <returns>MetaObject representing the binding result.</returns>
        </member>
        <member name="M:System.Dynamic.Binders.OperationOnIndexBinder.FallbackOperationOnIndex(System.Dynamic.Binders.MetaObject,System.Dynamic.Binders.MetaObject[])">
            <summary>
            Implements a binding logic for the operation. This is called by the target when
            the target lets the executing language participate in the binding process.
            </summary>
            <param name="target">Target of the operation.</param>
            <param name="args">List of indexes and right-hand value</param>
            <returns>MetaObject representing the binding.</returns>
        </member>
        <member name="M:System.Dynamic.Binders.OperationOnIndexBinder.FallbackOperationOnIndex(System.Dynamic.Binders.MetaObject,System.Dynamic.Binders.MetaObject[],System.Dynamic.Binders.MetaObject)">
            <summary>
            Implements a binding logic for the operation. This is called by the target when
            the target lets the executing language participate in the binding process.
            </summary>
            <param name="target">Target of the operation.</param>
            <param name="args">List of indexes and right-hand value</param>
            <param name="errorSuggestion">The representaiton of the binding error that the target meta object recommends the language to use if the language cannot bind. This allows the target meta object to participate in the error handling process.</param>
            <returns>MetaObject representing the binding.</returns>
        </member>
        <member name="P:System.Dynamic.Binders.OperationOnIndexBinder.Operation">
            <summary>
            The operation to be performed.
            </summary>
        </member>
        <member name="P:System.Dynamic.Binders.OperationOnIndexBinder.Arguments">
            <summary>
            Descriptions of arguments to the indexer. This allows for named and positional arguments.
            </summary>
        </member>
        <member name="T:System.Linq.Expressions.ExpressionVisitor">
            <summary>
            Base class for visiting and rewriting trees. Subclasses can override
            individual Visit methods from which they can return rewritten nodes.
            If a node is rewritten, all parent nodes will be rewritten
            automatically.
            
            TODO: rename back to ExpressionVisitor (fix the Linq test that has a copy)
            TODO: needs public API vetting
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.ExpressionVisitor.Visit``1(System.Collections.ObjectModel.ReadOnlyCollection{``0},System.Func{``0,``0})">
            <summary>
            Visits all nodes in the collection using a specified element visitor.
            </summary>
            <typeparam name="T">Element type.</typeparam>
            <param name="nodes">Input collection.</param>
            <param name="elementVisitor">Delegate that visits a single element.</param>
            <returns>Collection of visited nodes. Original collection is returned if no nodes were modified.</returns>
        </member>
        <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitAndConvert``1(System.Collections.ObjectModel.ReadOnlyCollection{``0},System.String)">
            <summary>
            Visits all of the nodes in the collection, and tries to convert each
            result back to the original type. If any conversion fails, it
            throws an error
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitExtension(System.Linq.Expressions.Expression)">
            <summary>
            Override called for Extension nodes. This can be overriden to
            rewrite certain extension nodes. If it's not overriden, this method
            will call into Expression.Visit, which gives the node a chance to
            walk its children
            </summary>
        </member>
        <member name="T:System.Linq.Expressions.LambdaExpression">
            <summary>
            This captures a block of code that should correspond to a .NET method
            body. It takes input through parameters and is expected to be fully
            bound. This code can then be generated in a variety of ways. The
            variables can be kept as .NET locals or hoisted into an object bound to
            the delegate. This is the primary unit used for passing around
            Expression Trees in LINQ and the DLR.
            </summary>
        </member>
        <member name="T:System.Linq.Expressions.LabelExpression">
            <summary>
            Represents a label, which can be placed in any Expression context. If
            it is jumped to, it will get the value provided by the corresponding
            GotoExpression. Otherwise, it gets the value in DefaultValue. If the
            Type equals System.Void, no value should be provided
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.LabelExpression.DefaultValue">
            <summary>
            The value of the LabelExpression when the label is reached through
            normal control flow (e.g. is not jumped to)
            </summary>
        </member>
        <member name="T:System.Linq.Expressions.DebugInfoExpression">
            <summary>
            Wraps an expression, emitting a sequence point around it
            
            This allows the debugger to highlight the correct source code when
            debugging.
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.DebugInfoExpression.Reduce">
            <summary>
            Returns the underlying expression
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.DebugInfoExpression.Document">
            <summary>
            Information about the source file
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.DebugInfoExpression.Expression">
            <summary>
            The underlying expression to be evaluated
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.ExpressionStringBuilder.ExpressionToString(System.Linq.Expressions.Expression)">
            <summary>
            Output a given expression tree to a string.
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.ExpressionStringBuilder.MemberBindingToString(System.Linq.Expressions.MemberBinding)">
            <summary>
            Output a given member binding to a string.
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.ExpressionStringBuilder.ElementInitBindingToString(System.Linq.Expressions.ElementInit)">
            <summary>
            Output a given ElementInit to a string.
            </summary>
        </member>
        <member name="M:System.Dynamic.Utils.CollectionExtensions.ToReadOnly``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Wraps the provided enumerable into a ReadOnlyCollection{T}
            
            Copies all of the data into a new array, so the data can't be
            changed after creation. The exception is if the enumerable is
            already a ReadOnlyCollection{T}, in which case we just return it.
            </summary>
        </member>
        <member name="T:System.Linq.Expressions.Compiler.HoistedLocals">
            <summary>
            Stores information about locals and arguments that are hoisted into
            the closure array because they're referenced in an inner lambda.
            
            This class is sometimes emitted as a runtime constant for internal
            use to hoist variables/parameters in quoted expressions
            
            Invariant: this class stores no mutable state
            </summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.Closure">
            <summary>
            If the delegate generated by the Lambda compiler needs to either be a
            closure, or close over constants, the delegate itself will close over
            the instance of this object.
            
            TODO: Prevent this from being exposed as public surface area. See what
            Linq v1 does with System.Runtime.CompilerServices.ExecutionScope
            </summary>
        </member>
        <member name="F:System.Runtime.CompilerServices.Closure.Constants">
            <summary>
            The constant pool
            </summary>
        </member>
        <member name="F:System.Runtime.CompilerServices.Closure.Locals">
            <summary>
            The environment, which stores closed over variables from the parent
            scope
            </summary>
        </member>
        <member name="T:System.Dynamic.ComInterop.DispCallable">
            <summary>
            This represents a bound dispmethod on a IDispatch object.
            </summary>
        </member>
        <member name="T:System.Dynamic.ComInterop.NullArgBuilder">
            <summary>
            ArgBuilder which always produces null.  
            </summary>
        </member>
        <member name="T:System.Dynamic.Binders.SmallRuleSet`1">
            <summary>
            This holds a set of rules for a particular DynamicSite.  Any given
            SmallRuleSet instance is immutable and therefore they may be cached
            and shared.  At the moment, the only ones that are shared are
            SmallRuleSets with a single rule.
            
            When a new rule is added, then a new SmallRuleSet will be created
            that contains all existing rules that are still considered valid with
            the new rule added to the front of the list.  The target generated for
            this type will simply try each of the rules in order and emit the
            standard DynamicSite.UpdateBindingAndInvoke fallback call at the end.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:System.Dynamic.Binders.RuleSet`1">
            <summary>
            A RuleSet is a collection of rules to apply to the objects at a DynamicSite.  Each Rule also
            includes a target that is to be called if the rules' conditions are met.
            RuleSets are all immutable.
            </summary>
        </member>
        <member name="T:System.Dynamic.Binders.ExpandoClass">
            <summary>
            Represents a dynamically assigned class.  Expando objects which share the same 
            members will share the same class.  Classes are dynamically assigned as the
            expando object gains members.
            </summary>
        </member>
        <member name="M:System.Dynamic.Binders.ExpandoClass.#ctor">
            <summary>
            Constructs the empty ExpandoClass.  This is the class used when an
            empty Expando object is initially constructed.
            </summary>
        </member>
        <member name="M:System.Dynamic.Binders.ExpandoClass.#ctor(System.String[],System.Int32)">
            <summary>
            Constructs a new ExpandoClass that can hold onto the specified keys.  The
            keys must be sorted ordinally.  The hash code must be precalculated for 
            the keys.
            </summary>
        </member>
        <member name="M:System.Dynamic.Binders.ExpandoClass.FindNewClass(System.String,System.Boolean)">
            <summary>
            Finds or creates a new ExpandoClass given the existing set of keys
            in this ExpandoClass plus the new key to be added.
            </summary>
        </member>
        <member name="M:System.Dynamic.Binders.ExpandoClass.GetNewKeys(System.Object[])">
            <summary>
            Gets a new object array for storing the data that matches this
            ExpandoClass given the old ExpandoClass and the instances associated 
            data array.
            </summary>
        </member>
        <member name="M:System.Dynamic.Binders.ExpandoClass.GetTransitionList(System.Int32)">
            <summary>
            Gets the lists of transitions that are valid from this ExpandoClass
            to an ExpandoClass whos keys hash to the apporopriate hash code.
            </summary>
        </member>
        <member name="M:System.Dynamic.Binders.ExpandoClass.GetValueIndex(System.String,System.Boolean)">
            <summary>
            Gets the index at which the value should be stored for the specified name.
            </summary>
        </member>
        <member name="M:System.Dynamic.Binders.ExpandoClass.GetIndexName(System.Int32)">
            <summary>
            Gets the name of the specified index.  Used for getting the name to 
            create a new expando class when all we have is the class and old index.
            </summary>
        </member>
        <member name="P:System.Dynamic.Binders.ExpandoClass.Keys">
            <summary>
            Gets the names of the keys that can be stored in the Expando class.  The
            list is sorted ordinally.
            </summary>
        </member>
        <member name="T:System.Dynamic.Binders.ExpandoObject">
            <summary>
            Simple type which implements IDynamicObject to support getting/setting/deleting members
            at runtime.
            </summary>
        </member>
        <member name="M:System.Dynamic.Binders.ExpandoObject.#ctor">
            <summary>
            Creates a new Expando object with no members.
            </summary>
        </member>
        <member name="M:System.Dynamic.Binders.ExpandoObject.GetValue(System.Dynamic.Binders.ExpandoClass,System.Int32,System.Boolean)">
            <summary>
            Gets the data stored for the specified class at the specified index.  If the
            class has changed a full lookup for the slot will be performed and the correct
            value will be retrieved.
            </summary>
        </member>
        <member name="M:System.Dynamic.Binders.ExpandoObject.SetValue(System.Dynamic.Binders.ExpandoClass,System.Int32,System.Boolean,System.Object)">
            <summary>
            Sets the data for the specified class at the specified index.  If the class has
            changed then a full look for the slot will be performed.  If the new class does
            not have the provided slot then the Expando's class will change.
            </summary>
        </member>
        <member name="M:System.Dynamic.Binders.ExpandoObject.DeleteValue(System.Dynamic.Binders.ExpandoClass,System.Int32,System.Boolean)">
            <summary>
            Gets the data stored for the specified class at the specified index.  If the
            class has changed a full lookup for the slot will be performed and the correct
            value will be retrieved.
            </summary>
        </member>
        <member name="M:System.Dynamic.Binders.ExpandoObject.PromoteClassWorker(System.Dynamic.Binders.ExpandoClass,System.Dynamic.Binders.ExpandoClass)">
            <summary>
            Promotes the class from the old type to the new type and returns the new
            ExpandoData object.
            </summary>
        </member>
        <member name="M:System.Dynamic.Binders.ExpandoObject.PromoteClass(System.Dynamic.Binders.ExpandoClass,System.Dynamic.Binders.ExpandoClass)">
            <summary>
            Internal helper to promote a class.  Called from our RuntimeOps helper.  This
            version simply doesn't expose the ExpandoData object which is a private
            data structure.
            </summary>
        </member>
        <member name="P:System.Dynamic.Binders.ExpandoObject.Class">
            <summary>
            Exposes the ExpandoClass which we've associated with this 
            Expando object.  Used for type checks in rules.
            </summary>
        </member>
        <member name="M:System.Dynamic.Binders.ExpandoObject.MetaExpando.AddDynamicTestAndDefer(System.Dynamic.Binders.MetaObjectBinder,System.Dynamic.Binders.MetaObject[],System.Dynamic.Binders.ExpandoClass,System.Dynamic.Binders.ExpandoClass,System.Linq.Expressions.Expression)">
            <summary>
            Adds a dynamic test which checks if the version has changed.  The test is only necessary for
            performance as the methods will do the correct thing if called with an incorrect version.
            </summary>
        </member>
        <member name="M:System.Dynamic.Binders.ExpandoObject.MetaExpando.GetClassEnsureIndex(System.String,System.Boolean,System.Dynamic.Binders.ExpandoClass@,System.Int32@)">
            <summary>
            Gets the class and the index associated with the given name.  Does not update the expando object.  Instead
            this returns both the original and desired new class.  A rule is created which includes the test for the
            original class, the promotion to the new class, and the set/delete based on the class post-promotion.
            </summary>
        </member>
        <member name="M:System.Dynamic.Binders.ExpandoObject.MetaExpando.GetLimitedSelf">
            <summary>
            Returns our Expression converted to our known LimitType
            </summary>
        </member>
        <member name="M:System.Dynamic.Binders.ExpandoObject.MetaExpando.GetRestrictions">
            <summary>
            Returns a Restrictions object which includes our current restrictions merged
            with a restriction limiting our type
            </summary>
        </member>
        <member name="T:System.Dynamic.Binders.ExpandoObject.ExpandoData">
            <summary>
            Stores the class and the data associated with the class as one atomic
            pair.  This enables us to do a class check in a thread safe manner w/o
            requiring locks.
            </summary>
        </member>
        <member name="F:System.Dynamic.Binders.ExpandoObject.ExpandoData.Class">
            <summary>
            the dynamically assigned class associated with the Expando object
            </summary>
        </member>
        <member name="F:System.Dynamic.Binders.ExpandoObject.ExpandoData.Data">
            <summary>
            data stored in the expando object, key names are stored in the class.
            
            Expando._data must be locked when mutating the value.  Otherwise a copy of it 
            could be made and lose values.
            </summary>
        </member>
        <member name="M:System.Dynamic.Binders.ExpandoObject.ExpandoData.#ctor">
            <summary>
            Constructs an empty ExpandoData object with the empty class and no data.
            </summary>
        </member>
        <member name="M:System.Dynamic.Binders.ExpandoObject.ExpandoData.#ctor(System.Dynamic.Binders.ExpandoClass,System.Object[])">
            <summary>
            Constructs a new ExpandoData object with the specified class and data.
            </summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.RuntimeOps.MergedRuntimeVariables">
            <summary>
            Provides a list of variables, supporing read/write of the values
            Exposed via RuntimeVariablesExpression
            </summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.RuntimeOps.RuntimeVariableList">
            <summary>
            Provides a list of variables, supporing read/write of the values
            Exposed via RuntimeVariablesExpression
            </summary>
        </member>
        <member name="T:System.Dynamic.Null">
            <summary>
            Gives us a concrete Type object to represent null's to allow for more uniform
            handling of methods that expect a Type or Type[].  This type can also be used by
            languages that support methods on null objects by adding extension methods with a
            Null/None this.
            </summary>
        </member>
        <member name="M:System.Dynamic.Null.#ctor">
            <summary>
            Private constructor is never called since 'null' is the only valid instance.
            </summary>
        </member>
        <member name="F:System.Runtime.CompilerServices.StrongBox`1.Value">
            <summary>
            Gets the strongly typed value associated with the StrongBox.  This is explicitly
            exposed as a field instead of a property to enable loading the address of the field.
            </summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.StrongBox`1.#ctor">
            <summary>
            Creates a new StrongBox which can receive a value when used in a reference call.
            TODO: review this new API
            </summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.StrongBox`1.#ctor(`0)">
            <summary>
            Creates a new StrongBox with the specified value.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:System.Linq.Expressions.ExpressionWriter.Dump(System.Linq.Expressions.Expression,System.String,System.IO.TextWriter)">
            <summary>
            Write out the given AST
            </summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.CallSiteOps">
            <summary>
            Do not use this type. It is for internal use by CallSite
            </summary>
        </member>
        <member name="T:System.Dynamic.ComInterop.ComEventSinksContainer">
            <summary>
            ComEventSinksContainer is just a regular list with a finalizer.
            This list is usually attached as a custom data for RCW object and 
            is finalized whenever RCW is finalized.
            </summary>
        </member>
        <member name="T:System.Dynamic.ComInterop.ComEventSink">
            <summary>
            This class implements an event sink for a particular RCW.
            Unlike the implementation of events in TlbImp'd assemblies,
            we will create only one event sink per RCW (theoretically RCW might have
            several ComEventSink evenk sinks - but all these implement different source intefaces).
            Each ComEventSink contains a list of ComEventSinkMethod objects - which represent
            a single method on the source interface an a multicast delegate to redirect 
            the calls. Notice that we are chaining multicast delegates so that same 
            ComEventSinkMedhod can invoke multiple event handlers).
            
            ComEventSink implements an IDisposable pattern to Unadvise from the connection point.
            Typically, when RCW is finalized the corresponding Dispose will be triggered by 
            ComEventSinksContainer finalizer. Notice that lifetime of ComEventSinksContainer
            is bound to the lifetime of the RCW. 
            </summary>
        </member>
        <member name="T:System.Dynamic.ComInterop.ComEventSink.ComEventSinkMethod">
            <summary>
            Contains a methods DISPID (in a string formatted of "[DISPID=N]"
            and a chained list of delegates to invoke
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.TreeComparer.Compare(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Collections.Generic.List{System.Linq.Expressions.ConstantExpression}@,System.Boolean@)">
            <summary>
            Compares two trees.  If the trees differ only by constants then the list of constants which differ
            is provided as a list via an out-param.  The constants collected are the constants in the left
            side of the tree and only include constants which differ in value.
            </summary>
        </member>
        <member name="T:System.Linq.Expressions.TreeComparer.FlatTreeWalker">
            <summary>
            Walks all of the nodes of a tree and puts all of the expressions into
            a list.
            </summary>
        </member>
        <member name="T:System.Dynamic.SourceSpan">
            <summary>
            Stores the location of a span of text in a source file.
            TODO: move to System.Linq.Expressions
            TODO: review public APIs !!!
                  Lots of stuff on here that is not used by the compiler
            </summary>
        </member>
        <member name="M:System.Dynamic.SourceSpan.#ctor(System.Dynamic.SourceLocation,System.Dynamic.SourceLocation)">
            <summary>
            Constructs a new span with a specific start and end location.
            </summary>
            <param name="start">The beginning of the span.</param>
            <param name="end">The end of the span.</param>
        </member>
        <member name="F:System.Dynamic.SourceSpan.None">
            <summary>
            A valid span that represents no location.
            </summary>
        </member>
        <member name="F:System.Dynamic.SourceSpan.Invalid">
            <summary>
            An invalid span.
            </summary>
        </member>
        <member name="M:System.Dynamic.SourceSpan.op_Equality(System.Dynamic.SourceSpan,System.Dynamic.SourceSpan)">
            <summary>
            Compares two specified Span values to see if they are equal.
            </summary>
            <param name="left">One span to compare.</param>
            <param name="right">The other span to compare.</param>
            <returns>True if the spans are the same, False otherwise.</returns>
        </member>
        <member name="M:System.Dynamic.SourceSpan.op_Inequality(System.Dynamic.SourceSpan,System.Dynamic.SourceSpan)">
            <summary>
            Compares two specified Span values to see if they are not equal.
            </summary>
            <param name="left">One span to compare.</param>
            <param name="right">The other span to compare.</param>
            <returns>True if the spans are not the same, False otherwise.</returns>
        </member>
        <member name="P:System.Dynamic.SourceSpan.Start">
            <summary>
            The start location of the span.
            </summary>
        </member>
        <member name="P:System.Dynamic.SourceSpan.End">
            <summary>
            The end location of the span. Location of the first character behind the span.
            </summary>
        </member>
        <member name="P:System.Dynamic.SourceSpan.Length">
            <summary>
            Length of the span (number of characters inside the span).
            </summary>
        </member>
        <member name="P:System.Dynamic.SourceSpan.IsValid">
            <summary>
            Whether the locations in the span are valid.
            </summary>
        </member>
        <member name="T:System.Linq.Expressions.ParameterExpression">
            <summary>
            Base class for specialized parameter expressions.  This version only holds onto the
            name which all subclasses need.  Specialized subclasses provide the type and by ref
            flags.
            </summary>
        </member>
        <member name="T:System.Linq.Expressions.ByRefParameterExpression">
            <summary>
            Specialized subclass to avoid holding onto the byref flag in a 
            parameter expression.  This version always holds onto the expression
            type explicitly and therefore derives from TypedParameterExpression.
            </summary>
        </member>
        <member name="T:System.Linq.Expressions.TypedParameterExpression">
            <summary>
            Specialized subclass which holds onto the type of the expression for
            uncommon types.
            </summary>
        </member>
        <member name="T:System.Linq.Expressions.PrimitiveParameterExpression`1">
            <summary>
            Generic type to avoid needing explicit storage for primitive data types
            which are commonly used.
            </summary>
        </member>
        <member name="T:System.Linq.Expressions.IndexExpression">
            <summary>
            Represents property or array indexing
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.IndexExpression.Indexer">
            <summary>
            If this is an indexed property, returns the property
            If this is an array indexing operation, returns null
            </summary>
        </member>
        <member name="T:System.Linq.Expressions.DynamicExpression">
            <summary>
            A late-bound operation. The precise semantics is determined by the
            Binder. If the Binder is one of the standard dynamic operations
            supported by MetaObject, the run-time behavior can be infered from the
            StandardAction
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.DynamicExpression.Rewrite(System.Linq.Expressions.Expression[])">
            <summary>
            Makes a copy of this node replacing the args with the provided values.  The 
            number of the args needs to match the number of the current block.
            
            This helper is provided to allow re-writing of nodes to not depend on the specific optimized
            subclass of DynamicExpression which is being used. 
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.DynamicExpression.Binder">
            <summary>
            The CallSiteBinder, which determines the runtime behavior of the
            dynamic site
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.DynamicExpression.DelegateType">
            <summary>
            The type of the CallSite's delegate
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.DynamicExpression.Arguments">
            <summary>
            Arguments to the dynamic operation
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Compiler.Snippets.SnippetsDirectory">
            <summary>
            Directory where snippet assembly will be saved if SaveSnippets is set.
            </summary>
        </member>
        <member name="T:System.Dynamic.ComInterop.VariantBuilder">
            <summary>
            VariantBuilder handles packaging of arguments into a Variant for a call to IDispatch.Invoke
            </summary>
        </member>
        <member name="M:System.Dynamic.ComInterop.ComRuntimeHelpers.GetITypeInfoFromIDispatch(System.Dynamic.ComInterop.IDispatch,System.Boolean)">
            <summary>
            Look for typeinfo using IDispatch.GetTypeInfo
            </summary>
            <param name="dispatch"></param>
            <param name="throwIfMissingExpectedTypeInfo">
            Some COM objects just dont expose typeinfo. In these cases, this method will return null.
            Some COM objects do intend to expose typeinfo, but may not be able to do so if the type-library is not properly 
            registered. This will be considered as acceptable or as an error condition depending on throwIfMissingExpectedTypeInfo</param>
            <returns></returns>
        </member>
        <member name="M:System.Dynamic.ComInterop.ComRuntimeHelpers.CheckIfMissingTypeInfoIsExpected(System.Int32,System.Boolean)">
            <summary>
            This method should be called when typeinfo is not available for an object. The function
            will check if the typeinfo is expected to be missing. This can include error cases where
            the same error is guaranteed to happen all the time, on all machines, under all circumstances.
            In such cases, we just have to operate without the typeinfo.
            
            However, if accessing the typeinfo is failing in a transient way, we might want to throw
            an exception so that we will eagerly predictably indicate the problem.
            </summary>
        </member>
        <member name="T:System.Dynamic.ComInterop.UnsafeMethods">
            <summary>
            This class contains methods that either cannot be expressed in C#, or which require writing unsafe code.
            Callers of these methods need to use them extremely carefully as incorrect use could cause GC-holes
            and other problems.
            </summary>
            
        </member>
        <member name="M:System.Dynamic.ComInterop.UnsafeMethods.AssertByrefPointsToStack(System.IntPtr)">
            <summary>
            TODO: Used only in DEBUG build. Remove?
            
            Ensure that "value" is a local variable in some caller's frame. So converting
            the byref to an IntPtr is a safe operation. Alternatively, we could also allow 
            allowed "value"  to be a pinned object.
            </summary>
        </member>
        <member name="T:System.Dynamic.ComInterop.UnsafeMethods.IUnknownReleaseDelegate">
            <summary>
            We will emit an indirect call to an unmanaged function pointer from the vtable of the given interface pointer. 
            This approach can take only ~300 instructions on x86 compared with ~900 for Marshal.Release. We are relying on 
            the JIT-compiler to do pinvoke-stub-inlining and calling the pinvoke target directly.
            </summary>
        </member>
        <member name="T:System.Dynamic.ComInterop.UnsafeMethods.IDispatchInvokeDelegate">
            <summary>
            We will emit an indirect call to an unmanaged function pointer from the vtable of the given IDispatch interface pointer. 
            It is not possible to express this in C#. Using an indirect pinvoke call allows us to do our own marshalling. 
            We can allocate the Variant arguments cheaply on the stack. We are relying on the JIT-compiler to do 
            pinvoke-stub-inlining and calling the pinvoke target directly.
            The alternative of calling via a managed interface declaration of IDispatch would have a performance
            penalty of going through a CLR stub that would have to re-push the arguments on the stack, etc.
            Marshal.GetDelegateForFunctionPointer could be used here, but its too expensive (~2000 instructions on x86).
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.ConstantCheck.IsConstant(System.Linq.Expressions.Expression,System.Boolean)">
            <summary>
            Tests to see if the expression is a constant with the given value.
            </summary>
            <param name="e">The expression to examine</param>
            <param name="value">The constant value to check for.</param>
            <returns>true/false</returns>
        </member>
        <member name="M:System.Linq.Expressions.ConstantCheck.AnalyzeTypeIs(System.Linq.Expressions.TypeBinaryExpression)">
            <summary>
            If the result of a TypeBinaryExpression is known statically, this
            returns the result, otherwise it returns null, meaning we'll need
            to perform the IsInst instruction at runtime.
            
            The result of this function must be equivalent to IsInst, or
            null.
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.ConstantCheck.AnalyzeTypeIs(System.Linq.Expressions.UnaryExpression)">
            <summary>
            If the result of a unary TypeAs expression is known statically, this
            returns the result, otherwise it returns null, meaning we'll need
            to perform the IsInst instruction at runtime.
            
            The result of this function must be equivalent to IsInst, or
            null.
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.ConstantCheck.AnalyzeTypeIs(System.Linq.Expressions.Expression,System.Type)">
            <summary>
            If the result of an isinst opcode is known statically, this
            returns the result, otherwise it returns null, meaning we'll need
            to perform the IsInst instruction at runtime.
            
            The result of this function must be equivalent to IsInst, or
            null.
            </summary>
        </member>
        <member name="M:System.Dynamic.ComInterop.ComInvokeBinder.MakeIDispatchInvokeTarget">
            <summary>
            Create a stub for the target of the optimized lopop.
            </summary>
            <returns></returns>
        </member>
        <member name="M:System.Dynamic.ComInterop.ComInvokeBinder.MakeArgumentExpressions">
            <summary>
            Gets expressions to access all the arguments. This includes the instance argument.
            </summary>
        </member>
        <member name="M:System.Dynamic.ComInterop.ComInvokeBinder.GetArgumentNames">
            <summary>
            Gets all of the argument names. The instance argument is not included
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.LoopExpression.#ctor(System.Linq.Expressions.Expression,System.Linq.Expressions.LabelTarget,System.Linq.Expressions.LabelTarget)">
            <summary>
            Null test means infinite loop.
            </summary>
        </member>
        <member name="T:System.Linq.Expressions.Compiler.BoundConstants">
            <summary>
            This type tracks "runtime" constants--live objects that appear in
            ConstantExpression nodes and must be bound to the delegate.
            </summary>
        </member>
        <member name="F:System.Linq.Expressions.Compiler.BoundConstants._values">
            <summary>
            The list of constants in the order they appear in the constant array
            </summary>
        </member>
        <member name="F:System.Linq.Expressions.Compiler.BoundConstants._indexes">
            <summary>
            The index of each constant in the constant array
            </summary>
        </member>
        <member name="F:System.Linq.Expressions.Compiler.BoundConstants._references">
            <summary>
            Each constant referenced within this lambda, and how often it was referenced
            </summary>
        </member>
        <member name="F:System.Linq.Expressions.Compiler.BoundConstants._cache">
            <summary>
            IL locals for storing frequently used constants
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Compiler.BoundConstants.AddReference(System.Object,System.Type)">
            <summary>
            Called by VariableBinder. Adds the constant to the list (if needed)
            and increases the reference count by one
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Compiler.BoundConstants.EmitConstant(System.Linq.Expressions.Compiler.LambdaCompiler,System.Object,System.Type)">
            <summary>
            Emits a live object as a constant
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Compiler.BoundConstants.EmitCacheConstants(System.Linq.Expressions.Compiler.LambdaCompiler)">
            <summary>
            Emit code to cache frequently used constants into IL locals,
            instead of pulling them out of the array each time
            </summary>
        </member>
        <member name="T:System.Linq.Expressions.Compiler.BoundConstants.TypedConstant">
            <summary>
            Constants can emit themselves as different types
            For caching purposes, we need to treat each distinct Type as a
            seperate thing to cache. (If we have to cast it on the way out, it
            ends up using a JIT temp and defeats the purpose of caching the
            value in a local)
            </summary>
        </member>
        <member name="T:System.Dynamic.Binders.OperationOnMemberBinder">
            <summary>
            A Binder that is responsible for runtime binding of operation:
            a.b (op)= c
            </summary>
        </member>
        <member name="M:System.Dynamic.Binders.OperationOnMemberBinder.#ctor(System.Linq.Expressions.ExpressionType,System.String,System.Boolean)">
            <summary>
            Constructor of the OperationOnIndexBinder object, representing "a.b (op)= c" operation.
            </summary>
            <param name="operation">Binary operation to be performed.</param>
            <param name="name">Name of the member for the operation.</param>
            <param name="ignoreCase">Ignore case of the member.</param>
        </member>
        <member name="M:System.Dynamic.Binders.OperationOnMemberBinder.FallbackOperation(System.Dynamic.Binders.MetaObject,System.Dynamic.Binders.MetaObject)">
            <summary>
            Implements a binding logic for the binary operation part of the binding.
            This is called by the target when the target implements the whole operation:
               a[b] += c
            as:
               a[b] = a[b] + c
            to let the language participate in the binding of the binary operation only.
            </summary>
            <param name="target">Target of the operation.</param>
            <param name="arg">Right-hand operator value</param>
            <returns>MetaObject representing the binding result.</returns>
        </member>
        <member name="M:System.Dynamic.Binders.OperationOnMemberBinder.FallbackOperation(System.Dynamic.Binders.MetaObject,System.Dynamic.Binders.MetaObject,System.Dynamic.Binders.MetaObject)">
            <summary>
            Implements a binding logic for the binary operation part of the binding.
            This is called by the target when the target implements the whole operation:
               a[b] += c
            as:
               a[b] = a[b] + c
            to let the language participate in the binding of the binary operation only.
            </summary>
            <param name="target">Target of the operation.</param>
            <param name="arg">Right-hand operator value</param>
            <param name="errorSuggestion">The representaiton of the binding error that the target meta object recommends the language to use if the language cannot bind. This allows the target meta object to participate in the error handling process.</param>
            <returns>MetaObject representing the binding result.</returns>
        </member>
        <member name="M:System.Dynamic.Binders.OperationOnMemberBinder.FallbackOperationOnMember(System.Dynamic.Binders.MetaObject,System.Dynamic.Binders.MetaObject)">
            <summary>
            Implements a binding logic for the operation. This is called by the target when
            the target lets the executing language participate in the binding process.
            </summary>
            <param name="target">Target of the operation.</param>
            <param name="value">The right-hand value</param>
            <returns>MetaObject representing the binding.</returns>
        </member>
        <member name="M:System.Dynamic.Binders.OperationOnMemberBinder.FallbackOperationOnMember(System.Dynamic.Binders.MetaObject,System.Dynamic.Binders.MetaObject,System.Dynamic.Binders.MetaObject)">
            <summary>
            Implements a binding logic for the operation. This is called by the target when
            the target lets the executing language participate in the binding process.
            </summary>
            <param name="target">Target of the operation.</param>
            <param name="value">The right-hand value</param>
            <param name="errorSuggestion">The representaiton of the binding error that the target meta object recommends the language to use if the language cannot bind. This allows the target meta object to participate in the error handling process.</param>
            <returns>MetaObject representing the binding.</returns>
        </member>
        <member name="M:System.Dynamic.Binders.OperationOnMemberBinder.Equals(System.Object)">
            <summary>
            Implements Equality operation for the OperationOnMemberBinder
            </summary>
            <param name="obj">Instance to comapre equal to.</param>
            <returns>true/false</returns>
        </member>
        <member name="M:System.Dynamic.Binders.OperationOnMemberBinder.GetHashCode">
            <summary>
            Calculates hash code for the OperationOnMemberBinder
            </summary>
            <returns>The hash code.</returns>
        </member>
        <member name="P:System.Dynamic.Binders.OperationOnMemberBinder.Operation">
            <summary>
            The operation to be performed.
            </summary>
        </member>
        <member name="P:System.Dynamic.Binders.OperationOnMemberBinder.Name">
            <summary>
            Name of the member for the operation.
            </summary>
        </member>
        <member name="P:System.Dynamic.Binders.OperationOnMemberBinder.IgnoreCase">
            <summary>
            Ignore case of the member.
            </summary>
        </member>
        <member name="T:System.Linq.Expressions.Compiler.CompilerScope">
            <summary>
            CompilerScope is the data structure which the Compiler keeps information
            related to compiling scopes. It stores the following information:
              1. Parent relationship (for resolving variables)
              2. Information about hoisted variables
              3. Information for resolving closures
            
            Instances are produced by VariableBinder, which does a tree walk
            looking for scope nodes: LambdaExpression and BlockExpression.
            </summary>
        </member>
        <member name="F:System.Linq.Expressions.Compiler.CompilerScope._parent">
            <summary>
            parent scope, if any
            </summary>
        </member>
        <member name="F:System.Linq.Expressions.Compiler.CompilerScope.Node">
            <summary>
            The expression node for this scope
            </summary>
        </member>
        <member name="F:System.Linq.Expressions.Compiler.CompilerScope.NeedsClosure">
            <summary>
            Does this scope (or any inner scope) close over variables from any
            parent scope?
            Populated by VariableBinder
            </summary>
        </member>
        <member name="F:System.Linq.Expressions.Compiler.CompilerScope.Definitions">
            <summary>
            Variables defined in this scope, and whether they're hoisted or not
            Populated by VariableBinder
            </summary>
        </member>
        <member name="F:System.Linq.Expressions.Compiler.CompilerScope.ReferenceCount">
            <summary>
            Each variable referenced within this scope, and how often it was referenced
            Populated by VariableBinder
            
            Created lazily as we only use in about 1 out of 3 compiles when compiling rules.
            </summary>
        </member>
        <member name="F:System.Linq.Expressions.Compiler.CompilerScope.MergedScopes">
            <summary>
            Scopes whose variables were merged into this one
            
            Created lazily as we create hundreds of compiler scopes w/o merging scopes when compiling rules.
            </summary>
        </member>
        <member name="F:System.Linq.Expressions.Compiler.CompilerScope._hoistedLocals">
            <summary>
            The scope's hoisted locals, if any.
            Provides storage for variables that are referenced from nested lambdas
            </summary>
        </member>
        <member name="F:System.Linq.Expressions.Compiler.CompilerScope._closureHoistedLocals">
            <summary>
            The closed over hoisted locals
            </summary>
        </member>
        <member name="F:System.Linq.Expressions.Compiler.CompilerScope._locals">
            <summary>
            Mutable dictionary that maps non-hoisted variables to either local
            slots or argument slots
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Compiler.CompilerScope.Enter(System.Linq.Expressions.Compiler.LambdaCompiler,System.Linq.Expressions.Compiler.CompilerScope)">
            <summary>
            Called when entering a lambda/block. Performs all variable allocation
            needed, including creating hoisted locals and IL locals for accessing
            parent locals
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Compiler.CompilerScope.Exit">
            <summary>
            Frees unnamed locals, clears state associated with this compiler
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Compiler.CompilerScope.AddLocal(System.Linq.Expressions.Compiler.LambdaCompiler,System.Linq.Expressions.ParameterExpression)">
            <summary>
            Adds a new virtual variable corresponding to an IL local
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Compiler.CompilerScope.ResolveVariable(System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Compiler.HoistedLocals)">
            <summary>
            Resolve a local variable in this scope or a closed over scope
            Throws if the variable is defined
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Compiler.CompilerScope.NearestHoistedLocals">
            <summary>
            This scope's hoisted locals, or the closed over locals, if any
            Equivalent to: _hoistedLocals ?? _closureHoistedLocals
            </summary>
        </member>
        <member name="T:System.Linq.Expressions.RuntimeVariablesExpression">
            <summary>
            An expression that provides runtime read/write access to variables.
            Needed to implement "eval" in dynamic languages.
            Evaluates to an instance of ILocalVariables at run time.
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables">
            <summary>
            The variables or parameters to provide access to
            </summary>
        </member>
        <member name="T:System.Linq.Expressions.LabelTarget">
            <summary>
            Used to denote the target of a GotoExpression
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.LabelTarget.Type">
            <summary>
            The type of value that is passed when jumping to the label
            (or System.Void if no value should be passed)
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.GotoExpression.Value">
            <summary>
            The value passed to the target, or null if the target is of type
            System.Void
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.GotoExpression.Target">
            <summary>
            The target label where this node jumps to
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.GotoExpression.Kind">
            <summary>
            The kind of the goto. For information purposes only.
            </summary>
        </member>
        <member name="T:System.Dynamic.Utils.ListStack`1">
            <summary>
            A stack implemented as a list. Allows both Push/Pop access and indexing into any member of the list.
            </summary>
        </member>
        <member name="M:System.Dynamic.Utils.ListStack`1.Peek">
            <exception cref="T:System.InvalidOperationException">Stack is empty.</exception>
        </member>
        <member name="M:System.Dynamic.Utils.ListStack`1.Pop">
            <exception cref="T:System.InvalidOperationException">Stack is empty.</exception>
        </member>
        <member name="M:System.Dynamic.Utils.ListStack`1.GetEnumerator">
            <summary>
            Enumerates from the top of the stack to the bottom.
            </summary>
            <exception cref="T:System.InvalidOperationException">Stack has been modified during enumeration.</exception>
        </member>
        <member name="M:System.Dynamic.Utils.ContractUtils.RequiresArrayIndex``1(System.Collections.Generic.IList{``0},System.Int32,System.String)">
            <summary>
            Requires the specified index to point inside the array.
            </summary>
            <exception cref="T:System.ArgumentNullException">Array is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Index is outside the array.</exception>
        </member>
        <member name="M:System.Dynamic.Utils.ContractUtils.RequiresArrayInsertIndex``1(System.Collections.Generic.IList{``0},System.Int32,System.String)">
            <summary>
            Requires the specified index to point inside the array or at the end
            </summary>
            <exception cref="T:System.ArgumentNullException">Array is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Index is outside the array.</exception>
        </member>
        <member name="M:System.Dynamic.Utils.ContractUtils.RequiresArrayRange``1(System.Collections.Generic.IList{``0},System.Int32,System.Int32,System.String,System.String)">
            <summary>
            Requires the range [offset, offset + count] to be a subset of [0, array.Count].
            </summary>
            <exception cref="T:System.ArgumentNullException">Array is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Offset or count are out of range.</exception>
        </member>
        <member name="M:System.Dynamic.Utils.ContractUtils.RequiresListRange(System.Collections.IList,System.Int32,System.Int32,System.String,System.String)">
            <summary>
            Requires the range [offset, offset + count] to be a subset of [0, array.Count].
            </summary>
            <exception cref="T:System.ArgumentNullException">Array is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Offset or count are out of range.</exception>
        </member>
        <member name="M:System.Dynamic.Utils.ContractUtils.RequiresArrayRange(System.String,System.Int32,System.Int32,System.String,System.String)">
            <summary>
            Requires the range [offset, offset + count] to be a subset of [0, array.Count].
            </summary>
            <exception cref="T:System.ArgumentNullException">String is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Offset or count are out of range.</exception>
        </member>
        <member name="M:System.Dynamic.Utils.ContractUtils.RequiresNotNullItems``1(System.Collections.Generic.IList{``0},System.String)">
            <summary>
            Requires the array and all its items to be non-null.
            </summary>
        </member>
        <member name="T:System.Dynamic.ComInterop.IDispatchComObject">
            <summary>
            An object that implements IDispatch
            
            This currently has the following issues:
            1. If we prefer ComObjectWithTypeInfo over IDispatchComObject, then we will often not
               IDispatchComObject since implementations of IDispatch often rely on a registered type library. 
               If we prefer IDispatchComObject over ComObjectWithTypeInfo, users get a non-ideal experience.
            2. IDispatch cannot distinguish between properties and methods with 0 arguments (and non-0 
               default arguments?). So obj.foo() is ambiguous as it could mean invoking method foo, 
               or it could mean invoking the function pointer returned by property foo.
               We are attempting to find whether we need to call a method or a property by examining
               the ITypeInfo associated with the IDispatch. ITypeInfo tell's use what parameters the method
               expects, is it a method or a property, what is the default property of the object, how to 
               create an enumerator for collections etc.
            3. IronPython processes the signature and converts ref arguments into return values. 
               However, since the signature of a DispMethod is not available beforehand, this conversion 
               is not possible. There could be other signature conversions that may be affected. How does 
               VB6 deal with ref arguments and IDispatch?
               
            We also support events for IDispatch objects:
            Background:
            COM objects support events through a mechanism known as Connect Points.
            Connection Points are separate objects created off the actual COM 
            object (this is to prevent circular references between event sink
            and event source). When clients want to sink events generated  by 
            COM object they would implement callback interfaces (aka source 
            interfaces) and hand it over (advise) to the Connection Point. 
            
            Implementation details:
            When IDispatchComObject.TryGetMember request is received we first check
            whether the requested member is a property or a method. If this check
            fails we will try to determine whether an event is requested. To do 
            so we will do the following set of steps:
            1. Verify the COM object implements IConnectionPointContainer
            2. Attempt to find COM object's coclass's description
               a. Query the object for IProvideClassInfo interface. Go to 3, if found
               b. From object's IDispatch retrieve primary interface description
               c. Scan coclasses declared in object's type library.
               d. Find coclass implementing this particular primary interface 
            3. Scan coclass for all its source interfaces.
            4. Check whether to any of the methods on the source interfaces matches 
            the request name
            
            Once we determine that TryGetMember requests an event we will return
            an instance of BoundDispEvent class. This class has InPlaceAdd and
            InPlaceSubtract operators defined. Calling InPlaceAdd operator will:
            1. An instance of ComEventSinksContainer class is created (unless 
            RCW already had one). This instance is hanged off the RCW in attempt
            to bind the lifetime of event sinks to the lifetime of the RCW itself,
            meaning event sink will be collected once the RCW is collected (this
            is the same way event sinks lifetime is controlled by PIAs).
            Notice: ComEventSinksContainer contains a Finalizer which will go and
            unadvise all event sinks.
            Notice: ComEventSinksContainer is a list of ComEventSink objects. 
            2. Unless we have already created a ComEventSink for the required 
            source interface, we will create and advise a new ComEventSink. Each
            ComEventSink implements a single source interface that COM object 
            supports. 
            3. ComEventSink contains a map between method DISPIDs to  the 
            multicast delegate that will be invoked when the event is raised.
            4. ComEventSink implements IReflect interface which is exposed as
            custom IDispatch to COM consumers. This allows us to intercept calls
            to IDispatch.Invoke and apply custom logic - in particular we will
            just find and invoke the multicast delegate corresponding to the invoked
            dispid.
             </summary>
        </member>
        <member name="T:System.Dynamic.SourceLocation">
            <summary>
            Represents a location in source code.
            TODO: move to System.Linq.Expressions
            TODO: review public APIs !!!
                  Lots of stuff on here that is not used by the compiler
            </summary>
        </member>
        <member name="M:System.Dynamic.SourceLocation.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a new source location.
            </summary>
            <param name="index">The index in the source stream the location represents (0-based).</param>
            <param name="line">The line in the source stream the location represents (1-based).</param>
            <param name="column">The column in the source stream the location represents (1-based).</param>
        </member>
        <member name="M:System.Dynamic.SourceLocation.op_Equality(System.Dynamic.SourceLocation,System.Dynamic.SourceLocation)">
            <summary>
            Compares two specified location values to see if they are equal.
            </summary>
            <param name="left">One location to compare.</param>
            <param name="right">The other location to compare.</param>
            <returns>True if the locations are the same, False otherwise.</returns>
        </member>
        <member name="M:System.Dynamic.SourceLocation.op_Inequality(System.Dynamic.SourceLocation,System.Dynamic.SourceLocation)">
            <summary>
            Compares two specified location values to see if they are not equal.
            </summary>
            <param name="left">One location to compare.</param>
            <param name="right">The other location to compare.</param>
            <returns>True if the locations are not the same, False otherwise.</returns>
        </member>
        <member name="M:System.Dynamic.SourceLocation.op_LessThan(System.Dynamic.SourceLocation,System.Dynamic.SourceLocation)">
            <summary>
            Compares two specified location values to see if one is before the other.
            </summary>
            <param name="left">One location to compare.</param>
            <param name="right">The other location to compare.</param>
            <returns>True if the first location is before the other location, False otherwise.</returns>
        </member>
        <member name="M:System.Dynamic.SourceLocation.op_GreaterThan(System.Dynamic.SourceLocation,System.Dynamic.SourceLocation)">
            <summary>
            Compares two specified location values to see if one is after the other.
            </summary>
            <param name="left">One location to compare.</param>
            <param name="right">The other location to compare.</param>
            <returns>True if the first location is after the other location, False otherwise.</returns>
        </member>
        <member name="M:System.Dynamic.SourceLocation.op_LessThanOrEqual(System.Dynamic.SourceLocation,System.Dynamic.SourceLocation)">
            <summary>
            Compares two specified location values to see if one is before or the same as the other.
            </summary>
            <param name="left">One location to compare.</param>
            <param name="right">The other location to compare.</param>
            <returns>True if the first location is before or the same as the other location, False otherwise.</returns>
        </member>
        <member name="M:System.Dynamic.SourceLocation.op_GreaterThanOrEqual(System.Dynamic.SourceLocation,System.Dynamic.SourceLocation)">
            <summary>
            Compares two specified location values to see if one is after or the same as the other.
            </summary>
            <param name="left">One location to compare.</param>
            <param name="right">The other location to compare.</param>
            <returns>True if the first location is after or the same as the other location, False otherwise.</returns>
        </member>
        <member name="M:System.Dynamic.SourceLocation.Compare(System.Dynamic.SourceLocation,System.Dynamic.SourceLocation)">
            <summary>
            Compares two specified location values.
            </summary>
            <param name="left">One location to compare.</param>
            <param name="right">The other location to compare.</param>
            <returns>0 if the locations are equal, -1 if the left one is less than the right one, 1 otherwise.</returns>
        </member>
        <member name="F:System.Dynamic.SourceLocation.None">
            <summary>
            A location that is valid but represents no location at all.
            </summary>
        </member>
        <member name="F:System.Dynamic.SourceLocation.Invalid">
            <summary>
            An invalid location.
            </summary>
        </member>
        <member name="F:System.Dynamic.SourceLocation.MinValue">
            <summary>
            A minimal valid location.
            </summary>
        </member>
        <member name="P:System.Dynamic.SourceLocation.Index">
            <summary>
            The index in the source stream the location represents (0-based).
            </summary>
        </member>
        <member name="P:System.Dynamic.SourceLocation.Line">
            <summary>
            The line in the source stream the location represents (1-based).
            </summary>
        </member>
        <member name="P:System.Dynamic.SourceLocation.Column">
            <summary>
            The column in the source stream the location represents (1-based).
            </summary>
        </member>
        <member name="P:System.Dynamic.SourceLocation.IsValid">
            <summary>
            Whether the location is a valid location.
            </summary>
            <returns>True if the location is valid, False otherwise.</returns>
        </member>
        <member name="T:System.Dynamic.Binders.AutoRuleTemplate">
            <summary>
            Handles auto-templating of rules.  There are three important actions this performs:
                1. Detects if templating is possible between two rules
                2. Re-writes a non-templated rule into templated form
                3. Extracts the constants from a non-templated rule which is compatible with a 
                    templated rule so that they can be used by the existing generated code.
                    
            Auto-templating is currently only used for serially monomorphic call sites where we
            can easily avoid code gen.  It is not used for polymorphic call sites although such
            a feature could be enabled in the future.
            </summary>
        </member>
        <member name="M:System.Dynamic.Binders.AutoRuleTemplate.CopyOrCreateTemplatedRule``1(System.Runtime.CompilerServices.CallSiteRule{``0},System.Runtime.CompilerServices.CallSiteRule{``0})">
            <summary>
            The entry point into auto-rule tempating.  This consumes the monomorphic rule which is currently
            stored in the cache as well as the rule that was just produced by the binder.  
            </summary>
            <param name="from">The original rule that is currently stored in the cache.  This rule may
            or may not be a templated rule.</param>
            <param name="to">The new rule produced by a binder.</param>
        </member>
        <member name="M:System.Dynamic.Binders.AutoRuleTemplate.CloneData(System.Object,System.Object[])">
            <summary>
            Clones the delegate target to create new delegate around it.
            The delegates created by the compiler are closed over the instance of Closure class.
            </summary>
        </member>
        <member name="M:System.Dynamic.Binders.Restrictions.AddRestrictions(System.Dynamic.Binders.Restrictions.Restriction[],System.Collections.Generic.List{System.Dynamic.Binders.Restrictions.Restriction})">
            <summary>
            Adds unique restrictions and doesn't add restrictions which are alerady present
            </summary>
        </member>
        <member name="M:System.Dynamic.Binders.Restrictions.CreateTypeRestriction(System.Linq.Expressions.Expression,System.Type)">
            <summary>
            Creates one type identity test 
            </summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.CallSite">
            <summary>
            A Dynamic Call Site base class. This type is used as a parameter type to the
            dynamic site targets. The first parameter of the delegate (T) below must be
            of this type.
            </summary>
        </member>
        <member name="F:System.Runtime.CompilerServices.CallSite._binder">
            <summary>
            The Binder responsible for binding operations at this call site.
            This binder is invoked by the UpdateAndExecute below if all Level 0,
            Level 1 and Level 2 caches experience cache miss.
            </summary>
        </member>
        <member name="P:System.Runtime.CompilerServices.CallSite.Binder">
            <summary>
            Class responsible for binding dynamic operations on the dynamic site.
            </summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.CallSite`1">
            <summary>
            Dynamic site type.
            </summary>
            <typeparam name="T">The delegate type.</typeparam>
        </member>
        <member name="F:System.Runtime.CompilerServices.CallSite`1.Update">
            <summary>
            The update delegate. Called when the dynamic site experiences cache miss
            </summary>
        </member>
        <member name="F:System.Runtime.CompilerServices.CallSite`1.Target">
            <summary>
            The Level 0 cache - a delegate specialized based on the site history.
            </summary>
        </member>
        <member name="F:System.Runtime.CompilerServices.CallSite`1.Rules">
            <summary>
            The Level 1 cache - a history of the dynamic site
            </summary>
        </member>
        <member name="F:System.Runtime.CompilerServices.CallSite`1._cache">
            <summary>
            The Level 2 cache - all rules produced for the same generic instantiation
            of the dynamic site (all dynamic sites with matching delegate type).
            </summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.CallSite`1.IfThen(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
            <summary>
            Behaves like an "if" statement in imperative languages. The type is
            always treated as void regardless of the body's type. The else
            branch is empty
            </summary>
        </member>
        <member name="M:System.Dynamic.Utils.TypeExtensions.CreateDelegate(System.Reflection.MethodInfo,System.Type)">
            <summary>
            Creates an open delegate for the given (dynamic)method.
            </summary>
        </member>
        <member name="M:System.Dynamic.Utils.TypeExtensions.CreateDelegate(System.Reflection.MethodInfo,System.Type,System.Object)">
            <summary>
            Creates a closed delegate for the given (dynamic)method.
            </summary>
        </member>
        <member name="M:System.Dynamic.Utils.TypeExtensions.IsSealedOrValueType(System.Type)">
            <summary>
            A helper routine to check if a type can be treated as sealed - i.e. there
            can never be a subtype of this given type.  This corresponds to a type
            that is either declared "Sealed" or is a ValueType and thus unable to be
            extended.
            
            TODO: this should not be needed. Type.IsSealed does the right thing.
            </summary>
        </member>
        <member name="M:System.Dynamic.Utils.TypeExtensions.IsMandatoryParameter(System.Reflection.ParameterInfo)">
            <summary>
            Returns <c>true</c> if the specified parameter is mandatory, i.e. is not optional and doesn't have a default value.
            </summary>
        </member>
        <member name="T:System.Dynamic.ComInterop.ExcepInfo">
            <summary>
            This is similar to ComTypes.EXCEPINFO, but lets us do our own custom marshaling
            </summary>
        </member>
        <member name="T:System.Dynamic.ComInterop.ComParamDesc">
            <summary>
            The parameter description of a method defined in a type library
            </summary>
        </member>
        <member name="M:System.Dynamic.ComInterop.ComParamDesc.#ctor(System.Runtime.InteropServices.ComTypes.ELEMDESC@,System.String)">
            <summary>
            Creates a representation for the paramter of a COM method
            </summary>
        </member>
        <member name="M:System.Dynamic.ComInterop.ComParamDesc.#ctor(System.Runtime.InteropServices.ComTypes.ELEMDESC@)">
            <summary>
            Creates a representation for the return value of a COM method
            TODO: Return values should be represented by a different type
            </summary>
        </member>
        <member name="P:System.Dynamic.ComInterop.ComParamDesc.DefaultValue">
            <summary>
            DBNull.Value if there is no default value
            </summary>
        </member>
        <member name="T:System.Linq.Expressions.TryExpression">
            <summary>
            Represents a try/catch/finally/fault block.
            
            The body is protected by the try block.
            The handlers consist of a set of CatchBlocks that can either be catch or filters.
            The fault runs if an exception is thrown.
            The finally runs regardless of how control exits the body.
            Only fault or finally can be supplied
            </summary>
        </member>
        <member name="T:System.Linq.Expressions.Compiler.ArgumentPrepender">
            <summary>
            Prepends an argument and stands in as an IArgumentProvider.  Avoids
            creation of a ReadOnlyCollection or making a temporary array copy.
            
            Note this is always as better than allocating an array because an empty
            array has 16 bytes of overhead - and so does this.
            </summary>
        </member>
        <member name="T:System.Dynamic.Utils.SynchronizedDictionary`2">
            <summary>
            Dictionary[TKey, TValue] is not thread-safe in the face of concurrent reads and writes. SynchronizedDictionary
            provides a thread-safe implementation. It holds onto a Dictionary[TKey, TValue] instead of inheriting from
            it so that users who need to do manual synchronization can access the underlying Dictionary[TKey, TValue].
            </summary>
        </member>
        <member name="P:System.Dynamic.Utils.SynchronizedDictionary`2.UnderlyingDictionary">
            <summary>
            This returns the raw unsynchronized Dictionary[TKey, TValue]. Users are responsible for locking
            on it before accessing it. Also, it should not be arbitrarily handed out to other code since deadlocks
            can be caused if other code incorrectly locks on it.
            </summary>
        </member>
        <member name="T:System.Linq.Expressions.BlockExpression">
            <summary>
            Defines a block where variables are defined. The compiler will
            automatically close over these variables if they're referenced in a
            nested LambdaExpession.
            
            Specialized subclasses exist which actually implement the storage
            for the BlockExpression.
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.BlockExpression.Rewrite(System.Collections.Generic.IList{System.Linq.Expressions.ParameterExpression},System.Linq.Expressions.Expression[])">
            <summary>
            Makes a copy of this node replacing the parameters/args with the provided values.  The 
            shape of the parameters/args needs to match the shape of the current block - in other
            words there should be the same # of parameters and args.
            
            parameters can be null in which case the existing parameters are used.
            
            This helper is provided to allow re-writing of nodes to not depend on the specific optimized
            subclass of BlockExpression which is being used. 
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.BlockExpression.ReturnReadOnlyExpressions(System.Linq.Expressions.BlockExpression,System.Object@)">
            <summary>
            Helper used for ensuring we only return 1 instance of a ReadOnlyCollection of T.
            
            This is similar to the ReturnReadOnly which only takes a single argument. This version
            supports nodes which hold onto 5 Expressions and puts all of the arguments into the
            ReadOnlyCollection.
            
            Ultimately this means if we create the ROC we will be slightly more wasteful as we'll
            have a ROC + some fields in the type.  The DLR internally avoids accessing anything
            which would force the ROC to be created.
            
            This is used by BlockExpression5 and MethodCallExpression5.
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.BlockExpression.Variables">
            <summary>
            The variables in this block.
            </summary>
        </member>
        <member name="T:System.Linq.Expressions.BlockExpressionList">
            <summary>
            Provides a wrapper around an IArgumentProvider which exposes the argument providers
            members out as an IList of Expression.  This is used to avoid allocating an array
            which needs to be stored inside of a ReadOnlyCollection.  Instead this type has
            the same amount of overhead as an array without duplicating the storage of the
            elements.  This ensures that internally we can avoid creating and copying arrays
            while users of the Expression trees also don't pay a size penalty for this internal
            optimization.  See IArgumentProvider for more general information on the Expression
            tree optimizations being used here.
            </summary>
        </member>
        <member name="M:System.Dynamic.ComInterop.SplatCallSite.MakeBigCaller(System.Int32)">
            <summary>
            Uses LCG to create method such as this:
            
            object SplatCaller(CallSite{T} site, object[] args) {
                 return site.Target(site, args[0], args[1], args[2], ...);
            }
            
            where the CallSite is bound to the delegate
            </summary>
            <param name="args">the number of arguments</param>
            <returns>a SplatCaller delegate.</returns>
        </member>
        <member name="T:System.Dynamic.Binders.RuleTree`1">
            <summary>
            This uses linear search to find a rule.  Clearly that doesn't scale super well.
            We will address this in the future.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:System.Dynamic.Binders.RuleTree`1.FindApplicableRules(System.Object[])">
            <summary>
            Looks through the rule list, prunes invalid rules and returns rules that apply
            </summary>
        </member>
        <member name="T:System.Dynamic.Utils.CacheDict`2">
            <summary>
            Provides a dictionary-like object used for caches which holds onto a maximum
            number of elements specified at construction time.
            
            This class is not thread safe.
            </summary>
        </member>
        <member name="T:System.Linq.Expressions.Compiler.KeyedQueue`2">
            <summary>
            A simple dictionary of queues, keyed off a particular type
            This is useful for storing free lists of variables
            </summary>
        </member>
        <member name="M:System.Dynamic.ComInterop.ReturnBuilder.#ctor(System.Type)">
            <summary>
            Creates a ReturnBuilder
            </summary>
            <param name="returnType">the type the ReturnBuilder will leave on the stack</param>
        </member>
        <member name="T:System.Dynamic.ComInterop.ComEventSinkProxy">
            <summary>
            ComEventSinkProxy class is responsible for handling QIs for sourceIid 
            on instances of ComEventSink.
            
            Background: When a COM even sink advises to a connection point it is 
            supposed to hand over the dispinterface. Now, some hosts will trust
            the COM client to pass the correct pointer, but some will not.
            E.g. Excel's implementation of Connection Points will not cause a
            QI on the pointer that has been passed, however Word will QI the
            pointer to return the required interface.
            
            ComEventSink does not, strongly speaking, implements the interface 
            that it claims to implement - it is just "faking" it by using IReflect.
            Thus, Word's QIs on the pointer passed to ICP::Advise would fail. To
            prevent this we take advangate of RealProxy's ability of
            "dressing up" like other classes and hence successfully respond to QIs 
            for interfaces that it does not really support( it is OK to say 
            "I implement this interface" for event sinks only since the common 
            practice is to use IDistpach.Invoke when calling into event sinks). 
            </summary>
        </member>
        <member name="M:System.Dynamic.Utils.Helpers.RepeatedArray``1(``0,System.Int32)">
            <summary>
            Creates an array of size count with each element initialized to item
            </summary>
        </member>
        <member name="M:System.Dynamic.Utils.TypeUtils.GetNumericConversionOrder(System.TypeCode,System.Int32@,System.Int32@)">
            <summary>
            Returns a numerical code of the size of a type.  All types get both a horizontal
            and vertical code.  Types that are lower in both dimensions have implicit conversions
            to types that are higher in both dimensions.
            </summary>
        </member>
        <member name="M:System.Dynamic.Utils.TypeUtils.GetBooleanOperator(System.Type,System.String)">
            <summary>
            Searches for an operator method on the type. The method must have
            the specified signature, no generic arguments, and have the
            SpecialName bit set. Also searches inherited operator methods.
            
            NOTE: This was designed to satisfy the needs of op_True and
            op_False, because we have to do runtime lookup for those. It may
            not work right for unary operators in general.
            </summary>
        </member>
        <member name="M:System.Dynamic.Utils.TypeUtils.GetTypeForBinding(System.Object)">
            <summary>
            Returns the System.Type for any object, including null.  The type of null
            is represented by None.Type and all other objects just return the 
            result of Object.GetType
            </summary>
        </member>
        <member name="M:System.Dynamic.Utils.TypeUtils.GetTypesForBinding(System.Collections.Generic.IEnumerable{System.Object})">
            <summary>
            Simply returns a Type[] from calling GetTypeForBinding on each element
            </summary>
        </member>
        <member name="T:System.Dynamic.Binders.UpdateDelegates.MatchmakerCache`1">
            <summary>
            Caches a single Matchmaker and its delegate to avoid expensive delegate
            recreation.  We just Interlock.Exchange this out each time we need one
            and replace it when we're done.  If multiple threads are operating we'll
            sometimes end up creating multiple delegates which is as bad w/o the
            cache.
            </summary>
        </member>
        <member name="T:System.Linq.Expressions.SymbolDocumentInfo">
            <summary>
            Stores information needed to emit debugging symbol information for a
            source file, in particular the file name and unique language identifier
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.SymbolDocumentInfo.FileName">
            <summary>
            The source file name
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.SymbolDocumentInfo.Language">
            <summary>
            Returns the language's unique identifier, if any
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor">
            <summary>
            Returns the language vendor's unique identifier, if any
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.SymbolDocumentInfo.DocumentType">
            <summary>
            Returns the document type's unique identifier, if any
            Defaults to the guid for a text file
            </summary>
        </member>
        <member name="T:System.Linq.Expressions.ListArgumentProvider">
            <summary>
            Provides a wrapper around an IArgumentProvider which exposes the argument providers
            members out as an IList of Expression.  This is used to avoid allocating an array
            which needs to be stored inside of a ReadOnlyCollection.  Instead this type has
            the same amount of overhead as an array without duplicating the storage of the
            elements.  This ensures that internally we can avoid creating and copying arrays
            while users of the Expression trees also don't pay a size penalty for this internal
            optimization.  See IArgumentProvider for more general information on the Expression
            tree optimizations being used here.
            </summary>
        </member>
        <member name="T:System.Linq.Expressions.Strings">
            <summary>
               Strongly-typed and parameterized string factory.
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Strings.UserDefinedOperatorMustBeStatic(System.Object)">
            <summary>
            A string like  "User-defined operator method '{0}' must be static."
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Strings.UserDefinedOperatorMustNotBeVoid(System.Object)">
            <summary>
            A string like  "User-defined operator method '{0}' must not be void."
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Strings.CoercionOperatorNotDefined(System.Object,System.Object)">
            <summary>
            A string like  "No coercion operator is defined between types '{0}' and '{1}'."
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Strings.UnaryOperatorNotDefined(System.Object,System.Object)">
            <summary>
            A string like  "The unary operator {0} is not defined for the type '{1}'."
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Strings.BinaryOperatorNotDefined(System.Object,System.Object,System.Object)">
            <summary>
            A string like  "The binary operator {0} is not defined for the types '{1}' and '{2}'."
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Strings.OperandTypesDoNotMatchParameters(System.Object,System.Object)">
            <summary>
            A string like  "The operands for operator '{0}' do not match the parameters of method '{1}'."
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Strings.CannotAutoInitializeValueTypeElementThroughProperty(System.Object)">
            <summary>
            A string like  "Cannot auto initialize elements of value type through property '{0}', use assignment instead"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Strings.CannotAutoInitializeValueTypeMemberThroughProperty(System.Object)">
            <summary>
            A string like  "Cannot auto initialize members of value type through property '{0}', use assignment instead"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Strings.CannotCastTypeToType(System.Object,System.Object)">
            <summary>
            A string like  "An expression of type '{0}' cannot be cast to type '{1}'"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Strings.IncorrectTypeForTypeAs(System.Object)">
            <summary>
            A string like  "The type used in TypeAs Expression must be of reference or nullable type, {0} is neither"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Strings.ExpressionTypeCannotInitializeArrayType(System.Object,System.Object)">
            <summary>
            A string like  "An expression of type '{0}' cannot be used to initialize an array of type '{1}'"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Strings.ExpressionTypeDoesNotMatchConstructorParameter(System.Object,System.Object)">
            <summary>
            A string like  "Expression of type '{0}' cannot be used for constructor parameter of type '{1}'"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Strings.ArgumentTypeDoesNotMatchMember(System.Object,System.Object)">
            <summary>
            A string like  " Argument type '{0}' does not match the corresponding member type '{1}'"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Strings.ArgumentMemberNotDeclOnType(System.Object,System.Object)">
            <summary>
            A string like  " The member '{0}' is not declared on type '{1}' being created"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Strings.ExpressionTypeDoesNotMatchMethodParameter(System.Object,System.Object,System.Object)">
            <summary>
            A string like  "Expression of type '{0}' cannot be used for parameter of type '{1}' of method '{2}'"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Strings.ExpressionTypeDoesNotMatchParameter(System.Object,System.Object)">
            <summary>
            A string like  "Expression of type '{0}' cannot be used for parameter of type '{1}'"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Strings.ExpressionTypeDoesNotMatchReturn(System.Object,System.Object)">
            <summary>
            A string like  "Expression of type '{0}' cannot be used for return type '{1}'"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Strings.ExpressionTypeDoesNotMatchAssignment(System.Object,System.Object)">
            <summary>
            A string like  "Expression of type '{0}' cannot be used for assignment to type '{1}'"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Strings.ExpressionTypeDoesNotMatchLabel(System.Object,System.Object)">
            <summary>
            A string like  "Expression of type '{0}' cannot be used for label of type '{1}'"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Strings.ExpressionTypeNotInvocable(System.Object)">
            <summary>
            A string like  "Expression of type '{0}' cannot be invoked"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Strings.FieldNotDefinedForType(System.Object,System.Object)">
            <summary>
            A string like  "Field '{0}' is not defined for type '{1}'"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Strings.IncorrectNumberOfMethodCallArguments(System.Object)">
            <summary>
            A string like  "Incorrect number of arguments supplied for call to method '{0}'"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Strings.MemberNotFieldOrProperty(System.Object)">
            <summary>
            A string like  "Member '{0}' not field or property"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Strings.MethodContainsGenericParameters(System.Object)">
            <summary>
            A string like  "Method {0} contains generic parameters"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Strings.MethodIsGeneric(System.Object)">
            <summary>
            A string like  "Method {0} is a generic method definition"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Strings.MethodNotPropertyAccessor(System.Object,System.Object)">
            <summary>
            A string like  "The method '{0}.{1}' is not a property accessor"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Strings.PropertyDoesNotHaveGetter(System.Object)">
            <summary>
            A string like  "The property '{0}' has no 'get' accessor"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Strings.PropertyDoesNotHaveSetter(System.Object)">
            <summary>
            A string like  "The property '{0}' has no 'set' accessor"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Strings.PropertyDoesNotHaveAccessor(System.Object)">
            <summary>
            A string like  "The property '{0}' has no 'get' or 'set' accessors"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Strings.NotAMemberOfType(System.Object,System.Object)">
            <summary>
            A string like  "'{0}' is not a member of type '{1}'"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Strings.OperatorNotImplementedForType(System.Object,System.Object)">
            <summary>
            A string like  "The operator '{0}' is not implemented for type '{1}'"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Strings.ParameterExpressionNotValidAsDelegate(System.Object,System.Object)">
            <summary>
            A string like  "ParameterExpression of type '{0}' cannot be used for delegate parameter of type '{1}'"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Strings.PropertyNotDefinedForType(System.Object,System.Object)">
            <summary>
            A string like  "Property '{0}' is not defined for type '{1}'"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Strings.MethodNotDefinedForType(System.Object,System.Object)">
            <summary>
            A string like  "Method '{0}' is not defined for type '{1}'"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Strings.TypeContainsGenericParameters(System.Object)">
            <summary>
            A string like  "Type {0} contains generic parameters"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Strings.TypeIsGeneric(System.Object)">
            <summary>
            A string like  "Type {0} is a generic type definition"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Strings.TypeMissingDefaultConstructor(System.Object)">
            <summary>
            A string like  "Type '{0}' does not have a default constructor"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Strings.ElementInitializerMethodNoRefOutParam(System.Object,System.Object)">
            <summary>
            A string like  "Parameter '{0}' of element initializer method '{1}' must not be a pass by reference parameter"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Strings.TypeNotIEnumerable(System.Object)">
            <summary>
            A string like  "Type '{0}' is not IEnumerable"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Strings.TypeParameterIsNotDelegate(System.Object)">
            <summary>
            A string like  "Type parameter is {0}. Expected a delegate."
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Strings.InvalidCast(System.Object,System.Object)">
            <summary>
            A string like  "Cannot cast from type '{0}' to type '{1}"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Strings.UnhandledBinary(System.Object)">
            <summary>
            A string like  "Unhandled binary: {0}"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Strings.UnhandledBindingType(System.Object)">
            <summary>
            A string like  "Unhandled Binding Type: {0}"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Strings.UnhandledConvert(System.Object)">
            <summary>
            A string like  "Unhandled convert: {0}"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Strings.UnhandledExpressionType(System.Object)">
            <summary>
            A string like  "Unhandled Expression Type: {0}"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Strings.UnhandledUnary(System.Object)">
            <summary>
            A string like  "Unhandled unary: {0}"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Strings.UserDefinedOpMustHaveConsistentTypes(System.Object,System.Object)">
            <summary>
            A string like  "The user-defined operator method '{1}' for operator '{0}' must have identical parameter and return types."
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Strings.UserDefinedOpMustHaveValidReturnType(System.Object,System.Object)">
            <summary>
            A string like  "The user-defined operator method '{1}' for operator '{0}' must return the same type as its parameter or a derived type."
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Strings.LogicalOperatorMustHaveBooleanOperators(System.Object,System.Object)">
            <summary>
            A string like  "The user-defined operator method '{1}' for operator '{0}' must have associated boolean True and False operators."
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Strings.MethodDoesNotExistOnType(System.Object,System.Object)">
            <summary>
            A string like  "No method '{0}' exists on type '{1}'."
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Strings.MethodWithArgsDoesNotExistOnType(System.Object,System.Object)">
            <summary>
            A string like  "No method '{0}' on type '{1}' is compatible with the supplied arguments."
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Strings.MethodWithMoreThanOneMatch(System.Object,System.Object)">
            <summary>
            A string like  "More than one method '{0}' on type '{1}' is compatible with the supplied arguments."
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Strings.ArgumentCountMustMatchBinding(System.Object,System.Object)">
            <summary>
            A string like  "Argument count (including instance) '{0}' must match arguments in the binding information '{1}'"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Strings.InvalidOperation(System.Object)">
            <summary>
            A string like  "Invalid operation: '{0}'"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Strings.OutOfRange(System.Object,System.Object)">
            <summary>
            A string like  "{0} must be greater than or equal to {1}"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Strings.TypeLibDoesNotContainInterface(System.Object,System.Object)">
            <summary>
            A string like  "TypeLib '{0}' does not contain COM interface '{1}'."
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Strings.UnexpectedVarEnum(System.Object)">
            <summary>
            A string like  "Unexpected VarEnum {0}."
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Strings.DispBadParamCount(System.Object)">
            <summary>
            A string like  "Error while invoking {0}."
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Strings.DispMemberNotFound(System.Object)">
            <summary>
            A string like  "Error while invoking {0}."
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Strings.DispNoNamedArgs(System.Object)">
            <summary>
            A string like  "Error while invoking {0}. Named arguments are not supported."
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Strings.DispOverflow(System.Object)">
            <summary>
            A string like  "Error while invoking {0}."
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Strings.DispTypeMismatch(System.Object,System.Object)">
            <summary>
            A string like  "Could not convert argument {0} for call to {1}."
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Strings.DispParamNotOptional(System.Object)">
            <summary>
            A string like  "Error while invoking {0}. A required parameter was omitted."
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Strings.GetIDsOfNamesInvalid(System.Object)">
            <summary>
            A string like  "IDispatch::GetIDsOfNames behaved unexpectedly for {0}."
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Strings.CouldNotGetDispId(System.Object,System.Object)">
            <summary>
            A string like  "Could not get DispId for {0} (error:{1})."
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Strings.AmbiguousConversion(System.Object,System.Object)">
            <summary>
            A string like  "There are valid conversions from {0} to {1}."
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Strings.VariantToObjectNYI(System.Object)">
            <summary>
            A string like  "Variant.ToObject cannot handle {0}."
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Strings.VariantGetAccessorNYI(System.Object)">
            <summary>
            A string like  "Variant.GetAccessor cannot handle {0}."
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Strings.LabelTargetAlreadyDefined(System.Object)">
            <summary>
            A string like  "Cannot redefine label '{0}' in an inner block."
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Strings.LabelTargetUndefined(System.Object)">
            <summary>
            A string like  "Cannot jump to to undefined label '{0}'."
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Strings.AmbiguousJump(System.Object)">
            <summary>
            A string like  "Cannot jump to ambiguous label '{0}'."
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Strings.InvalidLvalue(System.Object)">
            <summary>
            A string like  "Invalid lvalue for assignment: {0}."
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Strings.InvalidMemberType(System.Object)">
            <summary>
            A string like  "Invalid member type: {0}."
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Strings.UnknownLiftType(System.Object)">
            <summary>
            A string like  "unknown lift type: '{0}'."
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Strings.CanotEmitConstant(System.Object,System.Object)">
            <summary>
            A string like  "Cannot emit constant {0} ({1})"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Strings.NoImplicitCast(System.Object,System.Object)">
            <summary>
            A string like  "No implicit cast from {0} to {1}"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Strings.NoExplicitCast(System.Object,System.Object)">
            <summary>
            A string like  "No explicit cast from {0} to {1}"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Strings.IllegalNewGenericParams(System.Object)">
            <summary>
            A string like  "Cannot create instance of {0} because it contains generic parameters"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Strings.VerificationException(System.Object,System.Object,System.Object)">
            <summary>
            A string like  "Non-verifiable assembly generated: {0}:\nAssembly preserved as {1}\nError text:\n{2}\n"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Strings.UnboundVariable(System.Object,System.Object)">
            <summary>
            A string like  "Variable '{0}' referenced from lambda '{1}', but it is not defined in an outer scope"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Strings.UndefinedVariable(System.Object,System.Object,System.Object)">
            <summary>
            A string like  "variable '{0}' of type '{1}' referenced from scope '{2}', but it is not defined"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Strings.InvalidReturnTypeOfLambda(System.Object,System.Object,System.Object)">
            <summary>
            A string like  "Expression of type '{0}' cannot be used for return type '{1}' of lambda '{2}'"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Strings.MissingReturnForLambda(System.Object,System.Object)">
            <summary>
            A string like  "Expression missing for return in lambda '{0}', must have return type '{1}'"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Strings.CannotCloseOverByRef(System.Object,System.Object)">
            <summary>
            A string like  "Cannot close over byref parameter '{0}' referenced in lambda '{1}'"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Strings.UnexpectedType(System.Object,System.Object)">
            <summary>
            A string like  "Expected type {0}, got {1}."
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Strings.UnexpectedVarArgsCall(System.Object)">
            <summary>
            A string like  "Unexpected VarArgs call to method '{0}'"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Strings.MustRewriteToSameType(System.Object,System.Object,System.Object)">
            <summary>
            A string like  "When called from '{0}', rewriting a node of type '{1}' should return a non-null value of the same type. Alternatively, override '{2}' and change it to not visit children of this type."
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Strings.RuntimeVariablesNotSupportedInQuote(System.Object)">
            <summary>
            A string like  "A Quote expression cannot be used on RuntimeVariables expression '{0}' because at least one variable is declared outside the Quote"
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.OwningTeam">
            <summary>
            A string like  "DLinq"
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.MethodPreconditionViolated">
            <summary>
            A string like  "Method precondition violated"
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.InvalidArgumentValue">
            <summary>
            A string like  "Invalid argument value"
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.NonEmptyStringRequired">
            <summary>
            A string like  "Non-empty string required"
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.NonEmptyCollectionRequired">
            <summary>
            A string like  "Non-empty collection required"
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.MustBePositive">
            <summary>
            A string like  "must be &gt;= 0"
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.ArrayIndexMustBeInt">
            <summary>
            A string like  "Array index must be an int."
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.ArrayArgumentMustBeArray">
            <summary>
            A string like  "Array argument must be array."
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.IncorrectIndicesCount">
            <summary>
            A string like  "Incorrect number of indices."
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.ValueTypeMustMatchElementType">
            <summary>
            A string like  "Value type must match the array element type."
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.RhsMustBeAssignableToLhs">
            <summary>
            A string like  "right side must be assignable to left side"
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.ReducibleMustOverrideReduce">
            <summary>
            A string like  "reducible nodes must override Expression.Reduce()"
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.MustReduceToDifferent">
            <summary>
            A string like  "node cannot reduce to itself or null"
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.ReducedNotCompatible">
            <summary>
            A string like  "cannot assign from the reduced node type to the original node type"
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.NoGetterSetter">
            <summary>
            A string like  "No getter or setter specified"
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.SetterHasNoParams">
            <summary>
            A string like  "Setter must have parameters."
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.PropertyCannotHaveRefType">
            <summary>
            A string like  "Property cannot have a managed pointer type."
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.IndexesOfSetGetMustMatch">
            <summary>
            A string like  "Indexing parameters of getter and setter must match."
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.AccessorsCannotHaveVarArgs">
            <summary>
            A string like  "Accessor method should not have VarArgs."
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.AccessorsCannotHaveByRefArgs">
            <summary>
            A string like  "Accessor indexes cannot be passed ByRef."
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.IncorrectInstanceTypeField">
            <summary>
            A string like  "Incorrect instance type for the field"
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.IncorrectValueTypeField">
            <summary>
            A string like  "Incorrect value type for the field"
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.IncorrectinstanceTypeProperty">
            <summary>
            A string like  "Incorrect instance type for the property"
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.SetMustHaveParams">
            <summary>
            A string like  "set method must have at least one parameter"
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.IncorrectValueTypeForProperty">
            <summary>
            A string like  "Incorrect value type for the property"
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.MustBeStatic">
            <summary>
            A string like  "Method must be static"
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.IncorrectArgNumber">
            <summary>
            A string like  "Incorrect number of arguments"
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.ArgumentNotProvided">
            <summary>
            A string like  "Argument not provided for a mandatory parameter"
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.BoundsCannotBeLessThanOne">
            <summary>
            A string like  "Bounds count cannot be less than 1"
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.ValueMustBeInt">
            <summary>
            A string like  "Value must be int"
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.OnlyDefaultIsAllowed">
            <summary>
            A string like  "Only one default clause allowed"
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.CaseValuesMustBeUnique">
            <summary>
            A string like  "Case values must be unique"
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.TypeMustNotBeByRef">
            <summary>
            A string like  "type must not be ByRef"
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.VariableMustNotBeByRef">
            <summary>
            A string like  "variable must not be ByRef"
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.OperationKindMustMatchNodeType">
            <summary>
            A string like  "operation kind must match node type"
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.MustHaveAtLeastTarget">
            <summary>
            A string like  "Must receive at least one argument, the target to call"
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.PropertyDoesNotExist">
            <summary>
            A string like  "Property doesn't exist on the provided type"
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.FieldDoesNotExist">
            <summary>
            A string like  "Field doesn't exist on provided type"
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.TypeDoesNotHaveConstructorForTheSignature">
            <summary>
            A string like  "Type doesn't have constructor with a given signature"
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.TypeDoesNotHaveMethodForName">
            <summary>
            A string like  "Type doesn't have a method with a given name."
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.TypeDoesNotHaveMethodForNameSignature">
            <summary>
            A string like  "Type doesn't have a method with a given name and signature."
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.CountCannotBeNegative">
            <summary>
            A string like  "Count must be non-negative."
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.ArrayTypeMustBeArray">
            <summary>
            A string like  "arrayType must be an array type"
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.SetterMustBeVoid">
            <summary>
            A string like  "Setter should have void type."
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.PropertyTyepMustMatchSetter">
            <summary>
            A string like  "Property type must match the value type of setter"
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.BothAccessorsMustBeStatic">
            <summary>
            A string like  "Both accessors must be static."
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.OnlyStaticFieldsHaveNullExpr">
            <summary>
            A string like  "Static field requires null expression, non-static field requires non-null expression."
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.OnlyStaticPropertiesHaveNullExpr">
            <summary>
            A string like  "Static property requires null expression, non-static property requires non-null expression."
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.OnlyStaticMethodsHaveNullExpr">
            <summary>
            A string like  "Static method requires null expression, non-static method requires non-null expression."
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.PropertyTypeCannotBeVoid">
            <summary>
            A string like  "Property cannot have a void type."
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.PropertyNotReadable">
            <summary>
            A string like  "Property is not readable"
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.PropertyNotWriteable">
            <summary>
            A string like  "Property is not writeable"
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.InvalidUnboxType">
            <summary>
            A string like  "Can only unbox from an object or interface type to a value type."
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.ExpressionMustBeReadable">
            <summary>
            A string like  "Expression must be readable"
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.ExpressionMustBeWriteable">
            <summary>
            A string like  "Expression must be writeable"
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.ArgumentMustBeException">
            <summary>
            A string like  "Argument must be exception"
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.SubtreesMustBeBound">
            <summary>
            A string like  "subtrees of nodes with non-null type must also have non-null type"
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.MustReduceToReadable">
            <summary>
            A string like  "readable Expression must reduce to readable Expression"
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.MustReduceToWriteable">
            <summary>
            A string like  "writeable Expression must reduce to writeable Expression"
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.MustBeReducible">
            <summary>
            A string like  "must be reducible node"
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.MustBeReadableOrWriteable">
            <summary>
            A string like  "must be readable or writeable"
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.InvalidTypeBuilder">
            <summary>
            A string like  "TypeBuilder does not have a valid ModuleBuilder"
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.ConditionMustBeBoolean">
            <summary>
            A string like  "Condition must be boolean."
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.TypeMustBeDerivedFromSystemDelegate">
            <summary>
            A string like  "Type must be derived from System.Delegate"
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.ArgumentTypeCannotBeVoid">
            <summary>
            A string like  "Argument type cannot be void"
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.LabelMustBeVoidOrHaveExpression">
            <summary>
            A string like  "Label type must be System.Void if an expression is not supplied"
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.LabelTypeMustBeVoid">
            <summary>
            A string like  "Type must be System.Void for this label argument"
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.TypeOrBindingInfoMustBeNonNull">
            <summary>
            A string like  "type or bindingInfo must be non-null"
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.StartEndMustBeOrdered">
            <summary>
            A string like  "Start and End must be well ordered"
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.StartEndCanOnlyBothBeInvalid">
            <summary>
            A string like  "Start and End must both be valid or both invalid"
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.CannotHaveFinallyAndFault">
            <summary>
            A string like  "cannot have finally and fault"
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.TryMustHaveCatchFinallyOrFault">
            <summary>
            A string like  "try must have at least one catch, finally, or fault clause"
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.ArgumentMustBeArray">
            <summary>
            A string like  "Argument must be array"
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.ArgumentMustBeBoolean">
            <summary>
            A string like  "Argument must be boolean"
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.ArgumentMustBeFieldInfoOrPropertInfo">
            <summary>
            A string like  "Argument must be either a FieldInfo or PropertyInfo"
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.ArgumentMustBeFieldInfoOrPropertInfoOrMethod">
            <summary>
            A string like  "Argument must be either a FieldInfo, PropertyInfo or MethodInfo"
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.ArgumentMustBeInstanceMember">
            <summary>
            A string like  "Argument must be an instance member"
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.ArgumentMustBeInteger">
            <summary>
            A string like  "Argument must be of an integer type"
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.ArgumentMustBeArrayIndexType">
            <summary>
            A string like  "Argument for array index must be of type Int32"
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.ArgumentMustBeSingleDimensionalArrayType">
            <summary>
            A string like  "Argument must be single dimensional array type"
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.ArgumentTypesMustMatch">
            <summary>
            A string like  "Argument types do not match"
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.CoalesceUsedOnNonNullType">
            <summary>
            A string like  "Coalesce used with type that cannot be null"
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.IncorrectNumberOfIndexes">
            <summary>
            A string like  "Incorrect number of indexes"
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.IncorrectNumberOfLambdaArguments">
            <summary>
            A string like  "Incorrect number of arguments supplied for lambda invocation"
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.IncorrectNumberOfLambdaDeclarationParameters">
            <summary>
            A string like  "Incorrect number of parameters supplied for lambda declaration"
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.IncorrectNumberOfConstructorArguments">
            <summary>
            A string like  "Incorrect number of arguments for constructor"
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.IncorrectNumberOfMembersForGivenConstructor">
            <summary>
            A string like  " Incorrect number of members for constructor"
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.IncorrectNumberOfArgumentsForMembers">
            <summary>
            A string like  "Incorrect number of arguments for the given members "
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.LambdaTypeMustBeDerivedFromSystemDelegate">
            <summary>
            A string like  "Lambda type parameter must be derived from System.Delegate"
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.ListInitializerWithZeroMembers">
            <summary>
            A string like  "List initializers must contain at least one initializer"
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.ElementInitializerMethodNotAdd">
            <summary>
            A string like  "Element initializer method must be named 'Add'"
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.ElementInitializerMethodWithZeroArgs">
            <summary>
            A string like  "Element initializer method must have at least 1 parameter"
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.ElementInitializerMethodStatic">
            <summary>
            A string like  "Element initializer method must be an instance method"
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.UnexpectedCoalesceOperator">
            <summary>
            A string like  "Unexpected coalesce operator."
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.UnhandledBinding">
            <summary>
            A string like  "Unhandled binding "
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.UnknownBindingType">
            <summary>
            A string like  "Unknown binding type"
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.IncorrectNumberOfTypeArgsForFunc">
            <summary>
            A string like  "An incorrect number of type args were specified for the declaration of a Func type."
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.IncorrectNumberOfTypeArgsForAction">
            <summary>
            A string like  "An incorrect number of type args were specified for the declaration of an Action type."
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.ExpressionMayNotContainByrefParameters">
            <summary>
            A string like  "A lambda expression cannot contain pass by reference parameters."
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.ArgumentCannotBeOfTypeVoid">
            <summary>
            A string like  "Argument type cannot be System.Void."
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.NoOrInvalidRuleProduced">
            <summary>
            A string like  "No or Invalid rule produced"
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.FirstArgumentMustBeCallSite">
            <summary>
            A string like  "First argument of delegate must be CallSite"
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.FirstArgumentMustBeStrongBox">
            <summary>
            A string like  "expected StrongBox, but found null."
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.BindingCannotBeNull">
            <summary>
            A string like  "Bind cannot return null."
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.EmptyRuleSetTarget">
            <summary>
            A string like  "Empty rule set does not have target."
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.LhsUnassignable">
            <summary>
            A string like  "Left side of assignment is not an assignable node type."
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.BadDelegateData">
            <summary>
            A string like  "Bad data bound to delegate."
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.RemovingUnregisteredEvent">
            <summary>
            A string like  "Removing an event handler that is not registered."
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.COMObjectDoesNotSupportEvents">
            <summary>
            A string like  "COM object does not support events."
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.COMObjectDoesNotSupportSourceInterface">
            <summary>
            A string like  "COM object does not support specified source interface."
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.RemovingUnregisteredHandler">
            <summary>
            A string like  "Removing not registered handler."
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.SetComObjectDataFailed">
            <summary>
            A string like  "Marshal.SetComObjectData failed."
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.MethodShouldNotBeCalled">
            <summary>
            A string like  "This method exists only to keep the compiler happy."
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.DefaultValueCannotBeRead">
            <summary>
            A string like  "Default value of COM parameter cannot be read properly."
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.CannotRetrieveTypeInformation">
            <summary>
            A string like  "ResolveComReference.CannotRetrieveTypeInformation."
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.UnsupportedEnumType">
            <summary>
            A string like  "Attempting to wrap an unsupported enum type."
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.ComObjectExpected">
            <summary>
            A string like  "COM object is expected."
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.QueueEmpty">
            <summary>
            A string like  "Queue empty."
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.AddressOfVoidBlock">
            <summary>
            A string like  "Cannot emit address of void-typed block."
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.ControlCannotLeaveFinally">
            <summary>
            A string like  "Control cannot leave a finally block."
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.ControlCannotLeaveFilterTest">
            <summary>
            A string like  "Control cannot leave a filter test."
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.ControlCannotEnterTry">
            <summary>
            A string like  "Control cannot enter a try block."
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.ControlCannotEnterExpression">
            <summary>
            A string like  "Control cannot enter an expression--only statements can be jumped into."
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.DynamicNotReduced">
            <summary>
            A string like  "Dynamic expression not reduced."
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.ActionNotReduced">
            <summary>
            A string like  "Action should have been reduced."
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.DeleteNotReduced">
            <summary>
            A string like  "Delete should have been reduced."
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.ExtensionNotReduced">
            <summary>
            A string like  "Extension should have been reduced."
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.RtConstRequiresBundDelegate">
            <summary>
            A string like  "Runtime constants require a bound delegate."
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.OpAssignmentNotReduced">
            <summary>
            A string like  "OpAssignment should have been reduced."
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.InvalidOutputDir">
            <summary>
            A string like  "Invalid output directory."
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.InvalidAsmNameOrExtension">
            <summary>
            A string like  "Invalid assembly name or file extension."
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.NoDefaultValue">
            <summary>
            A string like  "No default value for a given type."
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.StackChangedWhileEnumerationg">
            <summary>
            A string like  "Stack changed while enumerating."
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.CollectionReadOnly">
            <summary>
            A string like  "Collection is read-only."
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.CantReadProperty">
            <summary>
            A string like  "can't read from property"
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.CantWriteProperty">
            <summary>
            A string like  "can't write to property"
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.WrongIteratorReturnType">
            <summary>
            A string like  "Iterator return type must be IEnumerator or IEnumerator&lt;object&gt;."
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.MissingValueNotSupported">
            <summary>
            A string like  "missing parameter value not yet supported"
            </summary>
        </member>
        <member name="P:System.Linq.Expressions.Strings.RethrowRequiresCatch">
            <summary>
            A string like  "Rethrow statement is valid only inside a Catch block."
            </summary>
        </member>
        <member name="T:System.Linq.Expressions.Error">
            <summary>
               Strongly-typed and parameterized exception factory.
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.TypeOrBindingInfoMustBeNonNull">
            <summary>
            ArgumentException with message like "type or bindingInfo must be non-null"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.StartEndMustBeOrdered">
            <summary>
            ArgumentException with message like "Start and End must be well ordered"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.StartEndCanOnlyBothBeInvalid">
            <summary>
            ArgumentException with message like "Start and End must both be valid or both invalid"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.CannotHaveFinallyAndFault">
            <summary>
            ArgumentException with message like "cannot have finally and fault"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.TryMustHaveCatchFinallyOrFault">
            <summary>
            ArgumentException with message like "try must have at least one catch, finally, or fault clause"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.UserDefinedOperatorMustBeStatic(System.Object)">
            <summary>
            ArgumentException with message like "User-defined operator method '{0}' must be static."
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.UserDefinedOperatorMustNotBeVoid(System.Object)">
            <summary>
            ArgumentException with message like "User-defined operator method '{0}' must not be void."
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.CoercionOperatorNotDefined(System.Object,System.Object)">
            <summary>
            InvalidOperationException with message like "No coercion operator is defined between types '{0}' and '{1}'."
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.UnaryOperatorNotDefined(System.Object,System.Object)">
            <summary>
            InvalidOperationException with message like "The unary operator {0} is not defined for the type '{1}'."
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.BinaryOperatorNotDefined(System.Object,System.Object,System.Object)">
            <summary>
            InvalidOperationException with message like "The binary operator {0} is not defined for the types '{1}' and '{2}'."
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.OperandTypesDoNotMatchParameters(System.Object,System.Object)">
            <summary>
            InvalidOperationException with message like "The operands for operator '{0}' do not match the parameters of method '{1}'."
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.ArgumentMustBeArray">
            <summary>
            ArgumentException with message like "Argument must be array"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.ArgumentMustBeBoolean">
            <summary>
            ArgumentException with message like "Argument must be boolean"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.ArgumentMustBeFieldInfoOrPropertInfo">
            <summary>
            ArgumentException with message like "Argument must be either a FieldInfo or PropertyInfo"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.ArgumentMustBeFieldInfoOrPropertInfoOrMethod">
            <summary>
            ArgumentException with message like "Argument must be either a FieldInfo, PropertyInfo or MethodInfo"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.ArgumentMustBeInstanceMember">
            <summary>
            ArgumentException with message like "Argument must be an instance member"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.ArgumentMustBeInteger">
            <summary>
            ArgumentException with message like "Argument must be of an integer type"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.ArgumentMustBeArrayIndexType">
            <summary>
            ArgumentException with message like "Argument for array index must be of type Int32"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.ArgumentMustBeSingleDimensionalArrayType">
            <summary>
            ArgumentException with message like "Argument must be single dimensional array type"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.ArgumentTypesMustMatch">
            <summary>
            ArgumentException with message like "Argument types do not match"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.CannotAutoInitializeValueTypeElementThroughProperty(System.Object)">
            <summary>
            InvalidOperationException with message like "Cannot auto initialize elements of value type through property '{0}', use assignment instead"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.CannotAutoInitializeValueTypeMemberThroughProperty(System.Object)">
            <summary>
            InvalidOperationException with message like "Cannot auto initialize members of value type through property '{0}', use assignment instead"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.CannotCastTypeToType(System.Object,System.Object)">
            <summary>
            ArgumentException with message like "An expression of type '{0}' cannot be cast to type '{1}'"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.IncorrectTypeForTypeAs(System.Object)">
            <summary>
            ArgumentException with message like "The type used in TypeAs Expression must be of reference or nullable type, {0} is neither"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.CoalesceUsedOnNonNullType">
            <summary>
            InvalidOperationException with message like "Coalesce used with type that cannot be null"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.ExpressionTypeCannotInitializeArrayType(System.Object,System.Object)">
            <summary>
            InvalidOperationException with message like "An expression of type '{0}' cannot be used to initialize an array of type '{1}'"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.ExpressionTypeDoesNotMatchConstructorParameter(System.Object,System.Object)">
            <summary>
            ArgumentException with message like "Expression of type '{0}' cannot be used for constructor parameter of type '{1}'"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.ArgumentTypeDoesNotMatchMember(System.Object,System.Object)">
            <summary>
            ArgumentException with message like " Argument type '{0}' does not match the corresponding member type '{1}'"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.ArgumentMemberNotDeclOnType(System.Object,System.Object)">
            <summary>
            ArgumentException with message like " The member '{0}' is not declared on type '{1}' being created"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.ExpressionTypeDoesNotMatchMethodParameter(System.Object,System.Object,System.Object)">
            <summary>
            ArgumentException with message like "Expression of type '{0}' cannot be used for parameter of type '{1}' of method '{2}'"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.ExpressionTypeDoesNotMatchParameter(System.Object,System.Object)">
            <summary>
            ArgumentException with message like "Expression of type '{0}' cannot be used for parameter of type '{1}'"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.ExpressionTypeDoesNotMatchReturn(System.Object,System.Object)">
            <summary>
            ArgumentException with message like "Expression of type '{0}' cannot be used for return type '{1}'"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.ExpressionTypeDoesNotMatchAssignment(System.Object,System.Object)">
            <summary>
            ArgumentException with message like "Expression of type '{0}' cannot be used for assignment to type '{1}'"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.ExpressionTypeDoesNotMatchLabel(System.Object,System.Object)">
            <summary>
            ArgumentException with message like "Expression of type '{0}' cannot be used for label of type '{1}'"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.ExpressionTypeNotInvocable(System.Object)">
            <summary>
            ArgumentException with message like "Expression of type '{0}' cannot be invoked"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.FieldNotDefinedForType(System.Object,System.Object)">
            <summary>
            ArgumentException with message like "Field '{0}' is not defined for type '{1}'"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.IncorrectNumberOfIndexes">
            <summary>
            ArgumentException with message like "Incorrect number of indexes"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.IncorrectNumberOfLambdaArguments">
            <summary>
            InvalidOperationException with message like "Incorrect number of arguments supplied for lambda invocation"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.IncorrectNumberOfLambdaDeclarationParameters">
            <summary>
            ArgumentException with message like "Incorrect number of parameters supplied for lambda declaration"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.IncorrectNumberOfMethodCallArguments(System.Object)">
            <summary>
            ArgumentException with message like "Incorrect number of arguments supplied for call to method '{0}'"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.IncorrectNumberOfConstructorArguments">
            <summary>
            ArgumentException with message like "Incorrect number of arguments for constructor"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.IncorrectNumberOfMembersForGivenConstructor">
            <summary>
            ArgumentException with message like " Incorrect number of members for constructor"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.IncorrectNumberOfArgumentsForMembers">
            <summary>
            ArgumentException with message like "Incorrect number of arguments for the given members "
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.LambdaTypeMustBeDerivedFromSystemDelegate">
            <summary>
            ArgumentException with message like "Lambda type parameter must be derived from System.Delegate"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.MemberNotFieldOrProperty(System.Object)">
            <summary>
            ArgumentException with message like "Member '{0}' not field or property"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.MethodContainsGenericParameters(System.Object)">
            <summary>
            ArgumentException with message like "Method {0} contains generic parameters"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.MethodIsGeneric(System.Object)">
            <summary>
            ArgumentException with message like "Method {0} is a generic method definition"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.MethodNotPropertyAccessor(System.Object,System.Object)">
            <summary>
            ArgumentException with message like "The method '{0}.{1}' is not a property accessor"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.PropertyDoesNotHaveGetter(System.Object)">
            <summary>
            ArgumentException with message like "The property '{0}' has no 'get' accessor"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.PropertyDoesNotHaveSetter(System.Object)">
            <summary>
            ArgumentException with message like "The property '{0}' has no 'set' accessor"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.PropertyDoesNotHaveAccessor(System.Object)">
            <summary>
            ArgumentException with message like "The property '{0}' has no 'get' or 'set' accessors"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.NotAMemberOfType(System.Object,System.Object)">
            <summary>
            ArgumentException with message like "'{0}' is not a member of type '{1}'"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.OperatorNotImplementedForType(System.Object,System.Object)">
            <summary>
            NotImplementedException with message like "The operator '{0}' is not implemented for type '{1}'"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.ParameterExpressionNotValidAsDelegate(System.Object,System.Object)">
            <summary>
            ArgumentException with message like "ParameterExpression of type '{0}' cannot be used for delegate parameter of type '{1}'"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.PropertyNotDefinedForType(System.Object,System.Object)">
            <summary>
            ArgumentException with message like "Property '{0}' is not defined for type '{1}'"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.MethodNotDefinedForType(System.Object,System.Object)">
            <summary>
            ArgumentException with message like "Method '{0}' is not defined for type '{1}'"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.TypeContainsGenericParameters(System.Object)">
            <summary>
            ArgumentException with message like "Type {0} contains generic parameters"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.TypeIsGeneric(System.Object)">
            <summary>
            ArgumentException with message like "Type {0} is a generic type definition"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.TypeMissingDefaultConstructor(System.Object)">
            <summary>
            ArgumentException with message like "Type '{0}' does not have a default constructor"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.ListInitializerWithZeroMembers">
            <summary>
            ArgumentException with message like "List initializers must contain at least one initializer"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.ElementInitializerMethodNotAdd">
            <summary>
            ArgumentException with message like "Element initializer method must be named 'Add'"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.ElementInitializerMethodNoRefOutParam(System.Object,System.Object)">
            <summary>
            ArgumentException with message like "Parameter '{0}' of element initializer method '{1}' must not be a pass by reference parameter"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.ElementInitializerMethodWithZeroArgs">
            <summary>
            ArgumentException with message like "Element initializer method must have at least 1 parameter"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.ElementInitializerMethodStatic">
            <summary>
            ArgumentException with message like "Element initializer method must be an instance method"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.TypeNotIEnumerable(System.Object)">
            <summary>
            ArgumentException with message like "Type '{0}' is not IEnumerable"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.TypeParameterIsNotDelegate(System.Object)">
            <summary>
            InvalidOperationException with message like "Type parameter is {0}. Expected a delegate."
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.UnexpectedCoalesceOperator">
            <summary>
            InvalidOperationException with message like "Unexpected coalesce operator."
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.InvalidCast(System.Object,System.Object)">
            <summary>
            InvalidOperationException with message like "Cannot cast from type '{0}' to type '{1}"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.UnhandledBinary(System.Object)">
            <summary>
            ArgumentException with message like "Unhandled binary: {0}"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.UnhandledBinding">
            <summary>
            ArgumentException with message like "Unhandled binding "
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.UnhandledBindingType(System.Object)">
            <summary>
            ArgumentException with message like "Unhandled Binding Type: {0}"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.UnhandledConvert(System.Object)">
            <summary>
            ArgumentException with message like "Unhandled convert: {0}"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.UnhandledExpressionType(System.Object)">
            <summary>
            ArgumentException with message like "Unhandled Expression Type: {0}"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.UnhandledUnary(System.Object)">
            <summary>
            ArgumentException with message like "Unhandled unary: {0}"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.UnknownBindingType">
            <summary>
            ArgumentException with message like "Unknown binding type"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.UserDefinedOpMustHaveConsistentTypes(System.Object,System.Object)">
            <summary>
            ArgumentException with message like "The user-defined operator method '{1}' for operator '{0}' must have identical parameter and return types."
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.UserDefinedOpMustHaveValidReturnType(System.Object,System.Object)">
            <summary>
            ArgumentException with message like "The user-defined operator method '{1}' for operator '{0}' must return the same type as its parameter or a derived type."
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.LogicalOperatorMustHaveBooleanOperators(System.Object,System.Object)">
            <summary>
            ArgumentException with message like "The user-defined operator method '{1}' for operator '{0}' must have associated boolean True and False operators."
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.MethodDoesNotExistOnType(System.Object,System.Object)">
            <summary>
            InvalidOperationException with message like "No method '{0}' exists on type '{1}'."
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.MethodWithArgsDoesNotExistOnType(System.Object,System.Object)">
            <summary>
            InvalidOperationException with message like "No method '{0}' on type '{1}' is compatible with the supplied arguments."
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.MethodWithMoreThanOneMatch(System.Object,System.Object)">
            <summary>
            InvalidOperationException with message like "More than one method '{0}' on type '{1}' is compatible with the supplied arguments."
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.IncorrectNumberOfTypeArgsForFunc">
            <summary>
            ArgumentException with message like "An incorrect number of type args were specified for the declaration of a Func type."
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.IncorrectNumberOfTypeArgsForAction">
            <summary>
            ArgumentException with message like "An incorrect number of type args were specified for the declaration of an Action type."
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.ExpressionMayNotContainByrefParameters">
            <summary>
            ArgumentException with message like "A lambda expression cannot contain pass by reference parameters."
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.ArgumentCannotBeOfTypeVoid">
            <summary>
            ArgumentException with message like "Argument type cannot be System.Void."
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.NoOrInvalidRuleProduced">
            <summary>
            InvalidOperationException with message like "No or Invalid rule produced"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.FirstArgumentMustBeCallSite">
            <summary>
            ArgumentException with message like "First argument of delegate must be CallSite"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.FirstArgumentMustBeStrongBox">
            <summary>
            ArgumentException with message like "expected StrongBox, but found null."
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.BindingCannotBeNull">
            <summary>
            InvalidOperationException with message like "Bind cannot return null."
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.EmptyRuleSetTarget">
            <summary>
            InvalidOperationException with message like "Empty rule set does not have target."
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.LhsUnassignable">
            <summary>
            ArgumentException with message like "Left side of assignment is not an assignable node type."
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.BadDelegateData">
            <summary>
            InvalidOperationException with message like "Bad data bound to delegate."
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.ArgumentCountMustMatchBinding(System.Object,System.Object)">
            <summary>
            ArgumentException with message like "Argument count (including instance) '{0}' must match arguments in the binding information '{1}'"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.InvalidOperation(System.Object)">
            <summary>
            ArgumentException with message like "Invalid operation: '{0}'"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.OutOfRange(System.Object,System.Object)">
            <summary>
            ArgumentOutOfRangeException with message like "{0} must be greater than or equal to {1}"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.RemovingUnregisteredEvent">
            <summary>
            InvalidOperationException with message like "Removing an event handler that is not registered."
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.COMObjectDoesNotSupportEvents">
            <summary>
            ArgumentException with message like "COM object does not support events."
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.COMObjectDoesNotSupportSourceInterface">
            <summary>
            ArgumentException with message like "COM object does not support specified source interface."
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.RemovingUnregisteredHandler">
            <summary>
            InvalidOperationException with message like "Removing not registered handler."
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.SetComObjectDataFailed">
            <summary>
            System.Runtime.InteropServices.COMException with message like "Marshal.SetComObjectData failed."
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.TypeLibDoesNotContainInterface(System.Object,System.Object)">
            <summary>
            System.Runtime.InteropServices.COMException with message like "TypeLib '{0}' does not contain COM interface '{1}'."
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.MethodShouldNotBeCalled">
            <summary>
            InvalidOperationException with message like "This method exists only to keep the compiler happy."
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.DefaultValueCannotBeRead">
            <summary>
            InvalidProgramException with message like "Default value of COM parameter cannot be read properly."
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.UnexpectedVarEnum(System.Object)">
            <summary>
            InvalidOperationException with message like "Unexpected VarEnum {0}."
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.DispBadParamCount(System.Object)">
            <summary>
            System.Reflection.TargetParameterCountException with message like "Error while invoking {0}."
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.DispMemberNotFound(System.Object)">
            <summary>
            MissingMemberException with message like "Error while invoking {0}."
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.DispNoNamedArgs(System.Object)">
            <summary>
            ArgumentException with message like "Error while invoking {0}. Named arguments are not supported."
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.DispOverflow(System.Object)">
            <summary>
            OverflowException with message like "Error while invoking {0}."
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.DispTypeMismatch(System.Object,System.Object)">
            <summary>
            ArgumentException with message like "Could not convert argument {0} for call to {1}."
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.DispParamNotOptional(System.Object)">
            <summary>
            ArgumentException with message like "Error while invoking {0}. A required parameter was omitted."
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.CannotRetrieveTypeInformation">
            <summary>
            System.Runtime.InteropServices.COMException with message like "ResolveComReference.CannotRetrieveTypeInformation."
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.GetIDsOfNamesInvalid(System.Object)">
            <summary>
            ArgumentException with message like "IDispatch::GetIDsOfNames behaved unexpectedly for {0}."
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.UnsupportedEnumType">
            <summary>
            InvalidOperationException with message like "Attempting to wrap an unsupported enum type."
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.ComObjectExpected">
            <summary>
            ArgumentException with message like "COM object is expected."
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.CouldNotGetDispId(System.Object,System.Object)">
            <summary>
            MissingMemberException with message like "Could not get DispId for {0} (error:{1})."
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.AmbiguousConversion(System.Object,System.Object)">
            <summary>
            System.Reflection.AmbiguousMatchException with message like "There are valid conversions from {0} to {1}."
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.VariantToObjectNYI(System.Object)">
            <summary>
            NotImplementedException with message like "Variant.ToObject cannot handle {0}."
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.VariantGetAccessorNYI(System.Object)">
            <summary>
            NotImplementedException with message like "Variant.GetAccessor cannot handle {0}."
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.QueueEmpty">
            <summary>
            InvalidOperationException with message like "Queue empty."
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.AddressOfVoidBlock">
            <summary>
            NotSupportedException with message like "Cannot emit address of void-typed block."
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.LabelTargetAlreadyDefined(System.Object)">
            <summary>
            InvalidOperationException with message like "Cannot redefine label '{0}' in an inner block."
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.LabelTargetUndefined(System.Object)">
            <summary>
            InvalidOperationException with message like "Cannot jump to to undefined label '{0}'."
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.ControlCannotLeaveFinally">
            <summary>
            InvalidOperationException with message like "Control cannot leave a finally block."
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.ControlCannotLeaveFilterTest">
            <summary>
            InvalidOperationException with message like "Control cannot leave a filter test."
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.AmbiguousJump(System.Object)">
            <summary>
            InvalidOperationException with message like "Cannot jump to ambiguous label '{0}'."
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.ControlCannotEnterTry">
            <summary>
            InvalidOperationException with message like "Control cannot enter a try block."
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.ControlCannotEnterExpression">
            <summary>
            InvalidOperationException with message like "Control cannot enter an expression--only statements can be jumped into."
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.DynamicNotReduced">
            <summary>
            InvalidOperationException with message like "Dynamic expression not reduced."
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.ActionNotReduced">
            <summary>
            InvalidOperationException with message like "Action should have been reduced."
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.DeleteNotReduced">
            <summary>
            InvalidOperationException with message like "Delete should have been reduced."
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.ExtensionNotReduced">
            <summary>
            InvalidOperationException with message like "Extension should have been reduced."
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.RtConstRequiresBundDelegate">
            <summary>
            InvalidOperationException with message like "Runtime constants require a bound delegate."
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.InvalidLvalue(System.Object)">
            <summary>
            InvalidOperationException with message like "Invalid lvalue for assignment: {0}."
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.InvalidMemberType(System.Object)">
            <summary>
            InvalidOperationException with message like "Invalid member type: {0}."
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.OpAssignmentNotReduced">
            <summary>
            InvalidOperationException with message like "OpAssignment should have been reduced."
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.UnknownLiftType(System.Object)">
            <summary>
            InvalidOperationException with message like "unknown lift type: '{0}'."
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.InvalidOutputDir">
            <summary>
            ArgumentException with message like "Invalid output directory."
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.InvalidAsmNameOrExtension">
            <summary>
            ArgumentException with message like "Invalid assembly name or file extension."
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.CanotEmitConstant(System.Object,System.Object)">
            <summary>
            ArgumentException with message like "Cannot emit constant {0} ({1})"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.NoImplicitCast(System.Object,System.Object)">
            <summary>
            ArgumentException with message like "No implicit cast from {0} to {1}"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.NoExplicitCast(System.Object,System.Object)">
            <summary>
            ArgumentException with message like "No explicit cast from {0} to {1}"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.NoDefaultValue">
            <summary>
            ArgumentException with message like "No default value for a given type."
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.StackChangedWhileEnumerationg">
            <summary>
            InvalidOperationException with message like "Stack changed while enumerating."
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.CollectionReadOnly">
            <summary>
            NotSupportedException with message like "Collection is read-only."
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.CantReadProperty">
            <summary>
            InvalidOperationException with message like "can't read from property"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.CantWriteProperty">
            <summary>
            InvalidOperationException with message like "can't write to property"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.IllegalNewGenericParams(System.Object)">
            <summary>
            ArgumentException with message like "Cannot create instance of {0} because it contains generic parameters"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.VerificationException(System.Object,System.Object,System.Object)">
            <summary>
            System.Security.VerificationException with message like "Non-verifiable assembly generated: {0}:\nAssembly preserved as {1}\nError text:\n{2}\n"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.UnboundVariable(System.Object,System.Object)">
            <summary>
            InvalidOperationException with message like "Variable '{0}' referenced from lambda '{1}', but it is not defined in an outer scope"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.UndefinedVariable(System.Object,System.Object,System.Object)">
            <summary>
            InvalidOperationException with message like "variable '{0}' of type '{1}' referenced from scope '{2}', but it is not defined"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.WrongIteratorReturnType">
            <summary>
            ArgumentException with message like "Iterator return type must be IEnumerator or IEnumerator&lt;object&gt;."
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.InvalidReturnTypeOfLambda(System.Object,System.Object,System.Object)">
            <summary>
            InvalidOperationException with message like "Expression of type '{0}' cannot be used for return type '{1}' of lambda '{2}'"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.MissingReturnForLambda(System.Object,System.Object)">
            <summary>
            InvalidOperationException with message like "Expression missing for return in lambda '{0}', must have return type '{1}'"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.CannotCloseOverByRef(System.Object,System.Object)">
            <summary>
            InvalidOperationException with message like "Cannot close over byref parameter '{0}' referenced in lambda '{1}'"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.UnexpectedType(System.Object,System.Object)">
            <summary>
            ArgumentException with message like "Expected type {0}, got {1}."
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.UnexpectedVarArgsCall(System.Object)">
            <summary>
            InvalidOperationException with message like "Unexpected VarArgs call to method '{0}'"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.MissingValueNotSupported">
            <summary>
            NotSupportedException with message like "missing parameter value not yet supported"
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.RethrowRequiresCatch">
            <summary>
            InvalidOperationException with message like "Rethrow statement is valid only inside a Catch block."
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.MustRewriteToSameType(System.Object,System.Object,System.Object)">
            <summary>
            InvalidOperationException with message like "When called from '{0}', rewriting a node of type '{1}' should return a non-null value of the same type. Alternatively, override '{2}' and change it to not visit children of this type."
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.Error.RuntimeVariablesNotSupportedInQuote(System.Object)">
            <summary>
            NotSupportedException with message like "A Quote expression cannot be used on RuntimeVariables expression '{0}' because at least one variable is declared outside the Quote"
            </summary>
        </member>
        <member name="T:System.Linq.Expressions.Compiler.VariableBinder">
            <summary>
            Determines if variables are closed over in nested lambdas and need to
            be hoisted.
            </summary>
        </member>
        <member name="T:System.Dynamic.ComInterop.VarEnumSelector">
            <summary>
            If a managed user type (as opposed to a primitive type or a COM object) is passed as an argument to a COM call, we need
            to determine the VarEnum type we will marshal it as. We have the following options:
            1.	Raise an exception. Languages with their own version of primitive types would not be able to call
                COM methods using the language's types (for eg. strings in IronRuby are not System.String). An explicit
                cast would be needed.
            2.	We could marshal it as VT_DISPATCH. Then COM code will be able to access all the APIs in a late-bound manner,
                but old COM components will probably malfunction if they expect a primitive type.
            3.	We could guess which primitive type is the closest match. This will make COM components be as easily 
                accessible as .NET methods.
            4.	We could use the type library to check what the expected type is. However, the type library may not be available.
            
            VarEnumSelector implements option # 3
            </summary>
        </member>
        <member name="M:System.Dynamic.ComInterop.VarEnumSelector.GetManagedMarshalType(System.Runtime.InteropServices.VarEnum)">
            <summary>
            Gets the managed type that an object needs to be coverted to in order for it to be able
            to be represented as a Variant.
            
            In general, there is a many-to-many mapping between Type and VarEnum. However, this method
            returns a simple mapping that is needed for the current implementation. The reason for the 
            many-to-many relation is:
            1. Int32 maps to VT_I4 as well as VT_ERROR, and Decimal maps to VT_DECIMAL and VT_CY. However,
               this changes if you throw the wrapper types into the mix.
            2. There is no Type to represent COM types. __ComObject is a private type, and Object is too
               general.
            </summary>
        </member>
        <member name="M:System.Dynamic.ComInterop.VarEnumSelector.CreateComPrimitiveTypeFamilies">
            <summary>
            Creates a family of COM types such that within each family, there is a completely non-lossy
            conversion from a type to an earlier type in the family.
            </summary>
        </member>
        <member name="M:System.Dynamic.ComInterop.VarEnumSelector.GetConversionsToComPrimitiveTypeFamilies(System.Type)">
            <summary>
            Get the (one representative type for each) primitive type families that the argument can be converted to
            </summary>
        </member>
        <member name="M:System.Dynamic.ComInterop.VarEnumSelector.CheckForAmbiguousMatch(System.Type,System.Collections.Generic.List{System.Runtime.InteropServices.VarEnum})">
            <summary>
            If there is more than one type family that the argument can be converted to, we will throw a
            AmbiguousMatchException instead of randomly picking a winner.
            </summary>
        </member>
        <member name="M:System.Dynamic.ComInterop.VarEnumSelector.TryGetPrimitiveComTypeViaConversion(System.Type,System.Runtime.InteropServices.VarEnum@)">
            <summary>
            Is there a unique primitive type that has the best conversion for the argument
            </summary>
        </member>
        <member name="M:System.Dynamic.ComInterop.VarEnumSelector.GetVariantBuilder(System.Type)">
            <summary>
            Get the COM Variant type that argument should be marshaled as for a call to COM
            </summary>
        </member>
    </members>
</doc>
