<?xml version="1.0" encoding="utf-8"?>
<doc>
<assembly><name>FSharp.Core</name></assembly>
<members>
<member name="P:Microsoft.BuildSettings.Version.OfFile">

</member>
<member name="P:Microsoft.BuildSettings.Version.OfAssembly">

</member>
<member name="P:Microsoft.BuildSettings.Version.ProductBuild">

</member>
<member name="P:Microsoft.BuildSettings.Version.Minor">

</member>
<member name="P:Microsoft.BuildSettings.Version.Major">

</member>
<member name="T:Microsoft.BuildSettings.Version">

</member>
<member name="P:Microsoft.FSharp.Collections.FSharpList`1.Tail">
<summary>
 Gets the tail of the list, which is a list containing all the elements of the list, excluding the first element 
</summary>
</member>
<member name="P:Microsoft.FSharp.Collections.FSharpList`1.Length">
<summary>
 Gets the number of items contained in the list
</summary>
</member>
<member name="P:Microsoft.FSharp.Collections.FSharpList`1.Item(System.Int32)">
<summary>
 Get the element of the list at the given position. Note lists are represented
 as linked lists so this is an O(n) operation.
</summary>
</member>
<member name="P:Microsoft.FSharp.Collections.FSharpList`1.IsEmpty">
<summary>
 Gets a value indicating if the list contains no entries
</summary>
</member>
<member name="P:Microsoft.FSharp.Collections.FSharpList`1.Head">
<summary>
 Gets the first element of the list
</summary>
</member>
<member name="P:Microsoft.FSharp.Collections.FSharpList`1.Empty">
<summary>
 Returns an empty list of a particular type
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.FSharpList`1.Cons(`0,Microsoft.FSharp.Collections.FSharpList{`0})">
<summary>
 Returns a list with &lt;c&gt;head&lt;/c&gt; as its first element and &lt;c&gt;tail&lt;/c&gt; as its subsequent elements
</summary>
</member>
<member name="T:Microsoft.FSharp.Collections.FSharpList`1">
<summary>
 The type of immutable singly-linked lists. 

 Use the constructors &lt;c&gt;[]&lt;/c&gt; and &lt;c&gt;::&lt;/c&gt; (infix) to create values of this type, or
 the notation &lt;c&gt;[1;2;3]&lt;/c&gt;.  Use the values in the &lt;c&gt;List&lt;/c&gt; module to manipulate 
 values of this type, or pattern match against the values directly.
</summary>
</member>
<member name="P:Microsoft.FSharp.Collections.FSharpMap`2.Item(`0)">
<summary>
 Lookup an element in the map. Raise &lt;c&gt;KeyNotFoundException&lt;/c&gt; if no binding
 exists in the map.
</summary>
</member>
<member name="P:Microsoft.FSharp.Collections.FSharpMap`2.IsEmpty">
<summary>
 Return true if there are no bindings in the map.
</summary>
</member>
<member name="P:Microsoft.FSharp.Collections.FSharpMap`2.Empty">
<summary>
 The empty map
</summary>
</member>
<member name="P:Microsoft.FSharp.Collections.FSharpMap`2.Count">
<summary>
 The number of bindings in the map
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.FSharpMap`2.TryFind(`0)">
<summary>
 Lookup an element in the map, returning a &lt;c&gt;Some&lt;/c&gt; value if the element is in the domain 
 of the map and &lt;c&gt;None&lt;/c&gt; if not.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.FSharpMap`2.Remove(`0)">
<summary>
 Remove an element from the domain of the map.  No exception is raised if the element is not present.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.FSharpMap`2.Equals(System.Object)">

</member>
<member name="M:Microsoft.FSharp.Collections.FSharpMap`2.ContainsKey(`0)">
<summary>
 Test if an element is in the domain of the map
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.FSharpMap`2.Add(`0,`1)">
<summary>
 Return a new map with the binding added to the given map.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.FSharpMap`2..ctor(System.Collections.Generic.IEnumerable{System.Tuple`2{`0,`1}})">
<summary>
 Build a map that contains the bindings of the given IEnumerable
</summary>
</member>
<member name="T:Microsoft.FSharp.Collections.FSharpMap`2">
<summary>
 Immutable maps.  Keys are ordered by F# generic comparison.

 &lt;performance&gt; 
   Maps based on generic comparison are efficient for small keys. They are not a suitable choice if keys are recursive data structures 
   or if keys require bespoke comparison semantics.
 &lt;/performance&gt;
</summary>
</member>
<member name="T:Microsoft.FSharp.Collections.ResizeArray`1">
<summary>
 An abbreviation for the CLI type &lt;c&gt;System.Collections.Generic.List&lt;_&gt;&lt;/c&gt;
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.FSharpSet`1.op_Subtraction(Microsoft.FSharp.Collections.FSharpSet{`0},Microsoft.FSharp.Collections.FSharpSet{`0})">
<summary>
 Return a new set with the elements of the second set removed from the first.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.FSharpSet`1.op_Addition(Microsoft.FSharp.Collections.FSharpSet{`0},Microsoft.FSharp.Collections.FSharpSet{`0})">
<summary>
 Compute the union of the two sets.
</summary>
</member>
<member name="P:Microsoft.FSharp.Collections.FSharpSet`1.MinimumElement">
<summary>
 Returns the lowest element in the set according to the ordering being used for the set
</summary>
</member>
<member name="P:Microsoft.FSharp.Collections.FSharpSet`1.MaximumElement">
<summary>
 Returns the highest element in the set according to the ordering being used for the set
</summary>
</member>
<member name="P:Microsoft.FSharp.Collections.FSharpSet`1.IsEmpty">
<summary>
 A useful shortcut for Set.isEmpty.  See the Set module for further operations on sets.
</summary>
</member>
<member name="P:Microsoft.FSharp.Collections.FSharpSet`1.Empty">

</member>
<member name="P:Microsoft.FSharp.Collections.FSharpSet`1.Count">
<summary>
 The number of elements in the set
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.FSharpSet`1.Subtract(Microsoft.FSharp.Collections.FSharpSet{`0},Microsoft.FSharp.Collections.FSharpSet{`0})">

</member>
<member name="M:Microsoft.FSharp.Collections.FSharpSet`1.Remove(`0)">
<summary>
 A useful shortcut for Set.remove.  Note this operation produces a new set
 and does not mutate the original set.  The new set will share many storage
 nodes with the original.  See the Set module for further operations on sets.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.FSharpSet`1.IsSupersetOf(Microsoft.FSharp.Collections.FSharpSet{`0})">
<summary>
 Evaluates to &quot;true&quot; if all elements of the second set are in the first
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.FSharpSet`1.IsSubsetOf(Microsoft.FSharp.Collections.FSharpSet{`0})">
<summary>
 Evaluates to &quot;true&quot; if all elements of the first set are in the second
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.FSharpSet`1.IsProperSupersetOf(Microsoft.FSharp.Collections.FSharpSet{`0})">
<summary>
 Evaluates to &quot;true&quot; if all elements of the second set are in the first, and at least 
 one element of the first is not in the second
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.FSharpSet`1.IsProperSubsetOf(Microsoft.FSharp.Collections.FSharpSet{`0})">
<summary>
 Evaluates to &quot;true&quot; if all elements of the first set are in the second, and at least 
 one element of the second is not in the first
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.FSharpSet`1.GetPreviousElement(`0)">

</member>
<member name="M:Microsoft.FSharp.Collections.FSharpSet`1.GetNextElement(`0)">

</member>
<member name="M:Microsoft.FSharp.Collections.FSharpSet`1.Equals(System.Object)">

</member>
<member name="M:Microsoft.FSharp.Collections.FSharpSet`1.Contains(`0)">
<summary>
 A useful shortcut for Set.contains.  See the Set module for further operations on sets.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.FSharpSet`1.Add(`0)">
<summary>
 A useful shortcut for Set.add.  Note this operation produces a new set
 and does not mutate the original set.  The new set will share many storage
 nodes with the original.  See the Set module for further operations on sets.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.FSharpSet`1..ctor(System.Collections.Generic.IEnumerable{`0})">
<summary>
 Create a set containing elements drawn from the given sequence.
</summary>
</member>
<member name="T:Microsoft.FSharp.Collections.FSharpSet`1">
<summary>
 Immutable sets based on binary trees, where comparison is the
 F# structural comparison function, potentially using implementations
 of the IComparable interface on key values.

 See the Set module for further operations on sets.

 These sets can be used with elements of any type, but you should check that
 structural hashing and equality on the element type are correct for your type.  
</summary>
</member>
<member name="T:Microsoft.FSharp.Collections.list`1">
<summary>
 An abbreviation for the type of immutable singly-linked lists. 

 Use the constructors &lt;c&gt;[]&lt;/c&gt; and &lt;c&gt;::&lt;/c&gt; (infix) to create values of this type, or
 the notation &lt;c&gt;[1;2;3]&lt;/c&gt;.  Use the values in the &lt;c&gt;List&lt;/c&gt; module to manipulate 
 values of this type, or pattern match against the values directly.
</summary>
</member>
<member name="T:Microsoft.FSharp.Collections.seq`1">
<summary>
 An abbreviation for the CLI type &lt;c&gt;System.Collections.Generic.IEnumerable&lt;_&gt;&lt;/c&gt;
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array2DModule.GetSubArray``1(``0[,]`1,System.Int32,System.Int32,System.Int32,System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Collections.Array2DModule.Get``1(``0[,]`1,System.Int32,System.Int32)">
<summary>
 Fetch an element from a 2D array. You can also use the syntax &apos;array.[index1,index2]&apos; 
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array2DModule.Set``1(``0[,]`1,System.Int32,System.Int32,``0)">
<summary>
 Set the value of an element in an array. You can also use the syntax &apos;array.[index1,index2] &lt;- value&apos; 
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array2DModule.Rebase``1(``0[,]`1)">
<summary>
 Build a new array whose elements are the same as the input array but
 where a non-zero-based input array generates a corresponding zero-based 
 output array.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array2DModule.MapIndexed``2(Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{``0,``1}}},``0[,]`1)">
<summary>
 Build a new array whose elements are the results of applying the given function
 to each of the elements of the array. The integer indices passed to the
 function indicates the element being transformed.

 For non-zero-based arrays the basing on an input array will be propogated to the output
 array.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array2DModule.Map``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},``0[,]`1)">
<summary>
 Build a new array whose elements are the results of applying the given function
 to each of the elements of the array.

 For non-zero-based arrays the basing on an input array will be propogated to the output
 array.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array2DModule.Length2``1(``0[,]`1)">
<summary>
 Return the length of an array in the second dimension  
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array2DModule.Length1``1(``0[,]`1)">
<summary>
 Return the length of an array in the first dimension  
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array2DModule.IterateIndexed``1(Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.Unit}}},``0[,]`1)">
<summary>
 Apply the given function to each element of the array.  The integer indicies passed to the
 function indicates the index of element.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array2DModule.Iterate``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.Unit},``0[,]`1)">
<summary>
 Apply the given function to each element of the array. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array2DModule.ZeroCreateBased``1(System.Int32,System.Int32,System.Int32,System.Int32)">
<summary>
 Create a based array where the entries are initially Unchecked.defaultof&lt;&apos;T&gt;. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array2DModule.CreateBased``1(System.Int32,System.Int32,System.Int32,System.Int32,``0)">
<summary>
 Create a based array whose elements are all initially the given value
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array2DModule.InitializeBased``1(System.Int32,System.Int32,System.Int32,System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,``0}})">
<summary>
 Create a based array given the dimensions and a generator function to compute the elements.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array2DModule.ZeroCreate``1(System.Int32,System.Int32)">
<summary>
 Create an array where the entries are initially Unchecked.defaultof&lt;&apos;T&gt;. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array2DModule.Create``1(System.Int32,System.Int32,``0)">
<summary>
 Create an array whose elements are all initially the given value
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array2DModule.Initialize``1(System.Int32,System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,``0}})">
<summary>
 Create an array given the dimensions and a generator function to compute the elements.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array2DModule.CopyTo``1(``0[,]`1,System.Int32,System.Int32,``0[,]`1,System.Int32,System.Int32,System.Int32,System.Int32)">
<summary>
 Read a range of elements from the first array and write them into the second.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array2DModule.Copy``1(``0[,]`1)">
<summary>
 Build a new array whose elements are the same as the input array.

 For non-zero-based arrays the basing on an input array will be propogated to the output
 array.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array2DModule.Base2``1(``0[,]`1)">
<summary>
 Fetch the base-index for the second dimension of the array.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array2DModule.Base1``1(``0[,]`1)">
<summary>
 Fetch the base-index for the first dimension of the array.
</summary>
</member>
<member name="T:Microsoft.FSharp.Collections.Array2DModule">
<summary>
 Basic operations on 2-dimensional arrays. 

 F# and CLI multi-dimensional arrays are typically zero-based. 
 However, CLI multi-dimensional arrays used in conjunction with external
 libraries (e.g. libraries associated with Visual Basic) be 
 non-zero based, using a potentially different base for each dimension.
 The operations in this module will accept such arrays, and
 the basing on an input array will be propogated to a matching output
 array on the &lt;c&gt;Array2D.map&lt;/c&gt; and &lt;c&gt;Array2D.mapi&lt;/c&gt; operations.
 Non-zero-based arrays can also be created using &lt;c&gt;Array2D.zeroCreateBased&lt;/c&gt;, 
 &lt;c&gt;Array2D.createBased&lt;/c&gt; and &lt;c&gt;Array2D.initBased&lt;/c&gt;.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array3DModule.ZeroCreate``1(System.Int32,System.Int32,System.Int32)">
<summary>
 Create an array where the entries are initially the &quot;default&quot; value. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array3DModule.Set``1(``0[,,]`1,System.Int32,System.Int32,System.Int32,``0)">
<summary>
 Set the value of an element in an array.  You can also 
 use the syntax &apos;array.[index1,index2,index3] &lt;- value&apos;.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array3DModule.MapIndexed``2(Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{``0,``1}}}},``0[,,]`1)">
<summary>
 Build a new array whose elements are the results of applying the given function
 to each of the elements of the array. The integer indices passed to the
 function indicates the element being transformed.

 For non-zero-based arrays the basing on an input array will be propogated to the output
 array.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array3DModule.Map``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},``0[,,]`1)">
<summary>
 Build a new array whose elements are the results of applying the given function
 to each of the elements of the array.

 For non-zero-based arrays the basing on an input array will be propogated to the output
 array.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array3DModule.Length3``1(``0[,,]`1)">
<summary>
 Return the length of an array in the third dimension  
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array3DModule.Length2``1(``0[,,]`1)">
<summary>
 Return the length of an array in the second dimension  
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array3DModule.Length1``1(``0[,,]`1)">
<summary>
 Return the length of an array in the first dimension  
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array3DModule.IterateIndexed``1(Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.Unit}}}},``0[,,]`1)">
<summary>
 Apply the given function to each element of the array.  The integer indicies passed to the
 function indicates the index of element.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array3DModule.Iterate``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.Unit},``0[,,]`1)">
<summary>
 Apply the given function to each element of the array. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array3DModule.Get``1(``0[,,]`1,System.Int32,System.Int32,System.Int32)">
<summary>
 Fetch an element from a 3D array.  You can also use the syntax &apos;array.[index1,index2,index3]&apos;
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array3DModule.Initialize``1(System.Int32,System.Int32,System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,``0}}})">
<summary>
 Create an array given the dimensions and a generator function to compute the elements.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array3DModule.Create``1(System.Int32,System.Int32,System.Int32,``0)">
<summary>
 Create an array whose elements are all initially the given value
</summary>
</member>
<member name="T:Microsoft.FSharp.Collections.Array3DModule">
<summary>
 Basic operations on rank 3 arrays.  
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array4DModule.Set``1(``0[,,,]`1,System.Int32,System.Int32,System.Int32,System.Int32,``0)">
<summary>
 Set the value of an element in an array.  You can also 
 use the syntax &apos;array.[index1,index2,index3,index4] &lt;- value&apos;.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array4DModule.Get``1(``0[,,,]`1,System.Int32,System.Int32,System.Int32,System.Int32)">
<summary>
 Fetch an element from a 4D array.  You can also use the syntax &apos;array.[index1,index2,index3,index4]&apos;
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array4DModule.ZeroCreate``1(System.Int32,System.Int32,System.Int32,System.Int32)">
<summary>
 Create an array where the entries are initially the &quot;default&quot; value. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array4DModule.Length4``1(``0[,,,]`1)">
<summary>
 Return the length of an array in the fourth dimension  
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array4DModule.Length3``1(``0[,,,]`1)">
<summary>
 Return the length of an array in the third dimension  
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array4DModule.Length2``1(``0[,,,]`1)">
<summary>
 Return the length of an array in the second dimension  
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array4DModule.Length1``1(``0[,,,]`1)">
<summary>
 Return the length of an array in the first dimension  
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array4DModule.Initialize``1(System.Int32,System.Int32,System.Int32,System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,``0}}}})">
<summary>
 Create an array given the dimensions and a generator function to compute the elements.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array4DModule.Create``1(System.Int32,System.Int32,System.Int32,System.Int32,``0)">
<summary>
 Create an array whose elements are all initially the given value
</summary>
</member>
<member name="T:Microsoft.FSharp.Collections.Array4DModule">
<summary>
 Basic operations on rank 4 arrays.  
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.CompatibleOfSeq``1(System.Collections.Generic.IEnumerable{``0})">

</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.CompatibleOfList``1(Microsoft.FSharp.Collections.FSharpList{``0})">

</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.CompatibleToSeq``1(``0[]`1)">

</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.CompatibleToList``1(``0[]`1)">

</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Zip3``3(``0[]`1,``1[]`1,``2[]`1)">
<summary>
 Combine three arrays into an array of pairs. The three arrays must have equal lengths, otherwise an &lt;c&gt;ArgumentException&lt;/c&gt; is
 raised.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Zip``2(``0[]`1,``1[]`1)">
<summary>
 Combine the two arrays into an array of pairs. The two arrays must have equal lengths, otherwise an &lt;c&gt;ArgumentException&lt;/c&gt; is
 raised.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Unzip3``3(System.Tuple`3{``0,``1,``2}[]`1)">
<summary>
 Split an array of triples into three arrays
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Unzip``2(System.Tuple`2{``0,``1}[]`1)">
<summary>
 Split an array of pairs into two arrays
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.TryFindIndex``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Boolean},``0[]`1)">
<summary>
 Return the index of the first element in the array
 that satisfies the given predicate.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.TryFind``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Boolean},``0[]`1)">
<summary>
 Return the first element for which the given function returns &lt;c&gt;true&lt;/c&gt;.
 Return &lt;c&gt;None&lt;/c&gt; if no such element exists.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.ToSeq``1(``0[]`1)">
<summary>
 View the given array as a sequence
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.ToList``1(``0[]`1)">
<summary>
 Build a list from the given array
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.SumBy``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},``0[]`1)">
<summary>
 Return the sum of the results generated by applying the function to each element of the array.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Sum``1(``0[]`1)">
<summary>
 Return the sum of the elements in the array
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.SortInPlace``1(``0[]`1)">
<summary>
 Sort the elements of an array by mutating the array in-place, using the given comparison function. 
 Elements are compared using Operators.compare.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.SortInPlaceWith``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Int32}},``0[]`1)">
<summary>
 Sort the elements of an array by mutating the array in-place, using the given comparison function as the order 
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.SortInPlaceBy``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},``0[]`1)">
<summary>
 Sort the elements of an array by mutating the array in-place, using the given projection for the keys. 
 Elements are compared using Operators.compare.

 This is not a stable sort, i.e. the original order of equal elements is not necessarily preserved. 
 For a stable sort, consider using Seq.sort.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.SortWith``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Int32}},``0[]`1)">
<summary>
 Sort the elements of an array, using the given comparison function as the order, returning a new array

 This is not a stable sort, i.e. the original order of equal elements is not necessarily preserved. 
 For a stable sort, consider using Seq.sort.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.SortBy``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},``0[]`1)">
<summary>
 Sort the elements of an array, using the given projection for the keys and returning a new array. 
 Elements are compared using Operators.compare. 

 This is not a stable sort, i.e. the original order of equal elements is not necessarily preserved. 
 For a stable sort, consider using Seq.sort.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Sort``1(``0[]`1)">
<summary>
 Sort the elements of an array, returning a new array. Elements are compared using Operators.compare. 

 This is not a stable sort, i.e. the original order of equal elements is not necessarily preserved. 
 For a stable sort, consider using Seq.sort.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.GetSubArray``1(``0[]`1,System.Int32,System.Int32)">
<summary>
 Build a new array that contains the given subrange specified by
 starting index and length.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Set``1(``0[]`1,System.Int32,``0)">
<summary>
 Set an element of an array
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.ScanBack``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,``1}},``0[]`1,``1)">
<summary>
 Like &lt;c&gt;foldBack&lt;/c&gt;, but return both the intermediary and final results
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Scan``2(Microsoft.FSharp.Core.FSharpFunc`2{``1,Microsoft.FSharp.Core.FSharpFunc`2{``0,``1}},``1,``0[]`1)">
<summary>
 Like &lt;c&gt;fold&lt;/c&gt;, but return the intermediary and final results
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Reverse``1(``0[]`1)">
<summary>
 Return a new array with the elements in reverse order
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.ReduceBack``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``0,``0}},``0[]`1)">
<summary>
 Apply a function to each element of the array, threading an accumulator argument
 through the computation. If the input function is &lt;c&gt;f&lt;/c&gt; and the elements are &lt;c&gt;i0...iN&lt;/c&gt; 
 then computes &lt;c&gt;f i0 (...(f iN-1 iN))&lt;/c&gt;.
 Raises ArgumentException if the array has size zero.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Reduce``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``0,``0}},``0[]`1)">
<summary>
 Apply a function to each element of the array, threading an accumulator argument
 through the computation. If the input function is &lt;c&gt;f&lt;/c&gt; and the elements are &lt;c&gt;i0...iN&lt;/c&gt; 
 then computes &lt;c&gt;f (... (f i0 i1)...) iN&lt;/c&gt;.
 Raises ArgumentException if the array has size zero.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Permute``1(Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,System.Int32},``0[]`1)">
<summary>
 Returns an array with all elements permuted according to the
 specified permutation
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Partition``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Boolean},``0[]`1)">
<summary>
 Split the collection into two collections, containing the 
 elements for which the given predicate returns &quot;true&quot; and &quot;false&quot;
 respectively 
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.OfSeq``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Build a new array from the given enumerable object
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.OfList``1(Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Build an array from the given list
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.MinBy``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},``0[]`1)">
<summary>
 Return the lowest of all elements of the array, compared via Operators.min on the function result

 Throws ArgumentException for empty arrays
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Min``1(``0[]`1)">
<summary>
 Return the lowest of all elements of the array, compared via Operators.min

 Throws ArgumentException for empty arrays
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.MaxBy``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},``0[]`1)">
<summary>
 Return the greatest of all elements of the array, compared via Operators.max on the function result

 Throws ArgumentException for empty arrays
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Max``1(``0[]`1)">
<summary>
 Return the greatest of all elements of the array, compared via Operators.max on the function result

 Throws ArgumentException for empty arrays
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.MapIndexed``2(Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{``0,``1}},``0[]`1)">
<summary>
 Build a new array whose elements are the results of applying the given function
 to each of the elements of the array. The integer index passed to the
 function indicates the index of element being transformed.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.MapIndexed2``3(Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,``2}}},``0[]`1,``1[]`1)">
<summary>
 Build a new collection whose elements are the results of applying the given function
 to the corresponding elements of the two collections pairwise, also passing the index of 
 the elements.  The two input arrays must have the same lengths, otherwise an &lt;c&gt;ArgumentException&lt;/c&gt; is
 raised.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Map2``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,``2}},``0[]`1,``1[]`1)">
<summary>
 Build a new collection whose elements are the results of applying the given function
 to the corresponding elements of the two collections pairwise.  The two input
 arrays must have the same lengths, otherwise an &lt;c&gt;ArgumentException&lt;/c&gt; is
 raised.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Map``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},``0[]`1)">
<summary>
 Build a new array whose elements are the results of applying the given function
 to each of the elements of the array.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Length``1(``0[]`1)">
<summary>
 Return the length of an array.  You can also use property arr.Length.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.IterateIndexed2``2(Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,Microsoft.FSharp.Core.Unit}}},``0[]`1,``1[]`1)">
<summary>
 Apply the given function to pair of elements drawn from matching indices in two arrays,
 also passing the index of the elements. The two arrays must have the same lengths, 
 otherwise an &lt;c&gt;ArgumentException&lt;/c&gt; is raised.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.IterateIndexed``1(Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.Unit}},``0[]`1)">
<summary>
 Apply the given function to each element of the array.  The integer passed to the
 function indicates the index of element.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Iterate2``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,Microsoft.FSharp.Core.Unit}},``0[]`1,``1[]`1)">
<summary>
 Apply the given function to pair of elements drawn from matching indices in two arrays. The
 two arrays must have the same lengths, otherwise an &lt;c&gt;ArgumentException&lt;/c&gt; is
 raised.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Iterate``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.Unit},``0[]`1)">
<summary>
 Apply the given function to each element of the array. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.IsEmpty``1(``0[]`1)">
<summary>
 Return true if the given array is empty, otherwise false
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.ZeroCreate``1(System.Int32)">
<summary>
 Create an array where the entries are initially the default value Unchecked.defaultof&lt;&apos;T&gt;. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Initialize``1(System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,``0})">
<summary>
 Create an array given the dimension and a generator function to compute the elements.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Get``1(``0[]`1,System.Int32)">
<summary>
 Get an element from an array
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.FoldBack2``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,Microsoft.FSharp.Core.FSharpFunc`2{``2,``2}}},``0[]`1,``1[]`1,``2)">
<summary>
 Apply a function to pairs of elements drawn from the two collections, right-to-left, 
 threading an accumulator argument through the computation.  The two input
 arrays must have the same lengths, otherwise an &lt;c&gt;ArgumentException&lt;/c&gt; is
 raised.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Fold2``3(Microsoft.FSharp.Core.FSharpFunc`2{``2,Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,``2}}},``2,``0[]`1,``1[]`1)">
<summary>
 Apply a function to pairs of elements drawn from the two collections, 
 left-to-right, threading an accumulator argument
 through the computation.  The two input
 arrays must have the same lengths, otherwise an &lt;c&gt;ArgumentException&lt;/c&gt; is
 raised.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.FoldBack``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,``1}},``0[]`1,``1)">
<summary>
 Apply a function to each element of the array, threading an accumulator argument
 through the computation. If the input function is &lt;c&gt;f&lt;/c&gt; and the elements are &lt;c&gt;i0...iN&lt;/c&gt; then computes 
 &lt;c&gt;f i0 (...(f iN s))&lt;/c&gt;
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Fold``2(Microsoft.FSharp.Core.FSharpFunc`2{``1,Microsoft.FSharp.Core.FSharpFunc`2{``0,``1}},``1,``0[]`1)">
<summary>
 Apply a function to each element of the collection, threading an accumulator argument
 through the computation. If the input function is &lt;c&gt;f&lt;/c&gt; and the elements are &lt;c&gt;i0...iN&lt;/c&gt; then computes 
 &lt;c&gt;f (... (f s i0)...) iN&lt;/c&gt;
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.ForAll2``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,System.Boolean}},``0[]`1,``1[]`1)">
<summary>
 Test if all corresponding elements of the array satisfy the given predicate pairwise.

 The predicate is applied to matching elements in the two collections up to the lesser of the 
 two lengths of the collections. If any application returns false then the overall result is 
 false and no further elements are tested. Otherwise, if one collection is longer 
 than the other then the &lt;c&gt;ArgumentException&lt;/c&gt; exception is raised. 
 Otherwise, true is returned.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.ForAll``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Boolean},``0[]`1)">
<summary>
 Test if all elements of the array satisfy the given predicate.

 The predicate is applied to the elements of the input collection. If any application 
 returns false then the overall result is false and no further elements are tested. 
 Otherwise, true is returned.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.FindIndex``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Boolean},``0[]`1)">
<summary>
 Return the index of the first element in the array
 that satisfies the given predicate. Raise &lt;c&gt;KeyNotFoundException&lt;/c&gt; if 
 none of the elements satisy the predicate.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Find``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Boolean},``0[]`1)">
<summary>
 Return the first element for which the given function returns &apos;true&apos;.
 Raise &lt;c&gt;KeyNotFoundException&lt;/c&gt; if no such element exists.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Filter``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Boolean},``0[]`1)">
<summary>
 Return a new collection containing only the elements of the collection
 for which the given predicate returns &quot;true&quot;
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Exists2``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,System.Boolean}},``0[]`1,``1[]`1)">
<summary>
 Test if any pair of corresponding elements of the arrays satisfies the given predicate.

 The predicate is applied to matching elements in the two collections up to the lesser of the 
 two lengths of the collections. If any application returns true then the overall result is 
 true and no further elements are tested. Otherwise, if one collections is longer 
 than the other then the &lt;c&gt;ArgumentException&lt;/c&gt; exception is raised. 
 Otherwise, false is returned.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Exists``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Boolean},``0[]`1)">
<summary>
 Test if any element of the array satisfies the given predicate.

 The predicate is applied to the elements of the input array. If any application 
 returns true then the overall result is true and no further elements are tested. 
 Otherwise, false is returned.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Empty``1">
<summary>
 Return an empty array of the given type
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Choose``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpOption{``1}},``0[]`1)">
<summary>
 Apply the given function to each element of the array. Return
 the array comprised of the results &quot;x&quot; for each element where
 the function returns Some(x)
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Pick``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpOption{``1}},``0[]`1)">
<summary>
 Apply the given function to successive elements, returning the first
 result where function returns &lt;c&gt;Some(x)&lt;/c&gt; for some &lt;c&gt;x&lt;/c&gt;. If the function 
 never returns &lt;c&gt;Some(x)&lt;/c&gt; then &lt;c&gt;KeyNotFoundException&lt;/c&gt; is raised.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Fill``1(``0[]`1,System.Int32,System.Int32,``0)">
<summary>
 Fill a range of elements of the array with the given value.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.TryPick``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpOption{``1}},``0[]`1)">
<summary>
 Apply the given function to successive elements, returning the first
 result where function returns &lt;c&gt;Some(x)&lt;/c&gt; for some &lt;c&gt;x&lt;/c&gt;. If the function 
 never returns &lt;c&gt;Some(x)&lt;/c&gt; then &lt;c&gt;None&lt;/c&gt; is returned.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Create``1(System.Int32,``0)">
<summary>
 Create an array whose elements are all initially the given value.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Copy``1(``0[]`1)">
<summary>
 Build a new array that contains the elements of the given array
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Concat``1(System.Collections.Generic.IEnumerable{``0[]`1})">
<summary>
 Build a new array that contains the elements of each of the given sequence of arrays
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Collect``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1[]`1},``0[]`1)">
<summary>
 For each element of the array, apply the given function. Concatenate all the results and return the combined array.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.CopyTo``1(``0[]`1,System.Int32,``0[]`1,System.Int32,System.Int32)">
<summary>
 Read a range of elements from the first array and write them into the second.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.AverageBy``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},``0[]`1)">
<summary>
 Return the average of the elements generated by applying the function to each element of the array.
 If the array is empty an ArgumentException is thrown.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Average``1(``0[]`1)">
<summary>
 Return the average of the elements in the array. If the array is empty an ArgumentException is thrown.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ArrayModule.Append``1(``0[]`1,``0[]`1)">
<summary>
 Build a new array that contains the elements of the first array followed by the elements of the second array
</summary>
</member>
<member name="T:Microsoft.FSharp.Collections.ArrayModule">
<summary>
 Basic operations on arrays
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ComparisonIdentity.FromFunction``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Int32}})">
<summary>
 Compare using the given comparer function
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ComparisonIdentity.GetFastStructuralComparisonFunction``1">

</member>
<member name="M:Microsoft.FSharp.Collections.ComparisonIdentity.GetFastComparisonFunction``1(System.Collections.Generic.IComparer{``0})">

</member>
<member name="M:Microsoft.FSharp.Collections.ComparisonIdentity.Structural``1">
<summary>
 Structural comparison.  Compare using Operators.compare.
</summary>
</member>
<member name="T:Microsoft.FSharp.Collections.ComparisonIdentity">
<summary>
 Common notions of comparison identity used with sorted data structures.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.HashIdentity.FromFunctions``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Int32},Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Boolean}})">
<summary>
 Hash using the given hashing and equality functions
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.HashIdentity.Reference``1">
<summary>
 Physical hashing (hash on reference identity of objects, and the contents of value types).  
 Hash using LanguagePrimitives.PhysicalEquality and LanguagePrimitives.PhysicalHash,
 That is, for value types use GetHashCode and Object.Equals (if no other optimization available),
 and for reference types use System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode and 
 reference equality. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.HashIdentity.LimitedStructural``1(System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Collections.HashIdentity.Structural``1">
<summary>
 Structural hashing.  Hash using Operators.(=) and Operators.hash.
</summary>
</member>
<member name="T:Microsoft.FSharp.Collections.HashIdentity">
<summary>
 Common notions of value identity used with hash tables.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Zip3``3(Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``1},Microsoft.FSharp.Collections.FSharpList{``2})">
<summary>
 Combine the three lists into a list of triples. The lists must have equal lengths.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Zip``2(Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``1})">
<summary>
 Combine the two lists into a list of pairs. The two lists must have equal lengths.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Unzip3``3(Microsoft.FSharp.Collections.FSharpList{System.Tuple`3{``0,``1,``2}})">
<summary>
 Split a list of triples into three lists
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Unzip``2(Microsoft.FSharp.Collections.FSharpList{System.Tuple`2{``0,``1}})">
<summary>
 Split a list of pairs into two lists
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.TryFindIndex``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Boolean},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Return the index of the first element in the list
 that satisfies the given predicate.
 Return &lt;c&gt;None&lt;/c&gt; if no such element exists.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.TryFind``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Boolean},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Return the first element for which the given function returns &lt;c&gt;true&lt;/c&gt;.
 Return &lt;c&gt;None&lt;/c&gt; if no such element exists.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.TryPick``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpOption{``1}},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Apply the given function to successive elements, returning &lt;c&gt;Some(x)&lt;/c&gt; the first
 result where function returns &lt;c&gt;Some(x)&lt;/c&gt; for some x. If no such element 
 exists then return &lt;c&gt;None&lt;/c&gt;
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.ToSeq``1(Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 View the given array as a sequence
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.ToArray``1(Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Build an array from the given list
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.CompatibleToSeq``1(Microsoft.FSharp.Collections.FSharpList{``0})">

</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.CompatibleToArray``1(Microsoft.FSharp.Collections.FSharpList{``0})">

</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Tail``1(Microsoft.FSharp.Collections.FSharpList{``0})">

</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.CompatibleTail``1(Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Return the tail of the list.  

 Raises &lt;c&gt;System.ArgumentException&lt;/c&gt; if &lt;c&gt;list&lt;/c&gt; is empty
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.SumBy``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Return the sum of the results generated by applying the function to each element of the list.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Sum``1(Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Return the sum of the elements in the list
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Sort``1(Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Sort the given list using Operators.compare.

 This is a stable sort, i.e. the original order of equal elements is preserved.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.SortBy``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Sort the given list using keys given by the given projection. Keys are compared using Operators.compare. 

 This is a stable sort, i.e. the original order of equal elements is preserved.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.SortWith``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Int32}},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Sort the given list using the given comparison function

 This is a stable sort, i.e. the original order of equal elements is preserved.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.ScanBack``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,``1}},Microsoft.FSharp.Collections.FSharpList{``0},``1)">
<summary>
 Like &lt;c&gt;foldBack&lt;/c&gt;, but return both the intermediary and final results
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Scan``2(Microsoft.FSharp.Core.FSharpFunc`2{``1,Microsoft.FSharp.Core.FSharpFunc`2{``0,``1}},``1,Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Apply a function to each element of the collection, threading an accumulator argument
 through the computation. Take the second argument, and apply the function to it
 and the first element of the list.  Then feed this result into the function along
 with the second element and so on.  Return the list of intermediate results and the final result.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Reverse``1(Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Return a new list with the elements in reverse order
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Replicate``1(System.Int32,``0)">
<summary>
 Create a list by calling the given generator on each index
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.ReduceBack``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``0,``0}},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Apply a function to each element of the collection, threading an accumulator argument
 through the computation. If the input function is &lt;c&gt;f&lt;/c&gt; and the elements are &lt;c&gt;i0...iN&lt;/c&gt; then computes 
 &lt;c&gt;f i0 (...(f iN-1 iN))&lt;/c&gt;.

 Raises &lt;c&gt;System.ArgumentException&lt;/c&gt; if &lt;c&gt;list&lt;/c&gt; is empty
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Reduce``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``0,``0}},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Apply a function to each element of the collection, threading an accumulator argument
 through the computation. Apply the function to the first two elements of the list.
 Then feed this result into the function along with the third element and so on.  
 Return the final result. If the input function is &lt;c&gt;f&lt;/c&gt; and the elements are &lt;c&gt;i0...iN&lt;/c&gt; then computes 
 &lt;c&gt;f (... (f i0 i1) i2 ...) iN&lt;/c&gt;.

 Raises &lt;c&gt;System.ArgumentException&lt;/c&gt; if &lt;c&gt;list&lt;/c&gt; is empty
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Permute``1(Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,System.Int32},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Returns a list with all elements permuted according to the
 specified permutation
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Pick``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpOption{``1}},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Apply the given function to successive elements, returning the first
 result where function returns &lt;c&gt;Some(x)&lt;/c&gt; for some x. If no such
 element exists then raise &lt;c&gt;System.Collections.Generic.KeyNotFoundException&lt;/c&gt;
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Partition``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Boolean},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Split the collection into two collections, containing the 
 elements for which the given predicate returns &lt;c&gt;true&lt;/c&gt; and &lt;c&gt;false&lt;/c&gt;
 respectively 
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.OfSeq``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Build a new list from the given enumerable object
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.OfArray``1(``0[]`1)">
<summary>
 Build a list from the given array
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.CompatibleOfSeq``1(System.Collections.Generic.IEnumerable{``0})">

</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.CompatibleOfArray``1(``0[]`1)">

</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Get``1(Microsoft.FSharp.Collections.FSharpList{``0},System.Int32)">
<summary>
 Index into the list.  The first element has index 0.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.MinBy``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Return the lowest of all elements of the list, compared via Operators.min on the function result

 Raises &lt;c&gt;System.ArgumentException&lt;/c&gt; if &lt;c&gt;list&lt;/c&gt; is empty
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Min``1(Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Return the lowest of all elements of the list, compared via Operators.min

 Raises &lt;c&gt;System.ArgumentException&lt;/c&gt; if &lt;c&gt;list&lt;/c&gt; is empty
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.MaxBy``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Return the greatest of all elements of the list, compared via Operators.max on the function result

 Raises &lt;c&gt;System.ArgumentException&lt;/c&gt; if &lt;c&gt;list&lt;/c&gt; is empty
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Max``1(Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Return the greatest of all elements of the list, compared via Operators.max

 Raises &lt;c&gt;System.ArgumentException&lt;/c&gt; if &lt;c&gt;list&lt;/c&gt; is empty
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.MapIndexed2``3(Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,``2}}},Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``1})">
<summary>
 Like mapi, but mapping corresponding elements from two lists of equal length.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.MapIndexed``2(Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{``0,``1}},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Build a new collection whose elements are the results of applying the given function
 to each of the elements of the collection. The integer index passed to the
 function indicates the index (from 0) of element being transformed.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Map3``4(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,Microsoft.FSharp.Core.FSharpFunc`2{``2,``3}}},Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``1},Microsoft.FSharp.Collections.FSharpList{``2})">
<summary>
 Build a new collection whose elements are the results of applying the given function
 to the corresponding elements of the three collections simultaneously.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Map2``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,``2}},Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``1})">
<summary>
 Build a new collection whose elements are the results of applying the given function
 to the corresponding elements of the two collections pairwise.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Map``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Build a new collection whose elements are the results of applying the given function
 to each of the elements of the collection.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Length``1(Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Return the length of the list
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.IterateIndexed2``2(Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,Microsoft.FSharp.Core.Unit}}},Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``1})">
<summary>
 Apply the given function to two collections simultaneously. The
 collections must have identical size. The integer passed to the
 function indicates the index of element.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.IterateIndexed``1(Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.Unit}},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Apply the given function to each element of the collection. The integer passed to the
 function indicates the index of element.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Iterate2``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,Microsoft.FSharp.Core.Unit}},Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``1})">
<summary>
 Apply the given function to two collections simultaneously. The
 collections must have identical size.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Iterate``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Apply the given function to each element of the collection. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.IsEmpty``1(Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Return true if the list contains no elements, false otherwise
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Initialize``1(System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,``0})">
<summary>
 Create a list by calling the given generator on each index
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.CompatibleHead``1(Microsoft.FSharp.Collections.FSharpList{``0})">

</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Head``1(Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Return the first element of the list.

 Raises &lt;c&gt;System.ArgumentException&lt;/c&gt; if &lt;c&gt;list&lt;/c&gt; is empty
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.ForAll2``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,System.Boolean}},Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``1})">
<summary>
 Test if all corresponding elements of the collection satisfy the given predicate pairwise.

 The predicate is applied to matching elements in the two collections up to the lesser of the 
 two lengths of the collections. If any application returns false then the overall result is 
 false and no further elements are tested. Otherwise, if one collection is longer 
 than the other then the &lt;c&gt;System.ArgumentException&lt;/c&gt; exception is raised. 
 Otherwise, true is returned.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.ForAll``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Boolean},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Test if all elements of the collection satisfy the given predicate.

 The predicate is applied to the elements of the input list. If any application 
 returns false then the overall result is false and no further elements are tested. 
 Otherwise, true is returned.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.FoldBack2``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,Microsoft.FSharp.Core.FSharpFunc`2{``2,``2}}},Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``1},``2)">
<summary>
 Apply a function to corresponding elements of two collections, threading an accumulator argument
 through the computation. The collections must have identical sizes.
 If the input function is &lt;c&gt;f&lt;/c&gt; and the elements are &lt;c&gt;i0...iN&lt;/c&gt; and &lt;c&gt;j0...jN&lt;/c&gt;
 then computes &lt;c&gt;f i0 j0 (...(f iN jN s))&lt;/c&gt;.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.FoldBack``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,``1}},Microsoft.FSharp.Collections.FSharpList{``0},``1)">
<summary>
 Apply a function to each element of the collection, threading an accumulator argument
 through the computation. If the input function is &lt;c&gt;f&lt;/c&gt; and the elements are &lt;c&gt;i0...iN&lt;/c&gt; then 
 computes &lt;c&gt;f i0 (...(f iN s))&lt;/c&gt;.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Fold2``3(Microsoft.FSharp.Core.FSharpFunc`2{``2,Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,``2}}},``2,Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``1})">
<summary>
 Apply a function to corresponding elements of two collections, threading an accumulator argument
 through the computation. The collections must have identical sizes.
 If the input function is &lt;c&gt;f&lt;/c&gt; and the elements are &lt;c&gt;i0...iN&lt;/c&gt; and &lt;c&gt;j0...jN&lt;/c&gt;
 then computes &lt;c&gt;f (... (f s i0 j0)...) iN jN&lt;/c&gt;.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Fold``2(Microsoft.FSharp.Core.FSharpFunc`2{``1,Microsoft.FSharp.Core.FSharpFunc`2{``0,``1}},``1,Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Apply a function to each element of the collection, threading an accumulator argument
 through the computation. Take the second argument, and apply the function to it
 and the first element of the list.  Then feed this result into the function along
 with the second element and so on.  Return the final result.
 If the input function is &lt;c&gt;f&lt;/c&gt; and the elements are &lt;c&gt;i0...iN&lt;/c&gt; then 
 computes &lt;c&gt;f (... (f s i0) i1 ...) iN&lt;/c&gt;
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Filter``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Boolean},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Return a new collection containing only the elements of the collection
 for which the given predicate returns &quot;true&quot;
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.FindIndex``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Boolean},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Return the index of the first element in the list
 that satisfies the given predicate.
 Raise &lt;c&gt;KeyNotFoundException&lt;/c&gt; if no such element exists.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Find``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Boolean},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Return the first element for which the given function returns &lt;c&gt;true&lt;/c&gt;.
 Raise &lt;c&gt;KeyNotFoundException&lt;/c&gt; if no such element exists.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Exists2``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,System.Boolean}},Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``1})">
<summary>
 Test if any pair of corresponding elements of the lists satisfies the given predicate.

 The predicate is applied to matching elements in the two collections up to the lesser of the 
 two lengths of the collections. If any application returns true then the overall result is 
 true and no further elements are tested. Otherwise, if one collections is longer 
 than the other then the &lt;c&gt;System.ArgumentException&lt;/c&gt; exception is raised. 
 Otherwise, false is returned.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Exists``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Boolean},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Test if any element of the list satisfies the given predicate.

 The predicate is applied to the elements of the input list. If any application 
 returns true then the overall result is true and no further elements are tested. 
 Otherwise, false is returned.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Empty``1">
<summary>
 Return an empty list of the given type
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Concat``1(System.Collections.Generic.IEnumerable{Microsoft.FSharp.Collections.FSharpList{``0}})">
<summary>
 Return a new list that contains the elements of each the lists in order
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Collect``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Collections.FSharpList{``1}},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 For each element of the list, apply the given function. Concatenate all the results and return the combined list.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Choose``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpOption{``1}},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Apply the given function to each element of the list. Return
 the list comprised of the results &lt;c&gt;x&lt;/c&gt; for each element where
 the function returns Some(x)
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.AverageBy``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Return the average of the elements generated by applying the function to each element of the list.

 Raises &lt;c&gt;System.ArgumentException&lt;/c&gt; if &lt;c&gt;list&lt;/c&gt; is empty
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Average``1(Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Return the average of the elements in the list.

 Raises &lt;c&gt;System.ArgumentException&lt;/c&gt; if &lt;c&gt;list&lt;/c&gt; is empty
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ListModule.Append``1(Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Return a new list that contains the elements of the first list
 followed by elements of the second
</summary>
</member>
<member name="T:Microsoft.FSharp.Collections.ListModule">
<summary>
 Basic operations on lists.  
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.MapModule.TryFindIndex``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,System.Boolean}},Microsoft.FSharp.Collections.FSharpMap{``0,``1})">

</member>
<member name="M:Microsoft.FSharp.Collections.MapModule.FindIndex``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,System.Boolean}},Microsoft.FSharp.Collections.FSharpMap{``0,``1})">

</member>
<member name="M:Microsoft.FSharp.Collections.MapModule.Contains``2(``0,Microsoft.FSharp.Collections.FSharpMap{``0,``1})">

</member>
<member name="M:Microsoft.FSharp.Collections.MapModule.CompatibleToArray``2(Microsoft.FSharp.Collections.FSharpMap{``0,``1})">

</member>
<member name="M:Microsoft.FSharp.Collections.MapModule.CompatibleToList``2(Microsoft.FSharp.Collections.FSharpMap{``0,``1})">

</member>
<member name="M:Microsoft.FSharp.Collections.MapModule.CompatibleToSeq``2(Microsoft.FSharp.Collections.FSharpMap{``0,``1})">

</member>
<member name="M:Microsoft.FSharp.Collections.MapModule.CompatibleOfSeq``2(System.Collections.Generic.IEnumerable{System.Tuple`2{``0,``1}})">

</member>
<member name="M:Microsoft.FSharp.Collections.MapModule.CompatibleOfArray``2(System.Tuple`2{``0,``1}[]`1)">

</member>
<member name="M:Microsoft.FSharp.Collections.MapModule.CompatibleOfList``2(Microsoft.FSharp.Collections.FSharpList{System.Tuple`2{``0,``1}})">

</member>
<member name="M:Microsoft.FSharp.Collections.MapModule.TryFindKey``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,System.Boolean}},Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
<summary>
 Return the key of the first mapping in the collection that satisfies the given predicate. 
 Return &apos;None&apos; if no such element exists.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.MapModule.FindKey``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,System.Boolean}},Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
<summary>
 Evaluates the function on each mapping in the collection. Returns the key for the first mapping
 where the function returns &apos;true&apos;. Raise &lt;c&gt;KeyNotFoundException&lt;/c&gt; if no such element exists.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.MapModule.TryFind``2(``0,Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
<summary>
 Lookup an element in the map, returning a &lt;c&gt;Some&lt;/c&gt; value if the element is in the domain 
 of the map and &lt;c&gt;None&lt;/c&gt; if not.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.MapModule.Remove``2(``0,Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
<summary>
 Remove an element from the domain of the map.  No exception is raised if the element is not present.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.MapModule.Partition``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,System.Boolean}},Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
<summary>
 Build two new maps, one containing the bindings for which the given predicate returns &apos;true&apos;,
 and the other the remaining bindings.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.MapModule.ContainsKey``2(``0,Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
<summary>
 Test if an element is in the domain of the map
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.MapModule.Map``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,``2}},Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
<summary>
 Build a new collection whose elements are the results of applying the given function
 to each of the elements of the collection. The index passed to the
 function indicates the index of element being transformed.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.MapModule.ForAll``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,System.Boolean}},Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
<summary>
 Return true if the given predicate returns true for all of the
 bindings in the map.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.MapModule.Filter``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,System.Boolean}},Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
<summary>
 Build a new map containing only the bindings for which the given predicate returns &apos;true&apos;
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.MapModule.Exists``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,System.Boolean}},Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
<summary>
 Return true if the given predicate returns true for one of the
 bindings in the map.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.MapModule.Iterate``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,Microsoft.FSharp.Core.Unit}},Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
<summary>
 Apply the given function to each binding in the dictionary
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.MapModule.Fold``3(Microsoft.FSharp.Core.FSharpFunc`2{``2,Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,``2}}},``2,Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
<summary>
 Fold over the bindings in the map 
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.MapModule.FoldBack``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,Microsoft.FSharp.Core.FSharpFunc`2{``2,``2}}},Microsoft.FSharp.Collections.FSharpMap{``0,``1},``2)">
<summary>
 Fold over the bindings in the map 
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.MapModule.Pick``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,Microsoft.FSharp.Core.FSharpOption{``2}}},Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
<summary>
 Search the map looking for the first element where the given function returns a &lt;c&gt;Some&lt;/c&gt; value
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.MapModule.TryPick``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,Microsoft.FSharp.Core.FSharpOption{``2}}},Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
<summary>
 Search the map looking for the first element where the given function returns a &lt;c&gt;Some&lt;/c&gt; value
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.MapModule.Find``2(``0,Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
<summary>
 Lookup an element in the map, raising &lt;c&gt;KeyNotFoundException&lt;/c&gt; if no binding
 exists in the map.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.MapModule.Empty``2">
<summary>
 The empty map
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.MapModule.IsEmpty``2(Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
<summary>
 Is the map empty?
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.MapModule.ToArray``2(Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
<summary>
 Returns an array of all key-value pairs in the mapping
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.MapModule.ToList``2(Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
<summary>
 Returns a list of all key-value pairs in the mapping
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.MapModule.ToSeq``2(Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
<summary>
 View the collection as an enumerable sequence of pairs
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.MapModule.OfSeq``2(System.Collections.Generic.IEnumerable{System.Tuple`2{``0,``1}})">
<summary>
 Return a new map made from the given bindings
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.MapModule.OfArray``2(System.Tuple`2{``0,``1}[]`1)">
<summary>
 Return a new map made from the given bindings
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.MapModule.OfList``2(Microsoft.FSharp.Collections.FSharpList{System.Tuple`2{``0,``1}})">
<summary>
 Return a new map made from the given bindings
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.MapModule.Add``2(``0,``1,Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
<summary>
 Return a new map with the binding added to the given map.
</summary>
</member>
<member name="T:Microsoft.FSharp.Collections.MapModule">
<summary>
 Functional programming operators related to the &lt;c&gt;Map&lt;_,_&gt;&lt;/c&gt; type.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Zip3``3(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Collections.Generic.IEnumerable{``2})">
<summary>
 Combine the three sequences into a list of triples. The two sequences need not have equal lengths:
 when one sequence is exhausted any remaining elements in the other
 sequence are ignored.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Zip``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})">
<summary>
 Combine the two sequences into a list of pairs. The two sequences need not have equal lengths:
 when one sequence is exhausted any remaining elements in the other
 sequence are ignored.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Windowed``1(System.Int32,System.Collections.Generic.IEnumerable{``0})">
<summary>
 Return a sequence that yields &apos;sliding windows&apos; of containing elements drawn from the input
 sequence. Each window is returned as a fresh array.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Unfold``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpOption{System.Tuple`2{``1,``0}}},``0)">
<summary>
 Return a sequence that contains the elements generated by the given computation.
 The given initial &apos;state&apos; argument is passed to the element generator.
 For each IEnumerator elements in the stream are generated on-demand by applying the element
 generator, until a None value is returned by the element generator. Each call to the element
 generator returns a new residual &apos;state&apos;.

 Note the stream will be recomputed each time an IEnumerator is requested and iterated for the Seq.

 The returned sequence may be passed between threads safely. However, 
 individual IEnumerator values generated from the returned sequence should not be accessed concurrently.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Truncate``1(System.Int32,System.Collections.Generic.IEnumerable{``0})">
<summary>
 Return a sequence that when enumerated returns at most N elements.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.TryPick``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpOption{``1}},System.Collections.Generic.IEnumerable{``0})">
<summary>
 Apply the given function to successive elements, returning the first
 result where the function returns &quot;Some(x)&quot;.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.TryFindIndex``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Boolean},System.Collections.Generic.IEnumerable{``0})">
<summary>
 Return the index of the first element in the sequence 
 that satisfies the given predicate. Return &apos;None&apos; if no such element exists.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.TryFind``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Boolean},System.Collections.Generic.IEnumerable{``0})">
<summary>
 Return the first element for which the given function returns &lt;c&gt;true&lt;/c&gt;.
 Return &lt;c&gt;None&lt;/c&gt; if no such element exists.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.ToList``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Build a list from the given collection
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.ToArray``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Build an array from the given collection
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.CompatibleToList``1(System.Collections.Generic.IEnumerable{``0})">

</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.CompatibleToArray``1(System.Collections.Generic.IEnumerable{``0})">

</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.TakeWhile``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Boolean},System.Collections.Generic.IEnumerable{``0})">
<summary>
 Return a sequence that, when iterated, yields elements of the underlying sequence while the 
 given predicate returns &apos;true&apos;, and returns no further elements 
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Take``1(System.Int32,System.Collections.Generic.IEnumerable{``0})">
<summary>
 Return the first N elements of the sequence.  
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.SumBy``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},System.Collections.Generic.IEnumerable{``0})">
<summary>
 Return the sum of the results generated by applying the function to each element of the sequence.
 The generated elements are summed using the &apos;+&apos; operator and &apos;Zero&apos; property associated with the generated type.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Sum``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Return the sum of the elements in the sequence.

 The elements are summed using the &apos;+&apos; operator and &apos;Zero&apos; property associated with the generated type.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.SortBy``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},System.Collections.Generic.IEnumerable{``0})">
<summary>
 Apply a key-generating function to each element of a sequence and yield a sequence ordered
 by keys.  The keys are compared using generic comparison as implemented by &lt;c&gt;Operators.compare&lt;/c&gt;. 
 
 Note that this function returns a sequence that digests the whole initial sequence as soon as 
 that sequence is iterated. As a result this function should not be used with 
 large or infinite sequences. The function makes no assumption on the ordering of the original 
 sequence.

 This is a stable sort, i.e. the original order of equal elements is preserved.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Sort``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Yield a sequence ordered by keys.  
 
 Note that this function returns a sequence that digests the whole initial sequence as soon as 
 that sequence is iterated. As a result this function should not be used with 
 large or infinite sequences. The function makes no assumption on the ordering of the original 
 sequence.

 This is a stable sort, i.e. the original order of equal elements is preserved.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.SkipWhile``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Boolean},System.Collections.Generic.IEnumerable{``0})">
<summary>
 Return a sequence that, when iterated, skips elements of the underlying sequence while the 
 given predicate returns &apos;true&apos;, and then yields the remaining elements of the sequence
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Skip``1(System.Int32,System.Collections.Generic.IEnumerable{``0})">
<summary>
 Return a sequence that skips N elements of the underlying sequence and then yields the
 remaining elements of the sequence
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Singleton``1(``0)">
<summary>
 Return a sequence that yields one item only.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Scan``2(Microsoft.FSharp.Core.FSharpFunc`2{``1,Microsoft.FSharp.Core.FSharpFunc`2{``0,``1}},``1,System.Collections.Generic.IEnumerable{``0})">
<summary>
 Like fold, but compute on-demand and return the sequence of intermediary and final results
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Reduce``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``0,``0}},System.Collections.Generic.IEnumerable{``0})">
<summary>
 Apply a function to each element of the sequence, threading an accumulator argument
 through the computation. Begin by applying the function to the first two elements.
 Then feed this result into the function along with the third element and so on.  
 Return the final result.
 Raises ArgumentException if the sequence has no elements.    
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.ReadOnly``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Build a new sequence object that delegates to the given sequence object. This ensures 
 the original sequence can&apos;t be rediscovered and mutated by a type cast. For example, 
 if given an array the returned sequence will return the elements of the array, but
 you can&apos;t cast the returned sequence object to an array.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Pick``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpOption{``1}},System.Collections.Generic.IEnumerable{``0})">
<summary>
 Apply the given function to successive elements, returning the first
 &apos;x&apos; where the function returns &quot;Some(x)&quot;.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Pairwise``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Return a sequence of each element in the input sequence and its predecessor, with the
 exception of the first element which is only returned as the predecessor of the second element.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.CompatibleOfList``1(Microsoft.FSharp.Collections.FSharpList{``0})">

</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.CompatibleOfArray``1(``0[]`1)">

</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.OfList``1(Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 View the given list as a sequence
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.OfArray``1(``0[]`1)">
<summary>
 View the given array as a sequence
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Get``1(System.Int32,System.Collections.Generic.IEnumerable{``0})">
<summary>
 Compute the nth element in the collection.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.MinBy``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},System.Collections.Generic.IEnumerable{``0})">
<summary>
 Return the lowest of all elements of the sequence, compared via Operators.min on the function result

 Throws ArgumentException for empty sequence
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Min``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Return the lowest of all elements of the sequence, compared via Operators.min

 Throws ArgumentException for empty sequence
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.MaxBy``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},System.Collections.Generic.IEnumerable{``0})">
<summary>
 Return the greatest of all elements of the sequence, compared via Operators.max on the function result

 Throws ArgumentException for empty sequence
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Max``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Return the greatest of all elements of the sequence, compared via Operators.max

 Throws ArgumentException for empty sequence
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.MapIndexed``2(Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{``0,``1}},System.Collections.Generic.IEnumerable{``0})">
<summary>
 Build a new collection whose elements are the results of applying the given function
 to each of the elements of the collection. The integer index passed to the
 function indicates the index (from 0) of element being transformed.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Map2``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,``2}},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})">
<summary>
 Build a new collection whose elements are the results of applying the given function
 to the corresponding pairs of elements from the two sequences. If one input sequence is shorter than 
 the other then the remaining elements of the longer sequence are ignored.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Map``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},System.Collections.Generic.IEnumerable{``0})">
<summary>
 Build a new collection whose elements are the results of applying the given function
 to each of the elements of the collection.  The given function will be applied
 as elements are demanded using the &apos;MoveNext&apos; method on enumerators retrieved from the
 object.  

 The returned sequence may be passed between threads safely. However, 
 individual IEnumerator values generated from the returned sequence should not be accessed concurrently.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Length``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Return the length of the sequence
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Iterate2``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,Microsoft.FSharp.Core.Unit}},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})">
<summary>
 Apply the given function to two collections simultaneously. If one sequence is shorter than 
 the other then the remaining elements of the longer sequence are ignored.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.IterateIndexed``1(Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.Unit}},System.Collections.Generic.IEnumerable{``0})">
<summary>
 Apply the given function to each element of the collection. The integer passed to the
 function indicates the index of element.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Iterate``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.Unit},System.Collections.Generic.IEnumerable{``0})">
<summary>
 Apply the given function to each element of the collection. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.InitializeInfinite``1(Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,``0})">
<summary>
 Generate a new sequence which, when iterated, will return successive
 elements by calling the given function.  The results of calling the function
 will not be saved, i.e. the function will be reapplied as necessary to
 regenerate the elements.  The function is passed the index of the item being
 generated

 The returned sequence may be passed between threads safely. However, 
 individual IEnumerator values generated from the returned sequence should not be accessed concurrently.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Initialize``1(System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,``0})">
<summary>
 Generate a new sequence which, when iterated, will return successive
 elements by calling the given function, up to the given count.  The results of calling the function
 will not be saved, i.e. the function will be reapplied as necessary to
 regenerate the elements.  The function is passed the index of the item being
 generated.

 The returned sequence may be passed between threads safely. However, 
 individual IEnumerator values generated from the returned sequence should not be accessed concurrently.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.IsEmpty``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Return true if the sequence contains no elements, false otherwise
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Head``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Return the first element of the sequence.  
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.CompatibleHead``1(System.Collections.Generic.IEnumerable{``0})">

</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.GroupBy``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},System.Collections.Generic.IEnumerable{``0})">
<summary>
 Apply a key-generating function to each element of a sequence and yields a sequence of 
 unique keys. Each unique key has also contains a sequence of all elements that match 
 to this key. 
 
 Note that this function returns a sequence that digests the whole initial sequence as soon as 
 that sequence is iterated. As a result this function should not be used with 
 large or infinite sequences. The function makes no assumption on the ordering of the original 
 sequence.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.ForAll2``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,System.Boolean}},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})">
<summary>
 Test the all pairs of elements drawn from the two sequences satisfies the
 given predicate. If one sequence is shorter than 
 the other then the remaining elements of the longer sequence are ignored
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.ForAll``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Boolean},System.Collections.Generic.IEnumerable{``0})">
<summary>
 Test if all elements of the sequence satisfy the given predicate.

 The predicate is applied to the elements of the input sequence. If any application 
 returns false then the overall result is false and no further elements are tested. 
 Otherwise, true is returned.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Fold``2(Microsoft.FSharp.Core.FSharpFunc`2{``1,Microsoft.FSharp.Core.FSharpFunc`2{``0,``1}},``1,System.Collections.Generic.IEnumerable{``0})">
<summary>
 Apply a function to each element of the collection, threading an accumulator argument
 through the computation. If the input function is &lt;c&gt;f&lt;/c&gt; and the elements are &lt;c&gt;i0...iN&lt;/c&gt; 
 then computes &lt;c&gt;f (... (f s i0)...) iN&lt;/c&gt;
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.FindIndex``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Boolean},System.Collections.Generic.IEnumerable{``0})">
<summary>
 Return the index of the first element in the sequence of pairs
 that satisfies the given predicate. Raise &lt;c&gt;KeyNotFoundException&lt;/c&gt; if no such element exists.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Find``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Boolean},System.Collections.Generic.IEnumerable{``0})">
<summary>
 Return the first element for which the given function returns &lt;c&gt;true&lt;/c&gt;.
 Raise &lt;c&gt;KeyNotFoundException&lt;/c&gt; if no such element exists.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Filter``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Boolean},System.Collections.Generic.IEnumerable{``0})">
<summary>
 Return a new collection containing only the elements of the collection
 for which the given predicate returns &quot;true&quot;

 The returned sequence may be passed between threads safely. However, 
 individual IEnumerator values generated from the returned sequence should not be accessed concurrently.

 Remember sequence is lazy, effects are delayed until it is enumerated.      
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Exists2``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,System.Boolean}},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})">
<summary>
 Test if any pair of corresponding elements of the input sequences satisfies the given predicate.

 The predicate is applied to matching elements in the two sequences up to the lesser of the 
 two lengths of the collections. If any application returns true then the overall result is 
 true and no further elements are tested. Otherwise, false is returned. If one sequence is shorter than 
 the other then the remaining elements of the longer sequence are ignored.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Exists``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Boolean},System.Collections.Generic.IEnumerable{``0})">
<summary>
 Test if any element of the sequence satisfies the given predicate.

 The predicate is applied to the elements of the input sequence. If any application 
 returns true then the overall result is true and no further elements are tested. 
 Otherwise, false is returned.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Empty``1">
<summary>
 Create an empty sequence 
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.DistinctBy``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},System.Collections.Generic.IEnumerable{``0})">
<summary>
 Return a sequence that contains no duplicate entries according to the 
 generic hash and equality comparisons on the keys returned by the given key-generating function.
 If an element occurs multiple times in the sequence then the later occurrences are discarded.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Distinct``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Return a sequence that contains no duplicate entries according to generic hash and equality comparisons on the entries.
 If an element occurs multiple times in the sequence then the later occurrences are discarded.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Delay``1(Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.Unit,System.Collections.Generic.IEnumerable{``0}})">
<summary>
 Return a sequence that is built from the given delayed specification of an
 Seq. The input function is evaluated each time an IEnumerator for the sequence 
 is requested.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.CountBy``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},System.Collections.Generic.IEnumerable{``0})">
<summary>
 Apply a key-generating function to each element of a sequence and return a sequence yielding unique
 keys and their number of occurences in the original sequence.  
 
 Note that this function returns a sequence that digests the whole initial sequence as soon as 
 that sequence is iterated. As a result this function should not be used with 
 large or infinite sequences. The function makes no assumption on the ordering of the original 
 sequence.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Concat``2(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Wrap the given enumeration-of-enumerations as a single concatenated
 enumeration.

 The returned sequence may be passed between threads safely. However, 
 individual IEnumerator values generated from the returned sequence should not be accessed concurrently.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.CompareWith``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Int32}},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
<summary>
 Compare two sequence&apos;s using the given comparison function, element by element.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Compare``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Int32}},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
<summary>
 Compare two sequence&apos;s using generic comparison, element by element.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Collect``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},System.Collections.Generic.IEnumerable{``0})">
<summary>
 For each element of the enumeration apply the given function and concatenate all the results.

 Remember sequence is lazy, effects are delayed until it is enumerated.    
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Choose``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpOption{``1}},System.Collections.Generic.IEnumerable{``0})">
<summary>
 Apply the given function to each element of the list. Return
 the list comprised of the results &quot;x&quot; for each element where
 the function returns Some(x)

 The returned sequence may be passed between threads safely. However, 
 individual IEnumerator values generated from the returned sequence should not be accessed concurrently.

 Remember sequence is lazy, effects are delayed until it is enumerated.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Cast``1(System.Collections.IEnumerable)">
<summary>
 Wrap a loosely-typed System.Collections sequence as a typed sequence.

 The use of this function usually requires a type annotation.
 An incorrect type annotation may result in runtime type
 errors.

 Individual IEnumerator values generated from the returned sequence should not be accessed concurrently.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Cache``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Return a sequence that corresponds to a cached version of the input sequence.
 This result sequence will have the same elements as the input sequence. The result 
 can be enumerated multiple times. The input sequence will be enumerated at most 
 once and only as far as is necessary.

 Enumeration of the result sequence is thread safe in the sense that multiple independent IEnumerator
 values may be used simultaneously from different threads (accesses to 
 the internal lookaside table are thread safe). Each individual IEnumerator
 is not typically thread safe and should not be accessed concurrently.

 Note, once enumeration of the input sequence has started,
 it&apos;s enumerator will be kept live by this object until the enumeration has completed.
 At that point, the enumerator will be disposed. 

 The enumerator may be disposed and underlying cache storage released by 
 converting the returned sequence object to type IDisposable, and calling the Dispose method
 on this object. The sequence object may then be re-enumerated and a fresh enumerator will
 be used.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.AverageBy``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},System.Collections.Generic.IEnumerable{``0})">
<summary>
 Return the average of the results generated by applying the function to each element of the sequence.

 The elements are averaged using the &apos;+&apos; operator, &apos;DivideByInt&apos; method and &apos;Zero&apos; property 
 associated with the generated type.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Average``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Return the average of the elements in the sequence

 The elements are averaged using the &apos;+&apos; operator, &apos;DivideByInt&apos; method and &apos;Zero&apos; property 
 associated with the element type.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.SeqModule.Append``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
<summary>
 Wrap the two given enumeration-of-enumerations as a single concatenated
 enumeration.

 The returned sequence may be passed between threads safely. However, 
 individual IEnumerator values generated from the returned sequence should not be accessed concurrently.
</summary>
</member>
<member name="T:Microsoft.FSharp.Collections.SeqModule">
<summary>
 Basic operations on IEnumerables.  
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.Diff``1(Microsoft.FSharp.Collections.FSharpSet{``0},Microsoft.FSharp.Collections.FSharpSet{``0})">

</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.Subset``1(Microsoft.FSharp.Collections.FSharpSet{``0},Microsoft.FSharp.Collections.FSharpSet{``0})">

</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.Mem``1(``0,Microsoft.FSharp.Collections.FSharpSet{``0})">

</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.CompatibleOfSeq``1(System.Collections.Generic.IEnumerable{``0})">

</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.CompatibleToSeq``1(Microsoft.FSharp.Collections.FSharpSet{``0})">

</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.CompatibleToArray``1(Microsoft.FSharp.Collections.FSharpSet{``0})">

</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.CompatibleOfArray``1(``0[]`1)">

</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.CompatibleToList``1(Microsoft.FSharp.Collections.FSharpSet{``0})">

</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.CompatibleOfList``1(Microsoft.FSharp.Collections.FSharpList{``0})">

</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.Difference``1(Microsoft.FSharp.Collections.FSharpSet{``0},Microsoft.FSharp.Collections.FSharpSet{``0})">
<summary>
 Return a new set with the elements of the second set removed from the first.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.OfSeq``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Build a new collection from the given enumerable object
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.ToSeq``1(Microsoft.FSharp.Collections.FSharpSet{``0})">
<summary>
 Return a view of the collection as an enumerable object
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.ToArray``1(Microsoft.FSharp.Collections.FSharpSet{``0})">
<summary>
 Build an array that contains the elements of the set in order
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.OfArray``1(``0[]`1)">
<summary>
 Build a set that contains the same elements as the given array
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.ToList``1(Microsoft.FSharp.Collections.FSharpSet{``0})">
<summary>
 Build a list that contains the elements of the set in order
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.OfList``1(Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Build a set that contains the same elements as the given list
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.MaxElement``1(Microsoft.FSharp.Collections.FSharpSet{``0})">
<summary>
 Returns the highest element in the set according to the ordering being used for the set
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.MinElement``1(Microsoft.FSharp.Collections.FSharpSet{``0})">
<summary>
 Returns the lowest element in the set according to the ordering being used for the set
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.Remove``1(``0,Microsoft.FSharp.Collections.FSharpSet{``0})">
<summary>
Return a new set with the given element removed.  No exception is raised in 
the set doesn&apos;t contain the given element.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.Partition``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Boolean},Microsoft.FSharp.Collections.FSharpSet{``0})">
<summary>
Split the set into two sets containing the elements for which the given predicate
returns true and false respectively
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.Iterate``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Collections.FSharpSet{``0})">
<summary>
Apply the given function to each element of the set, in order according
to the comparison function
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.IsEmpty``1(Microsoft.FSharp.Collections.FSharpSet{``0})">
<summary>
Return &quot;true&quot; if the set is empty
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.UnionMany``1(System.Collections.Generic.IEnumerable{Microsoft.FSharp.Collections.FSharpSet{``0}})">
<summary>
Compute the union of a sequence of sets.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.Union``1(Microsoft.FSharp.Collections.FSharpSet{``0},Microsoft.FSharp.Collections.FSharpSet{``0})">
<summary>
Compute the union of the two sets.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.IntersectMany``1(System.Collections.Generic.IEnumerable{Microsoft.FSharp.Collections.FSharpSet{``0}})">
<summary>
Compute the intersection of a sequence of sets. The sequence must be non-empty
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.Intersect``1(Microsoft.FSharp.Collections.FSharpSet{``0},Microsoft.FSharp.Collections.FSharpSet{``0})">
<summary>
 Compute the intersection of the two sets.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.ForAll``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Boolean},Microsoft.FSharp.Collections.FSharpSet{``0})">
<summary>
 Test if all elements of the collection satisfy the given predicate.
 If the input function is &lt;c&gt;f&lt;/c&gt; and the elements are &lt;c&gt;i0...iN&lt;/c&gt; and &quot;j0...jN&quot;
 then computes &lt;c&gt;p i0 &amp;&amp; ... &amp;&amp; p iN&lt;/c&gt;.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.FoldBack``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,``1}},Microsoft.FSharp.Collections.FSharpSet{``0},``1)">
<summary>
 Apply the given accumulating function to all the elements of the set
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.Fold``2(Microsoft.FSharp.Core.FSharpFunc`2{``1,Microsoft.FSharp.Core.FSharpFunc`2{``0,``1}},``1,Microsoft.FSharp.Collections.FSharpSet{``0})">
<summary>
 Apply the given accumulating function to all the elements of the set
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.Map``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},Microsoft.FSharp.Collections.FSharpSet{``0})">
<summary>
 Return a new collection containing the results of applying the
 given function to each element of the input set
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.Filter``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Boolean},Microsoft.FSharp.Collections.FSharpSet{``0})">
<summary>
 Return a new collection containing only the elements of the collection
 for which the given predicate returns &lt;c&gt;true&lt;/c&gt;
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.Exists``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Boolean},Microsoft.FSharp.Collections.FSharpSet{``0})">
<summary>
Test if any element of the collection satisfies the given predicate.
If the input function is &lt;c&gt;f&lt;/c&gt; and the elements are &lt;c&gt;i0...iN&lt;/c&gt; 
then computes &lt;c&gt;p i0 or ... or p iN&lt;/c&gt;.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.Count``1(Microsoft.FSharp.Collections.FSharpSet{``0})">
<summary>
Return the number of elements in the set.  Same as &lt;c&gt;size&lt;/c&gt;
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.IsProperSuperset``1(Microsoft.FSharp.Collections.FSharpSet{``0},Microsoft.FSharp.Collections.FSharpSet{``0})">
<summary>
 Evaluates to &quot;true&quot; if all elements of the second set are in the first, and at least 
 one element of the first is not in the second
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.IsSuperset``1(Microsoft.FSharp.Collections.FSharpSet{``0},Microsoft.FSharp.Collections.FSharpSet{``0})">
<summary>
 Evaluates to &quot;true&quot; if all elements of the second set are in the first
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.IsProperSubset``1(Microsoft.FSharp.Collections.FSharpSet{``0},Microsoft.FSharp.Collections.FSharpSet{``0})">
<summary>
 Evaluates to &quot;true&quot; if all elements of the first set are in the second, and at least 
 one element of the second is not in the first
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.IsSubset``1(Microsoft.FSharp.Collections.FSharpSet{``0},Microsoft.FSharp.Collections.FSharpSet{``0})">
<summary>
 Evaluates to &quot;true&quot; if all elements of the first set are in the second
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.Contains``1(``0,Microsoft.FSharp.Collections.FSharpSet{``0})">
<summary>
Evaluates to &quot;true&quot; if the given element is in the given set
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.Add``1(``0,Microsoft.FSharp.Collections.FSharpSet{``0})">
<summary>
 Return a new set with an element added to the set.  No exception is raised if
 the set already contains the given element.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.Singleton``1(``0)">
<summary>
 The set containing the given one element.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.SetModule.Empty``1">
<summary>
 The empty set for the type &apos;T .
</summary>
</member>
<member name="T:Microsoft.FSharp.Collections.SetModule">
<summary>
 Functional programming operators related to the &lt;c&gt;Set&lt;_&gt;&lt;/c&gt; type.
</summary>
</member>
<member name="P:Microsoft.FSharp.Control.FSharpAsync.DefaultGroup">

</member>
<member name="P:Microsoft.FSharp.Control.FSharpAsync.DefaultCancellationToken">
<summary>
 Get the default cancellation token for executing asynchronous computations
</summary>
</member>
<member name="P:Microsoft.FSharp.Control.FSharpAsync.CancellationToken">
<summary>
 Return an asynchronous computation that, when run, returns the CancellationToken governing the execution 
 of the computation expression.
 In &lt;c&gt;async { let! token = Async.CancellationToken ...}&lt;/c&gt; token can be used to initiate other 
 asynchronous operations that will cancel cooperatively with this workflow.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsync.TryCancelled``1(Microsoft.FSharp.Control.FSharpAsync{``0},Microsoft.FSharp.Core.FSharpFunc`2{System.OperationCanceledException,Microsoft.FSharp.Core.Unit})">
<summary>
 Return an asynchronous computation that, when run, executes &lt;c&gt;computation&lt;/c&gt;,
 If this computation is cancelled before it completes then the computation generated by 
 running &lt;c&gt;compensation&lt;/c&gt; is executed. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsync.SwitchToThreadPool">
<summary>
 Return an asynchronous computation that, when run, queues a work item that runs
 its continutation.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsync.SwitchToNewThread">
<summary>
 Return an asynchronous computation that, when run, creates a new thread and runs
 its continutation in that thread
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsync.SwitchToGuiThread(System.Threading.SynchronizationContext)">

</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsync.SwitchToContext(System.Threading.SynchronizationContext)">
<summary>
 Return an asynchronous computation that, when run, runs
 its continuation using syncContext.Post. If syncContext is null 
 then the asynchronous computation is equivalent to SwitchToThreadPool().
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsync.StartWithContinuations``1(Microsoft.FSharp.Control.FSharpAsync{``0},Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc`2{System.Exception,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc`2{System.OperationCanceledException,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpOption{System.Threading.CancellationToken})">
<summary>
 Run an asynchronous computation, starting immediately on the current operating system
 thread. Call one of the three continuations when the operation completes.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsync.StartImmediate(Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpOption{System.Threading.CancellationToken})">
<summary>
 Run an asynchronous computation, starting immediately on the current operating system
 thread.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsync.StartChild``1(Microsoft.FSharp.Control.FSharpAsync{``0},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
<summary>
 Start a child computation within an asynchronous workflow. 
 This allows multiple asynchronous computations to be executed simultaneously.
 
 This method should normally be used as the immediate 
 right-hand-side of a &apos;let!&apos; binding in an F# asynchronous workflow, i.e.,
 
        async { ...
                let! completor1 = childComputation1 |&gt; Async.StartChild  
                let! completor2 = childComputation2 |&gt; Async.StartChild  
                ... 
                let! result1 = completor1 
                let! result2 = completor2 
                ... }
 
 When used in this way, each use of &lt;c&gt;StartChild&lt;/c&gt; starts an instance of &lt;c&gt;childComputation&lt;/c&gt; 
 and returns a completor object representing a computation to wait for the completion of the operation.
 When executed, the completor awaits the completion of &lt;c&gt;childComputation&lt;/c&gt;. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsync.Start(Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpOption{System.Threading.CancellationToken})">
<summary>
 Start the asynchronous computation in the thread pool. Do not await its result.

 If no cancellation token is provided then the default cancellation token is used.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsync.SpawnThenPostBack``1(Microsoft.FSharp.Control.FSharpAsync{``0},Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.Unit})">

</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsync.SpawnChild(Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.Unit})">

</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsync.Spawn(Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.Unit})">

</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsync.Sleep(System.Int32)">
<summary>
 Return an asynchronous computation that will sleep for the given time. This is scheduled
 using a System.Threading.Timer object. The operation will not block operating system threads
 for the duration of the wait.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsync.RunWithContinuations``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc`2{System.Exception,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc`2{System.OperationCanceledException,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Control.FSharpAsync{``0})">

</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsync.RunSynchronously``1(Microsoft.FSharp.Control.FSharpAsync{``0},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Threading.CancellationToken})">
<summary>
 Run the asynchronous computation and await its result.

 If an exception occurs in the asynchronous computation then an exception is re-raised by this
 function.
        
 If no cancellation token is provided then the default cancellation token is used.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsync.Run``1(Microsoft.FSharp.Control.FSharpAsync{``0},Microsoft.FSharp.Core.FSharpOption{System.Int32})">

</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsync.Primitive``1(Microsoft.FSharp.Core.FSharpFunc`2{System.Tuple`2{Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc`2{System.Exception,Microsoft.FSharp.Core.Unit}},Microsoft.FSharp.Core.Unit})">

</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsync.Primitive``1(Microsoft.FSharp.Core.FSharpFunc`2{System.Tuple`3{Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc`2{System.Exception,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc`2{System.OperationCanceledException,Microsoft.FSharp.Core.Unit}},Microsoft.FSharp.Core.Unit})">

</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsync.Parallel``1(System.Collections.Generic.IEnumerable{Microsoft.FSharp.Control.FSharpAsync{``0}})">
<summary>
 Return an asynchronous computation that, when run, executes all the given asynchronous computations, 
 initially queueing each as work items and using a fork/join pattern.

 If all child computations succeed, an array of results is passed to the success continuation.
 
 If any child computation raises an exception, then the overall computation will trigger an 
 exception, and cancel the others. 

 The overall computation will respond to cancellation while executing the child computations.
 If cancelled, the computation will cancel any remaining child computations but will still wait
 for the other child computations to complete.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsync.OnCancel(Microsoft.FSharp.Core.FSharpFunc`2{System.String,Microsoft.FSharp.Core.Unit})">
<summary>
 Generate a scoped, cooperative cancellation handler for use within an asynchronous workflow. 

 For example,
     &lt;c&gt;async { use! holder = Async.OnCancel interruption ... }&lt;/c&gt; 
 generates an asynchronous computation where, if a cancellation happens any time during 
 the execution of the asynchronous computation in the scope of &apos;holder&apos;, then action 
 &apos;interruption&apos; is executed on the thread that is performing the cancellation. This can 
 be used to arrange for a computation to be asynchronously notified that a cancellation 
 has occurred, e.g. by setting a flag, or deregistering a pending I/O action.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsync.Ignore``1(Microsoft.FSharp.Control.FSharpAsync{``0})">
<summary>
 Return an asynchronous computation that, when run, runs the given computation and ignores 
 its result.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsync.FromContinuations``1(Microsoft.FSharp.Core.FSharpFunc`2{System.Tuple`3{Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc`2{System.Exception,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc`2{System.OperationCanceledException,Microsoft.FSharp.Core.Unit}},Microsoft.FSharp.Core.Unit})">
<summary>
 Return an asynchronous computation that, when run, captures the current
 success, exception and cancellation continuations. The callback must 
 eventually call one of the given continuations. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsync.FromBeginEnd``4(``0,``1,``2,Microsoft.FSharp.Core.FSharpFunc`2{System.Tuple`5{``0,``1,``2,System.AsyncCallback,System.Object},System.IAsyncResult},Microsoft.FSharp.Core.FSharpFunc`2{System.IAsyncResult,``3},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit}})">
<summary>
 Return an asynchronous computation in terms of a Begin/End pair of actions in 
 the style used in CLI APIs. This overlaod should be used if the operation is 
 qualified by three arguments. For example, 
     &lt;c&gt;Async.FromBeginEnd(arg1,arg2,arg3,ws.BeginGetWeather,ws.EndGetWeather)&lt;/c&gt;
 When the computation is run, &apos;beginFunc&apos; is executed, with
 a callback which represents the continuation of the computation. 
 When the callback is invoked, the overall result is fetched using &apos;endFunc&apos;.

 The computation will respond to cancellation while waiting for the completion
 of the operation. If a cancellation occurs, and &apos;cancelAction&apos; is specified, then it is 
 executed, and the computation continues to wait for the completion of the operation.
 
 If &apos;cancelAction&apos; is not specified, then cancellation causes the computation
 to stop immediately, and subsequent invocations of the callback are ignored.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsync.FromBeginEnd``3(``0,``1,Microsoft.FSharp.Core.FSharpFunc`2{System.Tuple`4{``0,``1,System.AsyncCallback,System.Object},System.IAsyncResult},Microsoft.FSharp.Core.FSharpFunc`2{System.IAsyncResult,``2},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit}})">
<summary>
 Return an asynchronous computation in terms of a Begin/End pair of actions in 
 the style used in CLI APIs. This overlaod should be used if the operation is 
 qualified by two arguments. For example, 
     &lt;c&gt;Async.FromBeginEnd(arg1,arg2,ws.BeginGetWeather,ws.EndGetWeather)&lt;/c&gt;
 When the computation is run, &apos;beginFunc&apos; is executed, with
 a callback which represents the continuation of the computation. 
 When the callback is invoked, the overall result is fetched using &apos;endFunc&apos;.

 The computation will respond to cancellation while waiting for the completion
 of the operation. If a cancellation occurs, and &apos;cancelAction&apos; is specified, then it is 
 executed, and the computation continues to wait for the completion of the operation.
 
 If &apos;cancelAction&apos; is not specified, then cancellation causes the computation
 to stop immediately, and subsequent invocations of the callback are ignored.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsync.FromBeginEnd``2(``0,Microsoft.FSharp.Core.FSharpFunc`2{System.Tuple`3{``0,System.AsyncCallback,System.Object},System.IAsyncResult},Microsoft.FSharp.Core.FSharpFunc`2{System.IAsyncResult,``1},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit}})">
<summary>
 Return an asynchronous computation in terms of a Begin/End pair of actions in 
 the style used in CLI APIs. This overlaod should be used if the operation is 
 qualified by one argument. For example, 
     &lt;c&gt;Async.FromBeginEnd(place,ws.BeginGetWeather,ws.EndGetWeather)&lt;/c&gt;
 When the computation is run, &apos;beginFunc&apos; is executed, with
 a callback which represents the continuation of the computation. 
 When the callback is invoked, the overall result is fetched using &apos;endFunc&apos;.

 The computation will respond to cancellation while waiting for the completion
 of the operation. If a cancellation occurs, and &apos;cancelAction&apos; is specified, then it is 
 executed, and the computation continues to wait for the completion of the operation.
 
 If &apos;cancelAction&apos; is not specified, then cancellation causes the computation
 to stop immediately, and subsequent invocations of the callback are ignored.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsync.FromBeginEnd``1(Microsoft.FSharp.Core.FSharpFunc`2{System.Tuple`2{System.AsyncCallback,System.Object},System.IAsyncResult},Microsoft.FSharp.Core.FSharpFunc`2{System.IAsyncResult,``0},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit}})">
<summary>
 Return an asynchronous computation in terms of a Begin/End pair of actions in 
 the style used in CLI APIs. For example, 
     &lt;c&gt;Async.FromBeginEnd(ws.BeginGetWeather,ws.EndGetWeather)&lt;/c&gt;
 When the computation is run, &apos;beginFunc&apos; is executed, with
 a callback which represents the continuation of the computation. 
 When the callback is invoked, the overall result is fetched using &apos;endFunc&apos;.

 The computation will respond to cancellation while waiting for the completion
 of the operation. If a cancellation occurs, and &apos;cancelAction&apos; is specified, then it is 
 executed, and the computation continues to wait for the completion of the operation.
 
 If &apos;cancelAction&apos; is not specified, then cancellation causes the computation
 to stop immediately, and subsequent invocations of the callback are ignored.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsync.Catch``1(Microsoft.FSharp.Control.FSharpAsync{``0})">
<summary>
 Return an asynchronous computation that, when run, executes &lt;c&gt;computation&lt;/c&gt;,
 If this computation completes successfully then return &lt;c&gt;Choice1Of2&lt;/c&gt; with the returned
 value. If this computation raises an exception before it completes then return &lt;c&gt;Choice2Of2&lt;/c&gt;
 with the raised exception.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsync.CancelDefaultToken">
<summary>
 Raise the cancellation condition for the most recent set of asynchronous computations started 
 without any specific CancellationToken. Replace the global CancellationTokenSource with a new 
 global token source for any asynchronous computations created after this point without any 
 specific CancellationToken.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsync.CancelDefaultGroup(Microsoft.FSharp.Core.FSharpOption{System.String})">

</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsync.CancelCheck">

</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsync.BuildPrimitive``4(``0,``1,``2,Microsoft.FSharp.Core.FSharpFunc`2{System.Tuple`5{``0,``1,``2,System.AsyncCallback,System.Object},System.IAsyncResult},Microsoft.FSharp.Core.FSharpFunc`2{System.IAsyncResult,``3},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit}})">

</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsync.BuildPrimitive``3(``0,``1,Microsoft.FSharp.Core.FSharpFunc`2{System.Tuple`4{``0,``1,System.AsyncCallback,System.Object},System.IAsyncResult},Microsoft.FSharp.Core.FSharpFunc`2{System.IAsyncResult,``2},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit}})">

</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsync.BuildPrimitive``2(``0,Microsoft.FSharp.Core.FSharpFunc`2{System.Tuple`3{``0,System.AsyncCallback,System.Object},System.IAsyncResult},Microsoft.FSharp.Core.FSharpFunc`2{System.IAsyncResult,``1},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit}})">

</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsync.BuildPrimitive``1(Microsoft.FSharp.Core.FSharpFunc`2{System.Tuple`2{System.AsyncCallback,System.Object},System.IAsyncResult},Microsoft.FSharp.Core.FSharpFunc`2{System.IAsyncResult,``0},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit}})">

</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsync.AwaitWaitHandle(System.Threading.WaitHandle,Microsoft.FSharp.Core.FSharpOption{System.Int32})">
<summary>
 Return an asynchronous computation that will wait on the given WaitHandle.

 The computation returns true if the handle indicated a result within the given timeout. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsync.AwaitIAsyncResult(System.IAsyncResult,Microsoft.FSharp.Core.FSharpOption{System.Int32})">
<summary>
 Return an asynchronous computation that will wait on the IAsyncResult.

 The computation returns true if the handle indicated a result within the given timeout. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsync.AwaitEvent``2(Microsoft.FSharp.Control.IEvent{``0,``1},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit}})">
<summary>
 Return an asynchronous computation that waits for a single invocation of a CLI 
 event by adding a handler to the event. Once the computation completes or is 
 cancelled, the handler is removed from the event.

 The computation will respond to cancellation while waiting for the event. If a 
 cancellation occurs, and &apos;cancelAction&apos; is specified, then it is executed, and 
 the computation continues to wait for the event.
 
 If &apos;cancelAction&apos; is not specified, then cancellation causes the computation
 to cancel immediately. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsync.AsBeginEnd``1(Microsoft.FSharp.Control.FSharpAsync{``0})">
<summary>
 Return three functions that can be used to implement the .NET Asynchronous 
 Programming Model (APM) for a given asynchronous computation.
 
 The functions should normally be published as members with prefix &apos;Begin&apos;,
 &apos;End&apos; and &apos;Cancel&apos;, and can be used within a type definition as follows:
 &lt;c&gt;
   let beginAction,endAction,cancelAction = Async.AsBeginEnd computation
   member x.BeginSomeOperation(callback,state) = beginAction(callback,state)
   member x.EndSomeOperation(iar) = endAction(iar)
   member x.CancelSomeOperation(iar) = cancelAction(iar)
 &lt;/c&gt;

 The resulting API will be familiar to programmers in other CLI languages and 
 is a useful way to publish asynchronous computations in CLI components.
</summary>
</member>
<member name="T:Microsoft.FSharp.Control.FSharpAsync">
<summary>
 This static class holds members for creating and manipulating asynchronous computations
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsyncBuilder.Zero">
<summary>
 Return an asynchronous computation that, when run, just returns &apos;()&apos;

 A cancellation check is performed when the computation is executed.

 This existence of this method permits the use of empty &apos;else&apos; branches in the 
 &apos;async { ... }&apos; computation expression syntax.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsyncBuilder.While(Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.Unit,System.Boolean},Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.Unit})">
<summary>
 Return an asynchronous computation that, when run, runs &apos;p&apos; repeatedly 
 until &apos;gd()&apos; becomes false.

 A cancellation check is performed when the computation is executed.

 This existence of this method permits the use of &apos;while&apos; in the 
 &apos;async { ... }&apos; computation expression syntax.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsyncBuilder.Using``2(``0,Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Control.FSharpAsync{``1}})">
<summary>
 Return an asynchronous computation that, when run, runs &apos;f(resource)&apos;. 
 The action &apos;resource.Dispose()&apos; is executed as this computation yields its result
 or if the asynchronous computation exits by an exception or by cancellation.

 A cancellation check is performed when the computation is executed.

 This existence of this method permits the use of &apos;use&apos; and &apos;use!&apos; in the 
 &apos;async { ... }&apos; computation expression syntax.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsyncBuilder.TryWith``1(Microsoft.FSharp.Control.FSharpAsync{``0},Microsoft.FSharp.Core.FSharpFunc`2{System.Exception,Microsoft.FSharp.Control.FSharpAsync{``0}})">
<summary>
 Return an asynchronous computation that, when run, runs &apos;p&apos; and returns its result.
 If an exception happens then &apos;f(exn)&apos; is called and the resulting computation executed instead.

 A cancellation check is performed when the computation is executed.

 This existence of this method permits the use of &apos;try/with&apos; in the 
 &apos;async { ... }&apos; computation expression syntax.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsyncBuilder.TryFinally``1(Microsoft.FSharp.Control.FSharpAsync{``0},Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
<summary>
 Return an asynchronous computation that, when run, runs &apos;p&apos;. The action &apos;f&apos; is executed 
 after &apos;p&apos; completes, whether &apos;p&apos; exits normally or by an exception. If &apos;f&apos; raises an exception itself
 the original exception is discarded and the new exception becomes the overall result of the computation.

 A cancellation check is performed when the computation is executed.

 This existence of this method permits the use of &apos;try/finally&apos; in the 
 &apos;async { ... }&apos; computation expression syntax.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsyncBuilder.ReturnFrom``1(Microsoft.FSharp.Control.FSharpAsync{``0})">
<summary>
 Delegate to the input computation

 This existence of this method permits the use of &apos;return!&apos; in the 
 &apos;async { ... }&apos; computation expression syntax.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsyncBuilder.Return``1(``0)">
<summary>
 Return an asynchronous computation that, when run, returns the result &apos;v&apos;

 A cancellation check is performed when the computation is executed.

 This existence of this method permits the use of &apos;return&apos; in the 
 &apos;async { ... }&apos; computation expression syntax.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsyncBuilder.For``1(System.Collections.Generic.IEnumerable{``0},Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.Unit}})">
<summary>
 Return an asynchronous computation that, when run, enumerates the sequence &apos;seq&apos;
 on demand and runs &apos;f&apos; for each element.

 A cancellation check is performed on each iteration of the loop.

 This existence of this method permits the use of &apos;for&apos; in the 
 &apos;async { ... }&apos; computation expression syntax.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsyncBuilder.Delay``1(Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Control.FSharpAsync{``0}})">
<summary>
 Return an asynchronous computation that, when run, runs &apos;f()&apos;

 A cancellation check is performed when the computation is executed.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsyncBuilder.Combine``1(Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Control.FSharpAsync{``0})">
<summary>
 Return an asynchronous computation that, when run, first runs &apos;p1&apos; and then runs &apos;p2&apos;, returning the result of &apos;p2&apos;.

 A cancellation check is performed when the computation is executed.

 This existence of this method permits the use of expression sequencing in the 
 &apos;async { ... }&apos; computation expression syntax.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsyncBuilder.Bind``2(Microsoft.FSharp.Control.FSharpAsync{``0},Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Control.FSharpAsync{``1}})">
<summary>
 Return an asynchronous computation that, when run, runs &apos;p&apos;, and when 
 &apos;p&apos; generates a result &apos;T&apos;, runs &apos;f res&apos;.

 A cancellation check is performed when the computation is executed.

 This existence of this method permits the use of &apos;let!&apos; in the 
 &apos;async { ... }&apos; computation expression syntax.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsyncBuilder..ctor">
<summary>
 Generate an object used to build asynchronous computations using F# computation expressions. The value
 &apos;async&apos; is a pre-defined instance of this type.

 A cancellation check is performed when the computation is executed.
</summary>
</member>
<member name="T:Microsoft.FSharp.Control.FSharpAsyncBuilder">
<summary>
 The type of the &apos;async&apos; operator, used to build workflows for asynchronous computations.
</summary>
</member>
<member name="T:Microsoft.FSharp.Control.AsyncGroup">

</member>
<member name="M:Microsoft.FSharp.Control.FSharpAsyncReplyChannel`1.Reply(`0)">
<summary>
 Send a reply to a PostAndReply message
</summary>
</member>
<member name="T:Microsoft.FSharp.Control.FSharpAsyncReplyChannel`1">
<summary>
 A handle to a capability to reply to a PostAndReply message
</summary>
</member>
<member name="T:Microsoft.FSharp.Control.FSharpAsync`1">
<summary>
 A compositional asynchronous computation, which, when run, will eventually produce a value 
 of type T, or else raises an exception. 

 Asynchronous computations are normally specified using an F# computation expression.

 When run, asynchronous computations have two modes: as a work item (executing synchronous 
 code), or as a wait item (waiting for an event or I/O completion). 

 When run, asynchronous computations can be governed by CancellationToken. This can usually 
 be specified when the async computation is started. The associated CancellationTokenSource 
 may be used to cancel the asynchronous computation. Asynchronous computations built using 
 computation expressions can check the cancellation condition regularly. Synchronous 
 computations within an asynchronous computation do not automatically check this condition. 
</summary>
</member>
<member name="P:Microsoft.FSharp.Control.FSharpDelegateEvent`1.Publish">
<summary>
 Publish the event as a first class event value
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpDelegateEvent`1.Trigger(System.Object[]`1)">
<summary>
 Trigger the event using the given parameters
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpDelegateEvent`1..ctor">
<summary>
 Create an event object suitable for implementing an arbitrary type of delegate
</summary>
</member>
<member name="T:Microsoft.FSharp.Control.FSharpDelegateEvent`1">
<summary>
 Event implementations for an arbitrary type of delegate
</summary>
</member>
<member name="P:Microsoft.FSharp.Control.FSharpEvent`1.Publish">
<summary>
 Publish an observation  as a first class value
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpEvent`1.Trigger(`0)">
<summary>
 Trigger an observation using the given parameters
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpEvent`1..ctor">
<summary>
 Create an observable object 
</summary>
</member>
<member name="T:Microsoft.FSharp.Control.FSharpEvent`1">
<summary>
 Event implementations for the IEvent&lt;_&gt; type
</summary>
</member>
<member name="P:Microsoft.FSharp.Control.FSharpEvent`2.Publish">
<summary>
 Publish the event as a first class event value
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpEvent`2.Trigger(System.Object,`1)">
<summary>
 Trigger the event using the given sender object and parameters. The sender object may be &lt;c&gt;null&lt;/c&gt;.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpEvent`2..ctor">
<summary>
 Create an event object suitable for delegate types following the standard .NET Framework convention of a first &apos;sender&apos; argument
</summary>
</member>
<member name="T:Microsoft.FSharp.Control.FSharpEvent`2">
<summary>
 Event implementations for a delegate types following the standard .NET Framework convention of a first &apos;sender&apos; argument
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpHandler`1.Invoke(System.Object,`0)">

</member>
<member name="T:Microsoft.FSharp.Control.FSharpHandler`1">
<summary>
 A delegate type associated with the F# event type &lt;c&gt;IEvent&lt;_&gt;&lt;/c&gt;
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.IDelegateEvent`1.RemoveHandler(`0)">
<summary>
 Remove a listener delegate from an event listener store
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.IDelegateEvent`1.AddHandler(`0)">
<summary>
 Connect a handler delegate object to the event. A handler can
 be later removed using RemoveHandler. The listener will
 be invoked when the event is fired.
</summary>
</member>
<member name="T:Microsoft.FSharp.Control.IDelegateEvent`1">
<summary>
 First class event values for arbitrary delegate types. 

 F# gives special status to member properties compatible with type IDelegateEvent and 
 tagged with the CLIEventAttribute. In this case the F# compiler generates approriate 
 CLI metadata to make the member appear to other CLI languages as a CLI event.
</summary>
</member>
<member name="T:Microsoft.FSharp.Control.IEvent`1">
<summary>
 First-class listening points (i.e. objects that permit you to register a callback
 activated when the event is triggered). 
</summary>
</member>
<member name="T:Microsoft.FSharp.Control.IEvent`2">
<summary>
 First class event values for CLI events conforming to CLI Framework standards.
</summary>
</member>
<member name="T:Microsoft.FSharp.Control.Lazy`1">
<summary>
 The type of delayed computations.
 
 Use the values in the &lt;c&gt;Lazy&lt;/c&gt; module to manipulate 
 values of this type, and the notation &apos;lazy expr&apos; to create values
 of this type.
</summary>
</member>
<member name="P:Microsoft.FSharp.Control.FSharpMailboxProcessor`1.DefaultTimeout(System.Int32)">
<summary>
 Raise a timeout exception if a message not received in this amount of time. By default
 no timeout is used.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpMailboxProcessor`1.remove_Error(Microsoft.FSharp.Control.FSharpHandler{System.Exception})">
<summary>
 Occurs when the execution of the agent results in an exception
</summary>
</member>
<member name="P:Microsoft.FSharp.Control.FSharpMailboxProcessor`1.Error">
<summary>
 Occurs when the execution of the agent results in an exception
</summary>
</member>
<member name="P:Microsoft.FSharp.Control.FSharpMailboxProcessor`1.DefaultTimeout">
<summary>
 Raise a timeout exception if a message not received in this amount of time. By default
 no timeout is used.
</summary>
</member>
<member name="P:Microsoft.FSharp.Control.FSharpMailboxProcessor`1.CurrentQueueLength">
<summary>
 Returns the number of unprocessed messages in the message queue of the agent
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpMailboxProcessor`1.add_Error(Microsoft.FSharp.Control.FSharpHandler{System.Exception})">
<summary>
 Occurs when the execution of the agent results in an exception
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpMailboxProcessor`1.TryScan``1(Microsoft.FSharp.Core.FSharpFunc`2{`0,Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Control.FSharpAsync{``0}}},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
<summary>
 Scan for a message by looking through messages in arrival order until &apos;scanner&apos; 
 returns a Some value. Other messages remain in the queue.

 Raise a TimeoutException if a timeout is given and the timeout is exceeded.

 This method is for use within the body of the agent. For each agent, at most 
 one concurrent reader may be active, so no more than one concurrent call to 
 Receive, TryReceive, Scan and/or TryScan may be active.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpMailboxProcessor`1.TryReceive(Microsoft.FSharp.Core.FSharpOption{System.Int32})">
<summary>
 Wait for a message. This will consume the first message in arrival order. 

 This method is for use within the body of the agent. 

 Return None if a timeout is given and the timeout is exceeded.

 This method is for use within the body of the agent. For each agent, at most 
 one concurrent reader may be active, so no more than one concurrent call to 
 Receive, TryReceive, Scan and/or TryScan may be active.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpMailboxProcessor`1.TryPostAndReply``1(Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Control.FSharpAsyncReplyChannel{``0},`0},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
<summary>
 Like PostAndReply, but return None if no reply within the timeout period. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpMailboxProcessor`1.Start">
<summary>
 Start the agent
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpMailboxProcessor`1.Start(Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Control.FSharpMailboxProcessor{`0},Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.Unit}},Microsoft.FSharp.Core.FSharpOption{System.Threading.CancellationToken})">
<summary>
 Create and start an agent. The &apos;body&apos; function is used to generate the asynchronous 
 computation executed by the agent.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpMailboxProcessor`1.Scan``1(Microsoft.FSharp.Core.FSharpFunc`2{`0,Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Control.FSharpAsync{``0}}},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
<summary>
 Scan for a message by looking through messages in arrival order until &apos;scanner&apos; 
 returns a Some value. Other messages remain in the queue.

 Return None if a timeout is given and the timeout is exceeded.

 This method is for use within the body of the agent. For each agent, at most 
 one concurrent reader may be active, so no more than one concurrent call to 
 Receive, TryReceive, Scan and/or TryScan may be active.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpMailboxProcessor`1.Receive(Microsoft.FSharp.Core.FSharpOption{System.Int32})">
<summary>
 Wait for a message. This will consume the first message in arrival order. 

 This method is for use within the body of the agent. 

 Raise a TimeoutException if a timeout is given and the timeout is exceeded.

 This method is for use within the body of the agent. For each agent, at most 
 one concurrent reader may be active, so no more than one concurrent call to 
 Receive, TryReceive, Scan and/or TryScan may be active.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpMailboxProcessor`1.PostAndTryAsyncReply``1(Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Control.FSharpAsyncReplyChannel{``0},`0},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
<summary>
 Like AsyncPostAndReply, but return None if no reply within the timeout period. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpMailboxProcessor`1.PostAndReply``1(Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Control.FSharpAsyncReplyChannel{``0},`0},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
<summary>
 Post a message to an agent and await a reply on the channel, synchronously. 

 The message is generated by applying &apos;buildMessage&apos; to a new reply channel 
 to be incorporated into the message. The receiving agent must process this 
 message and invoke the Reply method on this reply channel precisly once.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpMailboxProcessor`1.PostAndAsyncReply``1(Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Control.FSharpAsyncReplyChannel{``0},`0},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
<summary>
 Post a message to an agent and await a reply on the channel, asynchronously. 

 The message is generated by applying &apos;buildMessage&apos; to a new reply channel 
 to be incorporated into the message. The receiving agent must process this 
 message and invoke the Reply method on this reply channel precisly once.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpMailboxProcessor`1.Post(`0)">
<summary>
 Post a message to the message queue of the MailboxProcessor, asynchronously
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.FSharpMailboxProcessor`1.AsyncTryPostAndReply``1(Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Control.FSharpAsyncReplyChannel{``0},`0},Microsoft.FSharp.Core.FSharpOption{System.Int32})">

</member>
<member name="M:Microsoft.FSharp.Control.FSharpMailboxProcessor`1.AsyncPostAndReply``1(Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Control.FSharpAsyncReplyChannel{``0},`0},Microsoft.FSharp.Core.FSharpOption{System.Int32})">

</member>
<member name="M:Microsoft.FSharp.Control.FSharpMailboxProcessor`1..ctor(Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Control.FSharpMailboxProcessor{`0},Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.Unit}},Microsoft.FSharp.Core.FSharpOption{System.Threading.CancellationToken})">
<summary>
 Create an agent. The &apos;body&apos; function is used to generate the asynchronous 
 computation executed by the agent. This function is not executed until 
 &apos;Start&apos; is called.
</summary>
</member>
<member name="T:Microsoft.FSharp.Control.FSharpMailboxProcessor`1">
<summary>
 A message-processing agent which executes an asynchronous computation.

 The agent encapsulates a message queue that supports multiple-writers and 
 a single reader agent. Writers send messages to the agent by using the Post 
 method and its variations.

 The agent may wait for messages using the Receive or TryReceive methods or
 scan through all available messages using the Scan or TryScan method. 
</summary>
</member>
<member name="T:Microsoft.FSharp.Control.lazy`1">

</member>
<member name="T:Microsoft.FSharp.Control.CancellationTokenSourceExtensions">

</member>
<member name="T:Microsoft.FSharp.Control.CommonExtensions">
<summary>
 A module of extension members that provide asynchronous operations for some basic CLI types related to concurrency and I/O.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.EventModule.Pairwise``2(Microsoft.FSharp.Control.IEvent{``0,``1})">
<summary>
 Return a new event that triggers on the second and subsequent triggerings of the input event.
 The Nth triggering of the input event passes the arguments from the N-1th and Nth triggering as
 a pair. The argument passed to the N-1th triggering is held in hidden internal state until the 
 Nth triggering occurs.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.EventModule.Add``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Control.IEvent{``1,``0})">
<summary>
 Run the given function each time the given event is triggered.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.EventModule.Listen``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Control.IEvent{``1,``0})">

</member>
<member name="M:Microsoft.FSharp.Control.EventModule.Scan``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,``0}},``0,Microsoft.FSharp.Control.IEvent{``2,``1})">
<summary>
 Return a new event consisting of the results of applying the given accumulating function
 to successive values triggered on the input event.  An item of internal state
 records the current value of the state parameter.  The internal state is not locked during the
 execution of the accumulation function, so care should be taken that the 
 input IEvent not triggered by multiple threads simultaneously.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.EventModule.Choose``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpOption{``1}},Microsoft.FSharp.Control.IEvent{``2,``0})">
<summary>
 Return a new event which fires on a selection of messages from the original event.
 The selection function takes an original message to an optional new message.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.EventModule.Split``4(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpChoice{``1,``2}},Microsoft.FSharp.Control.IEvent{``3,``0})">
<summary>
 Return a new event that listens to the original event and triggers the 
 first resulting event if the application of the function to the event arguments
 returned a Choice1Of2, and the second event if it returns a Choice2Of2
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.EventModule.Partition``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Boolean},Microsoft.FSharp.Control.IEvent{``1,``0})">
<summary>
 Return a new event that listens to the original event and triggers the 
 first resulting event if the application of the predicate to the event arguments
 returned true, and the second event if it returned false
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.EventModule.Filter``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Boolean},Microsoft.FSharp.Control.IEvent{``1,``0})">
<summary>
 Return a new event that listens to the original event and triggers the resulting
 event only when the argument to the event passes the given function
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.EventModule.Map``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},Microsoft.FSharp.Control.IEvent{``2,``0})">
<summary>
 Return a new event that passes values transformed by the given function
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.EventModule.Merge``3(Microsoft.FSharp.Control.IEvent{``0,``1},Microsoft.FSharp.Control.IEvent{``2,``1})">
<summary>
 Fire the output event when either of the input events fire
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.EventModule.Create``1">

</member>
<member name="T:Microsoft.FSharp.Control.EventModule">

</member>
<member name="T:Microsoft.FSharp.Control.LazyExtensions">

</member>
<member name="M:Microsoft.FSharp.Control.ObservableModule.Pairwise``1(System.IObservable{``0})">
<summary>
 Return a new observable that triggers on the second and subsequent triggerings of the input observable.
 The Nth triggering of the input observable passes the arguments from the N-1th and Nth triggering as
 a pair. The argument passed to the N-1th triggering is held in hidden internal state until the 
 Nth triggering occurs.

 For each observer, the registered intermediate observing object is not thread safe.
 That is, observations arising from the source must not be triggered concurrently 
 on different threads.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.ObservableModule.Subscribe``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.Unit},System.IObservable{``0})">
<summary>
 Create an observer which subscribes to the given observable and which calls
 the given function for each observation.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.ObservableModule.Add``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.Unit},System.IObservable{``0})">
<summary>
 Create an observer which permanently subscribes to the given observable and which calls
 the given function for each observation.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.ObservableModule.Scan``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,``0}},``0,System.IObservable{``1})">
<summary>
 Return an observables which, for each observer, allocates an item of state
 and applies the given accumulating function to successive values arising from
 the input. The returned object will trigger observations for each computed 
 state value, excluding the initial value. The returned object propagates 
 all errors arising from the source and completes when the source completes.

 For each observer, the registered intermediate observing object is not thread safe.
 That is, observations arising from the source must not be triggered concurrently 
 on different threads.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.ObservableModule.Choose``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpOption{``1}},System.IObservable{``0})">
<summary>
 Return an observable which chooses a projection of observations from the source 
 using the given function. The returned object will trigger observations &lt;c&gt;x&lt;/c&gt;
 for which the splitter returns &lt;c&gt;Some x&lt;/c&gt;. The returned object also propagates 
 all errors arising from the source and completes when the source completes.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.ObservableModule.Split``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpChoice{``1,``2}},System.IObservable{``0})">
<summary>
 Return two observables which split the observations of the source by the 
 given function. The first will trigger observations &lt;c&gt;x&lt;/c&gt; for which the 
 splitter returns &lt;c&gt;Choice1Of2 x&lt;/c&gt;. The second will trigger observations 
 &lt;c&gt;y&lt;/c&gt; for which the splitter returns &lt;c&gt;Choice2Of2 y&lt;/c&gt; The splitter is 
 executed once for each subscribed observer. Both also propagate error 
 observations arising from the source and each completes when the source 
 completes. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.ObservableModule.Partition``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Boolean},System.IObservable{``0})">
<summary>
 Return two observables which partition the observations of the source by 
 the given function. The first will trigger observations for those values 
 for which the predicate returns true. The second will trigger observations 
 for those values where the predicate returns false. The predicate is 
 executed once for each subscribed observer. Both also propagate all error 
 observations arising from the source and each completes when the source 
 completes. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.ObservableModule.Filter``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Boolean},System.IObservable{``0})">
<summary>
 Return an observable which filters the observations of the source 
 by the given function. The observable will see only those observations
 for which the predicate returns true. The predicate is executed once for 
 each subscribed observer. The returned object also propagates error 
 observations arising from the source and completes when the source completes.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.ObservableModule.Map``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},System.IObservable{``0})">
<summary>
 Return an observable which transforms the observations of the source by the 
 given function. The transformation function is executed once for each 
 subscribed observer. The returned object also propagates error observations 
 arising from the source and completes when the source completes. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.ObservableModule.Merge``1(System.IObservable{``0},System.IObservable{``0})">
<summary>
 Return an observable for the merged observations from the sources. 
 The returned object propagates success and error values arising 
 from either source and completes when both the sources have completed.

 For each observer, the registered intermediate observing object is not 
 thread safe. That is, observations arising from the sources must not 
 be triggered concurrently on different threads.
</summary>
</member>
<member name="T:Microsoft.FSharp.Control.ObservableModule">
<summary>
 Basic operations on first class event and other observable objects.  
</summary>
</member>
<member name="T:Microsoft.FSharp.Control.WebExtensions">
<summary>
 A module of extension members that provide asynchronous operations for some basic Web operations.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.AbstractClassAttribute..ctor">
<summary>
 Create an instance of the attribute
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.AbstractClassAttribute">
<summary>
 Adding this attribute to class definition makes it abstract, which means it need not
 implement all its methods. Instances of abstract classes may not be constructed directly.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.AllowNullLiteralAttribute..ctor">
<summary>
 Create an instance of the attribute
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.AllowNullLiteralAttribute">
<summary>
 Adding this attribute to a type lets the &apos;null&apos; literal be used for the type 
 within F# code. This attribute may only be added to F#-defined class or 
 interface types.
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.AutoOpenAttribute.Path">
<summary>
 Indicates the namespace or module to be automatically opened when an assembly is referenced
 or an enclosing module opened.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.AutoOpenAttribute..ctor(System.String)">
<summary>
 Create an attribute used to mark a namespace or module path to be &apos;automatically opened&apos; when an assembly is referenced
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.AutoOpenAttribute..ctor">
<summary>
 Create an attribute used to mark a module as &apos;automatically opened&apos; when the enclosing namespace is opened
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.AutoOpenAttribute">
<summary>
 This attribute is used for two purposes. When applied to an assembly, it must be given a string
 argument, and this argument must indicate a valid module or namespace in that assembly. Source
 code files compiled with a reference to this assembly are processed in an environment
 where the given path is automatically oepned.

 When applied to a module within an assembly, then the attribute must not be given any arguments.
 When the enclosing namespace is opened in user source code, the module is also implicitly opened.
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.AutoSerializableAttribute.Value">
<summary>
 The value of the attribute, indicating whether the type is automatically marked serializable or not
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.AutoSerializableAttribute..ctor(System.Boolean)">
<summary>
 Create an instance of the attribute
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.AutoSerializableAttribute">
<summary>
 Adding this attribute to a type with value &apos;false&apos; disables the behaviour where F# makes the
 type Serializable by default.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.CLIEventAttribute..ctor">
<summary>
 Create an instance of the attribute
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.CLIEventAttribute">
<summary>
 Adding this attribute to a property with event type causes it to be compiled with as a CLI
 metadata event, through a syntactic translation to a pair of &apos;add_EventName&apos; and 
 &apos;remove_EventName&apos; methods.
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpChoice`2">
<summary>
 Helper types for active patterns with 2 choices.
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpChoice`3">
<summary>
 Helper types for active patterns with 3 choices.
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpChoice`4">
<summary>
 Helper types for active patterns with 4 choices.
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpChoice`5">
<summary>
 Helper types for active patterns with 5 choices.
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpChoice`6">
<summary>
 Helper types for active patterns with 6 choices.
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpChoice`7">
<summary>
 Helper types for active patterns with 7 choices.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.ClassAttribute..ctor">
<summary>
 Create an instance of the attribute
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.ClassAttribute">
<summary>
 Adding this attribute to a type causes it to be represented using a CLI class.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.ComparisonConditionalOnAttribute..ctor">
<summary>
 Create an instance of the attribute
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.ComparisonConditionalOnAttribute">
<summary>
 This attribute is used to indicate a generic container type satisfies the F# comparison 
 constraint only if a generic argument also satisfies this constraint. For example, adding 
 this attribute to parameter &apos;T on a type definition C&lt;&apos;T&gt; means that a type C&lt;X&gt; only supports 
 comparison if the type X also supports comparison and all other conditions for C&lt;X&gt; to support 
 comparison are also met. The type C&lt;T&gt; can still be used with other type arguments, but a type such 
 as C&lt;(int -&gt; int)&gt; will not support comparison because the type (int -&gt; int) is an F# function type 
 and does not support comparison. 

 This attribute will be ignored if it is used on the generic parameters of functions or methods.
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.CompilationArgumentCountsAttribute.Counts">
<summary>
 Indicates the number of arguments in each argument group 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.CompilationArgumentCountsAttribute..ctor(System.Int32[]`1)">
<summary>
 Create an instance of the attribute
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.CompilationArgumentCountsAttribute">
<summary>
 This attribute is generated automatically by the F# compiler to tag functions and members 
 that accept a partial application of some of their arguments and return a residual function
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.CompilationMappingAttribute.VariantNumber">
<summary>
 Indicates the variant number of the entity, if any, in a linear sequence of elements with F# source code
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.CompilationMappingAttribute.SourceConstructFlags">
<summary>
 Indicates the relationship between the compiled entity and F# source code
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.CompilationMappingAttribute.SequenceNumber">
<summary>
 Indicates the sequence number of the entity, if any, in a linear sequence of elements with F# source code
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.CompilationMappingAttribute..ctor(Microsoft.FSharp.Core.SourceConstructFlags,System.Int32,System.Int32)">
<summary>
 Create an instance of the attribute
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.CompilationMappingAttribute..ctor(Microsoft.FSharp.Core.SourceConstructFlags,System.Int32)">
<summary>
 Create an instance of the attribute
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.CompilationMappingAttribute..ctor(Microsoft.FSharp.Core.SourceConstructFlags)">
<summary>
 Create an instance of the attribute
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.CompilationMappingAttribute">
<summary>
 This attribute is inserted automatically by the F# compiler to tag types 
 and methods in the generated CLI code with flags indicating the correspondence 
 with original source constructs. It is used by the functions in the 
 Microsoft.FSharp.Reflection namespace to reverse-map compiled constructs to 
 their original forms. It is not intended for use from user code.
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.CompilationRepresentationAttribute.Flags">
<summary>
 Indicates one or more adjustments to the compiled representation of an F# type or member
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.CompilationRepresentationAttribute..ctor(Microsoft.FSharp.Core.CompilationRepresentationFlags)">
<summary>
 Create an instance of the attribute
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.CompilationRepresentationAttribute">
<summary>
 This attribute is used to adjust the runtime representation for a type. 
 For example, it may be used to note that the &lt;c&gt;null&lt;/c&gt; representation
 may be used for a type. This affects how some constructs are compiled.
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.CompilationRepresentationFlags">
<summary>
 Indicates one or more adjustments to the compiled representation of an F# type or member
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.CompilationSourceNameAttribute.SourceName">
<summary>
 Indicates the name of the entity in F# source code
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.CompilationSourceNameAttribute..ctor(System.String)">
<summary>
 Create an instance of the attribute
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.CompilationSourceNameAttribute">
<summary>
 This attribute is inserted automatically by the F# compiler to tag 
 methods which are given the &apos;CompiledName&apos; attribute. It is not intended 
 for use from user code.
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.CompiledNameAttribute.CompiledName">
<summary>
 The name of the value as it appears in compiled code
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.CompiledNameAttribute..ctor(System.String)">
<summary>
 Create an instance of the attribute
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.CompiledNameAttribute">
<summary>
 Adding this attribute to a value or function definition in an F# module changes the name used
 for the value in compiled CLI code.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.CustomComparisonAttribute..ctor">
<summary>
 Create an instance of the attribute
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.CustomComparisonAttribute">
<summary>
 Adding this attribute to a type indicates it is a type with a user-defined implementation of comparison.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.CustomEqualityAttribute..ctor">
<summary>
 Create an instance of the attribute
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.CustomEqualityAttribute">
<summary>
 Adding this attribute to a type indicates it is a type with a user-defined implementation of equality.
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.DefaultAugmentationAttribute.Value">
<summary>
 The value of the attribute, indicating whether the type has a default augmentation or not
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.DefaultAugmentationAttribute..ctor(System.Boolean)">
<summary>
 Create an instance of the attribute
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.DefaultAugmentationAttribute">
<summary>
 Adding this attribute to a discriminated union with value false
 turns off the generation of standard helper member tester, constructor 
 and accessor members for the generated CLI class for that type.
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.DefaultValueAttribute.Check">
<summary>
 Indicates if a constraint is asserted that the field type supports &apos;null&apos;
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.DefaultValueAttribute..ctor(System.Boolean)">
<summary>
 Create an instance of the attribute
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.DefaultValueAttribute..ctor">
<summary>
 Create an instance of the attribute
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.DefaultValueAttribute">
<summary>
 Adding this attribute to a field declaration means that the field is 
 not initialized. During type checking a constraint is asserted that the field type supports &apos;null&apos;. 
 If the &apos;check&apos; value is false then the constraint is not asserted. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.EntryPointAttribute..ctor">
<summary>
 Create an instance of the attribute
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.EntryPointAttribute">
<summary>
 Adding this attribute to a function indicates it is the entrypoint for an application.
 If this absent is not speficied for an EXE then the initialization implicit in the
 module bindings in the last file in the compilation sequence are used as the entrypoint.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.EqualityConditionalOnAttribute..ctor">
<summary>
 Create an instance of the attribute
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.EqualityConditionalOnAttribute">
<summary>
 This attribute is used to indicate a generic container type satisfies the F# equality 
 constraint only if a generic argument also satisfies this constraint. For example, adding 
 this attribute to parameter &apos;T on a type definition C&lt;&apos;T&gt; means that a type C&lt;X&gt; only supports 
 equality if the type X also supports equality and all other conditions for C&lt;X&gt; to support 
 equality are also met. The type C&lt;T&gt; can still be used with other type arguments, but a type such 
 as C&lt;(int -&gt; int)&gt; will not support equality because the type (int -&gt; int) is an F# function type 
 and does not support equality. 

 This attribute will be ignored if it is used on the generic parameters of functions or methods.
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.ExperimentalAttribute.Message">
<summary>
 Indicates the warning message to be emitted when F# source code uses this construct
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.ExperimentalAttribute..ctor(System.String)">
<summary>
 Create an instance of the attribute
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.ExperimentalAttribute">
<summary>
 This attribute is used to tag values that are part of an experimental library
 feature
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.FSharpFunc`2.op_Implicit(System.Converter{`0,`1})">
<summary>
 Convert an value of type &lt;c&gt;System.Converter&lt;/c&gt; to a F# first class function value 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.FSharpFunc`2.op_Implicit(Microsoft.FSharp.Core.FSharpFunc`2{`0,`1})">
<summary>
 Convert an F# first class function value to a value of type &lt;c&gt;System.Converter&lt;/c&gt;
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.FSharpFunc`2.ToConverter(Microsoft.FSharp.Core.FSharpFunc`2{`0,`1})">
<summary>
 Convert an F# first class function value to a value of type &lt;c&gt;System.Converter&lt;/c&gt;
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.FSharpFunc`2.InvokeFast``1(Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.FSharpFunc`2{`1,``0}},`0,`1)">
<summary>
 Invoke an F# first class function value with two curried arguments. In some cases this
 will result in a more efficient application than applying the arguments successively.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.FSharpFunc`2.InvokeFast``2(Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.FSharpFunc`2{`1,Microsoft.FSharp.Core.FSharpFunc`2{``0,``1}}},`0,`1,``0)">
<summary>
 Invoke an F# first class function value with three curried arguments. In some cases this
 will result in a more efficient application than applying the arguments successively.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.FSharpFunc`2.InvokeFast``3(Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.FSharpFunc`2{`1,Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,``2}}}},`0,`1,``0,``1)">
<summary>
 Invoke an F# first class function value with four curried arguments. In some cases this
 will result in a more efficient application than applying the arguments successively.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.FSharpFunc`2.InvokeFast``4(Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.FSharpFunc`2{`1,Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,Microsoft.FSharp.Core.FSharpFunc`2{``2,``3}}}}},`0,`1,``0,``1,``2)">
<summary>
 Invoke an F# first class function value with five curried arguments. In some cases this
 will result in a more efficient application than applying the arguments successively.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.FSharpFunc`2.Invoke(`0)">
<summary>
 Invoke an F# first class function value with one argument
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.FSharpFunc`2.FromConverter(System.Converter{`0,`1})">
<summary>
 Convert an value of type &lt;c&gt;System.Converter&lt;/c&gt; to a F# first class function value 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.FSharpFunc`2..ctor">
<summary>
 Construct an instance of an F# first class function value 
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpFunc`2">
<summary>
 The CLI type used to represent F# function values. This type is not
 typically used directly, though may be used from other CLI languages.
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.FSharpInterfaceDataVersionAttribute.Release">
<summary>
 The release number of the F# version associated with the attribute
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.FSharpInterfaceDataVersionAttribute.Minor">
<summary>
 The minor version number of the F# version associated with the attribute
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.FSharpInterfaceDataVersionAttribute.Major">
<summary>
 The major version number of the F# version associated with the attribute
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.FSharpInterfaceDataVersionAttribute..ctor(System.Int32,System.Int32,System.Int32)">
<summary>
 Create an instance of the attribute
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpInterfaceDataVersionAttribute">
<summary>
 This attribute is added to generated assemblies to indicate the 
 version of the data schema used to encode additional F#
 specific information in the resource attached to compiled F# libraries.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.FSharpTypeFunc.Specialize``1">
<summary>
 Specialize the type function at a given type
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.FSharpTypeFunc..ctor">
<summary>
 Construct an instance of an F# first class type function value 
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpTypeFunc">
<summary>
 The CLI type used to represent F# first-class type function values. This type is for use
 by compiled F# code.
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.FailureException">

</member>
<member name="T:Microsoft.FSharp.Core.Format`4">
<summary>
 Type of a formatting expression
     &apos;Printer : function type generated by printf
     &apos;State: type argument passed to %a formatters
     &apos;Residue: value generated by the overall printf action (e.g. sprint generates a string)
     &apos;Result: value generated after post processing (e.g. failwithf generates a string internally then raises an exception)
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.Format`5">
<summary>
 Type of a formatting expression
     &apos;Printer : function type generated by printf
     &apos;State: type argument passed to %a formatters
     &apos;Residue: value generated by the overall printf action (e.g. sprint generates a string)
     &apos;Result: value generated after post processing (e.g. failwithf generates a string internally then raises an exception)
     &apos;Tuple: tuple of values generated by scan or match
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.FuncConvert.ToFSharpFunc``2(System.Converter{``0,``1})">
<summary>
 Convert the given Converter delegate object to an F# function value
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.FuncConvert.ToFSharpFunc``1(System.Action{``0})">
<summary>
 Convert the given Action delegate object to an F# function value
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.FuncConvert.FuncFromTupled``6(Microsoft.FSharp.Core.FSharpFunc`2{System.Tuple`5{``0,``1,``2,``3,``4},``5})">
<summary>
 A utility funcion to convert function values from tupled to curried form
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.FuncConvert.FuncFromTupled``5(Microsoft.FSharp.Core.FSharpFunc`2{System.Tuple`4{``0,``1,``2,``3},``4})">
<summary>
 A utility funcion to convert function values from tupled to curried form
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.FuncConvert.FuncFromTupled``4(Microsoft.FSharp.Core.FSharpFunc`2{System.Tuple`3{``0,``1,``2},``3})">
<summary>
 A utility funcion to convert function values from tupled to curried form
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.FuncConvert.FuncFromTupled``3(Microsoft.FSharp.Core.FSharpFunc`2{System.Tuple`2{``0,``1},``2})">
<summary>
 A utility funcion to convert function values from tupled to curried form
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.FuncConvert.FuncFromTupled``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1})">
<summary>
 A utility funcion to convert function values from tupled to curried form
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.FuncConvert">
<summary>
 Helper functions for converting F# first class function values to and from CLI representaions
 of functions using delegates.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.GeneralizableValueAttribute..ctor">
<summary>
 Create an instance of the attribute
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.GeneralizableValueAttribute">
<summary>
 Adding this attribute to a non-function value with generic parameters indicates that 
 uses of the construct can give rise to generic code through type inference. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.InterfaceAttribute..ctor">
<summary>
 Create an instance of the attribute
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.InterfaceAttribute">
<summary>
 Adding this attribute to a type causes it to be represented using a CLI interface.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LiteralAttribute..ctor">
<summary>
 Create an instance of the attribute
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.LiteralAttribute">
<summary>
 Adding this attribute to a value causes it to be compiled as a CLI constant literal.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.MeasureAnnotatedAbbreviationAttribute..ctor">
<summary>
 Create an instance of the attribute
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.MeasureAnnotatedAbbreviationAttribute">
<summary>
 Adding this attribute to a type causes it to be interpreted as a refined type, currently limited to measure-parameterized types.
 This may only be used under very limited conditions.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.MeasureAttribute..ctor">
<summary>
 Create an instance of the attribute
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.MeasureAttribute">
<summary>
 Adding this attribute to a type causes it to be interpreted as a unit of measure.
 This may only be used under very limited conditions.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.NoComparisonAttribute..ctor">
<summary>
 Create an instance of the attribute
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.NoComparisonAttribute">
<summary>
 Adding this attribute to a type indicates it is a type where comparison is an abnormal operation.
 This means that the type does not satisfy the F# &apos;comparison&apos; constraint. Within the bounds of the 
 F# type system, this helps ensure that the F# generic comparison function is not instantiated directly
 at this type. The attribute and checking does not constrain the use of comparison with base or child 
 types of this type.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.NoDynamicInvocationAttribute..ctor">
<summary>
 Create an instance of the attribute
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.NoDynamicInvocationAttribute">
<summary>
 This attribute is used to tag values that may not be dynamically invoked at runtime. This is
 typically added to inlined functions whose implementations include unverifiable code. It
 causes the method body emitted for the inlined function to raise an exception if 
 dynamically invoked, rather than including the unverifiable code in the generated
 assembly.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.NoEqualityAttribute..ctor">
<summary>
 Create an instance of the attribute
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.NoEqualityAttribute">
<summary>
 Adding this attribute to a type indicates it is a type where equality is an abnormal operation.
 This means that the type does not satisfy the F# &apos;equality&apos; constraint. Within the bounds of the 
 F# type system, this helps ensure that the F# generic equality function is not instantiated directly
 at this type. The attribute and checking does not constrain the use of comparison with base or child 
 types of this type.
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.OCamlCompatibilityAttribute.Message">
<summary>
 Indicates the warning message to be emitted when F# source code uses this construct
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.OCamlCompatibilityAttribute..ctor(System.String)">
<summary>
 Create an instance of the attribute
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.OCamlCompatibilityAttribute..ctor">
<summary>
 Create an instance of the attribute
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.OCamlCompatibilityAttribute">
<summary>
 This attribute is used to tag values, modules and types that are only
 present in F# to permit a degree of code-compatibility and cross-compilation
 with other implementations of ML-familty languages, in particular OCaml. The
 use of the construct will give a warning unless the --ml-compatibility flag
 is specified.
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.FSharpOption`1.Value">
<summary>
 Get the value of a &apos;Some&apos; option. A NullReferenceException is raised if the option is &apos;None&apos;.
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.FSharpOption`1.None">
<summary>
 Create an option value that is a &apos;None&apos; value.
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.FSharpOption`1.IsSome">
<summary>
 Return &apos;true&apos; if the option is a &apos;Some&apos; value.
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.FSharpOption`1.IsNone">
<summary>
 Return &apos;true&apos; if the option is a &apos;None&apos; value.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.FSharpOption`1.Some(`0)">
<summary>
 Create an option value that is a &apos;Some&apos; value.
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpOption`1">
<summary>
 The type of optional values. When used from other CLI languages the
 empty option is the &lt;c&gt;null&lt;/c&gt; value. 

 Use the constructors &lt;c&gt;Some&lt;/c&gt; and &lt;c&gt;None&lt;/c&gt; to create values of this type.
 Use the values in the &lt;c&gt;Option&lt;/c&gt; module to manipulate values of this type,
 or pattern match against the values directly.

 &lt;c&gt;None&lt;/c&gt; values will appear as the value &lt;c&gt;null&lt;/c&gt; to other CLI languages.
 Instance methods on this type will appear as static methods to other CLI languages
 due to the use of &lt;c&gt;null&lt;/c&gt; as a value representation.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.OptionalArgumentAttribute..ctor">
<summary>
 Create an instance of the attribute
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.OptionalArgumentAttribute">
<summary>
 This attribute is added automatically for all optional arguments
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.OverloadIDAttribute.UniqueName">
<summary>
 A unique identifier for this overloaded member within a given overload set
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.OverloadIDAttribute..ctor(System.String)">
<summary>
 Create an instance of the attribute
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.OverloadIDAttribute">

</member>
<member name="P:Microsoft.FSharp.Core.PrintfFormat`4.Value">
<summary>
 The raw text of the format string 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.PrintfFormat`4..ctor(System.String)">
<summary>
 Construct a format string 
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.PrintfFormat`4">
<summary>
 Type of a formatting expression.
     &apos;Printer : function type generated by printf
     &apos;State: type argument passed to %a formatters
     &apos;Residue: value generated by the overall printf action (e.g. sprint generates a string)
     &apos;Result: value generated after post processing (e.g. failwithf generates a string internally then raises an exception)
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.PrintfFormat`5..ctor(System.String)">
<summary>
 Construct a format string 
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.PrintfFormat`5">
<summary>
 Type of a formatting expression.
     &apos;Printer : function type generated by printf
     &apos;State: type argument passed to %a formatters
     &apos;Residue: value generated by the overall printf action (e.g. sprint generates a string)
     &apos;Result: value generated after post processing (e.g. failwithf generates a string internally then raises an exception)
     &apos;Tuple: tuple of values generated by scan or match
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.FSharpRef`1.Value(`0)">
<summary>
 The current value of the reference cell
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.FSharpRef`1.Value">
<summary>
 The current value of the reference cell
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.FSharpRef`1">
<summary>
 The type of mutable references. Use the functions [:=] and [!] to get and
 set values of this type.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.ReferenceEqualityAttribute..ctor(System.Boolean)">

</member>
<member name="M:Microsoft.FSharp.Core.ReferenceEqualityAttribute..ctor">
<summary>
 Create an instance of the attribute
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.ReferenceEqualityAttribute">
<summary>
 Adding this attribute to a record or union type disables the automatic generation
 of overrides for &apos;System.Object.Equals(obj)&apos;, &apos;System.Object.GetHashCode()&apos; 
 and &apos;System.IComparable&apos; for the type. The type will by default use reference equality.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.ReflectedDefinitionAttribute..ctor">
<summary>
 Create an instance of the attribute
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.ReflectedDefinitionAttribute">
<summary>
 Adding this attribute to the let-binding for the definition of a top-level 
 value makes the quotation expression that implements the value available
 for use at runtime.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.RequireQualifiedAccessAttribute..ctor">
<summary>
 Create an instance of the attribute
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.RequireQualifiedAccessAttribute">
<summary>
 This attribute is used to indicate that references to a the elements of a module, record or union 
 type require explicit qualified access.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.RequiresExplicitTypeArgumentsAttribute..ctor">
<summary>
 Create an instance of the attribute
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.RequiresExplicitTypeArgumentsAttribute">
<summary>
 Adding this attribute to a type, value or member requires that 
 uses of the construct must explicitly instantiate any generic type parameters.
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.SealedAttribute.Value">
<summary>
 The value of the attribute, indicating whether the type is sealed or not
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.SealedAttribute..ctor(System.Boolean)">
<summary>
 Create an instance of the attribute
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.SealedAttribute..ctor">
<summary>
 Create an instance of the attribute
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.SealedAttribute">
<summary>
 Adding this attribute to class definition makes it sealed, which means it may not
 be extended or implemented.
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.SourceConstructFlags">
<summary>
 Indicates the relationship between a compiled entity in a CLI binary and an element in F# source code
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.StructAttribute..ctor">
<summary>
 Create an instance of the attribute
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.StructAttribute">
<summary>
 Adding this attribute to a type causes it to be represented using a CLI struct.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.StructuralComparisonAttribute..ctor(System.Boolean)">

</member>
<member name="M:Microsoft.FSharp.Core.StructuralComparisonAttribute..ctor">
<summary>
 Create an instance of the attribute
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.StructuralComparisonAttribute">
<summary>
 Adding this attribute to a record, union or struct type confirms confirms the 
 automatic generation of implementations for &apos;System.IComparable&apos; for the type.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.StructuralEqualityAttribute..ctor(System.Boolean)">

</member>
<member name="M:Microsoft.FSharp.Core.StructuralEqualityAttribute..ctor">
<summary>
 Create an instance of the attribute
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.StructuralEqualityAttribute">
<summary>
 Adding this attribute to a record, union or struct type confirms the automatic 
 generation of overrides for &apos;System.Object.Equals(obj)&apos; and 
 &apos;System.Object.GetHashCode()&apos; for the type. 
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.StructuredFormatDisplayAttribute.Value">
<summary>
 Indicates the text to display by default when objects of this type are displayed 
 using &apos;%A&apos; printf formatting patterns and other two-dimensional text-based display 
 layouts. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.StructuredFormatDisplayAttribute..ctor(System.String)">
<summary>
 Create an instance of the attribute
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.StructuredFormatDisplayAttribute">
<summary>
 This attribute is used to mark how a type is displayed by default when using 
 &apos;%A&apos; printf formatting patterns and other two-dimensional text-based display layouts. 
 In this version of F# the only valid values are of the form &lt;c&gt;PreText {PropertyName} PostText&lt;/c&gt;.
 The property name indicates a property to evaluate and to display instead of the object itself. 
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.Unit">
<summary>
 The type &apos;unit&apos;, which has only one value &quot;()&quot;. This value is special and
 always uses the representation &apos;null&apos;.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.UnverifiableAttribute..ctor">
<summary>
 Create an instance of the attribute
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.UnverifiableAttribute">
<summary>
 This attribute is used to tag values whose use will result in the generation
 of unverifiable code. These values are inevitably marked &apos;inline&apos; to ensure that
 the unverifiable constructs are not present in the actual code for the F# library,
 but are rather copied to the source code of the caller.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.VolatileFieldAttribute..ctor">
<summary>
 Create an instance of the attribute
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.VolatileFieldAttribute">
<summary>
 Adding this attribute to an F# mutable binding causes the &quot;volatile&quot;
 prefix to be used for all accesses to the field.
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.[,,,]`1">
<summary>
 Four dimensional arrays, typically zero-based. Non-zero-based arrays
 can be created using methods on the System.Array type.

 Use the values in the &lt;c&gt;Array4D&lt;/c&gt; module
 to manipulate values of this type, or the notation &apos;arr.[x1,x2,x3,x4]&apos; to get and set array
 values.   
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.[,,]`1">
<summary>
 Three dimensional arrays, typically zero-based. Non-zero-based arrays
 can be created using methods on the System.Array type.

 Use the values in the &lt;c&gt;Array3D&lt;/c&gt; module
 to manipulate values of this type, or the notation &apos;arr.[x1,x2,x3]&apos; to get and set array
 values.   
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.[,]`1">
<summary>
 Two dimensional arrays, typically zero-based. 

 Use the values in the &lt;c&gt;Array2D&lt;/c&gt; module
 to manipulate values of this type, or the notation &apos;arr.[x,y]&apos; to get/set array
 values.   

 Non-zero-based arrays can also be created using methods on the System.Array type.
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.[]`1">
<summary>
 Single dimensional, zero-based arrays, written &apos;int[]&apos;, &apos;string[]&apos; etc.
 Use the values in the &lt;c&gt;Array&lt;/c&gt; module to manipulate values 
 of this type, or the notation &apos;arr.[x]&apos; to get/set array
 values.   
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.array`1">
<summary>
 Single dimensional, zero-based arrays, written &apos;int[]&apos;, &apos;string[]&apos; etc.
 Use the values in the &lt;c&gt;Array&lt;/c&gt; module to manipulate values 
 of this type, or the notation &apos;arr.[x]&apos; to get/set array
 values.   
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.bool">
<summary>
 An abbreviation for the CLI type &lt;c&gt;System.Boolean&lt;/c&gt;
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.byref`1">
<summary>
 Represents a managed pointer in F# code.
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.byte">
<summary>
 An abbreviation for the CLI type &lt;c&gt;System.Byte&lt;/c&gt;
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.char">
<summary>
 An abbreviation for the CLI type &lt;c&gt;System.Char&lt;/c&gt;
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.decimal">
<summary>
 An abbreviation for the CLI type &lt;c&gt;System.Decimal&lt;/c&gt;
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.decimal`1">
<summary>
 The type of decimal numbers, annotated with a unit of measure. The unit
 of measure is erased in compiled code and when values of this type
 are analyzed using reflection. The type is representationally equivalent to 
 &lt;c&gt;System.Decimal&lt;/c&gt;.
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.double">
<summary>
 An abbreviation for the CLI type &lt;c&gt;System.Double&lt;/c&gt;
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.exn">
<summary>
 An abbreviation for the CLI type &lt;c&gt;System.Exception&lt;/c&gt;
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.float">
<summary>
 An abbreviation for the CLI type &lt;c&gt;System.Double&lt;/c&gt;
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.float32">
<summary>
 An abbreviation for the CLI type &lt;c&gt;System.Single&lt;/c&gt;
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.float32`1">
<summary>
 The type of floating point numbers, annotated with a unit of measure. The unit
 of measure is erased in compiled code and when values of this type
 are analyzed using reflection. The type is representationally equivalent to 
 &lt;c&gt;System.Single&lt;/c&gt;.
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.float`1">
<summary>
 The type of floating point numbers, annotated with a unit of measure. The unit
 of measure is erased in compiled code and when values of this type
 are analyzed using reflection. The type is representationally equivalent to 
 &lt;c&gt;System.Double&lt;/c&gt;.
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.ilsigptr`1">
<summary>
 This type is for internal use by the F# code generator
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.int">
<summary>
 An abbreviation for the CLI type &lt;c&gt;System.Int32&lt;/c&gt;
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.int16">
<summary>
 An abbreviation for the CLI type &lt;c&gt;System.Int16&lt;/c&gt;
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.int16`1">
<summary>
 The type of 16-bit signed integer numbers, annotated with a unit of measure. The unit
 of measure is erased in compiled code and when values of this type
 are analyzed using reflection. The type is representationally equivalent to 
 &lt;c&gt;System.Int16&lt;/c&gt;.
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.int32">
<summary>
 An abbreviation for the CLI type &lt;c&gt;System.Int32&lt;/c&gt;
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.int64">
<summary>
 An abbreviation for the CLI type &lt;c&gt;System.Int64&lt;/c&gt;
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.int64`1">
<summary>
 The type of 64-bit signed integer numbers, annotated with a unit of measure. The unit
 of measure is erased in compiled code and when values of this type
 are analyzed using reflection. The type is representationally equivalent to 
 &lt;c&gt;System.Int64&lt;/c&gt;.
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.int8">
<summary>
 An abbreviation for the CLI type &lt;c&gt;System.SByte&lt;/c&gt;
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.int`1">
<summary>
 The type of 32-bit signed integer numbers, annotated with a unit of measure. The unit
 of measure is erased in compiled code and when values of this type
 are analyzed using reflection. The type is representationally equivalent to 
 &lt;c&gt;System.Int32&lt;/c&gt;.
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.nativeint">
<summary>
 An abbreviation for the CLI type &lt;c&gt;System.IntPtr&lt;/c&gt;
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.nativeptr`1">
<summary>
 Represents an unmanaged pointer in F# code.

 This type should only be used when writing F# code that interoperates
 with native code.  Use of this type in F# code may result in
 unverifiable code being generated.  Conversions to and from the 
 &lt;c&gt;nativeint&lt;/c&gt; type may be required. Values of this type can be generated
 by the functions in the &lt;c&gt;NativeInterop.NativePtr&lt;/c&gt; module.
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.obj">
<summary>
 An abbreviation for the CLI type &lt;c&gt;System.Object&lt;/c&gt;
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.option`1">
<summary>
 The type of optional values. When used from other CLI languages the
 empty option is the &lt;c&gt;null&lt;/c&gt; value. 

 Use the constructors &lt;c&gt;Some&lt;/c&gt; and &lt;c&gt;None&lt;/c&gt; to create values of this type.
 Use the values in the &lt;c&gt;Option&lt;/c&gt; module to manipulate values of this type,
 or pattern match against the values directly.

 &apos;None&apos; values will appear as the value &lt;c&gt;null&lt;/c&gt; to other CLI languages.
 Instance methods on this type will appear as static methods to other CLI languages
 due to the use of &lt;c&gt;null&lt;/c&gt; as a value representation.
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.ref`1">
<summary>
 The type of mutable references. Use the functions [:=] and [!] to get and
 set values of this type.
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.sbyte">
<summary>
 An abbreviation for the CLI type &lt;c&gt;System.SByte&lt;/c&gt;
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.sbyte`1">
<summary>
 The type of 8-bit signed integer numbers, annotated with a unit of measure. The unit
 of measure is erased in compiled code and when values of this type
 are analyzed using reflection. The type is representationally equivalent to 
 &lt;c&gt;System.SByte&lt;/c&gt;.
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.single">
<summary>
 An abbreviation for the CLI type &lt;c&gt;System.Single&lt;/c&gt;
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.string">
<summary>
 An abbreviation for the CLI type &lt;c&gt;System.String&lt;/c&gt;
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.uint16">
<summary>
 An abbreviation for the CLI type &lt;c&gt;System.UInt16&lt;/c&gt;
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.uint32">
<summary>
 An abbreviation for the CLI type &lt;c&gt;System.UInt32&lt;/c&gt;
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.uint64">
<summary>
 An abbreviation for the CLI type &lt;c&gt;System.UInt64&lt;/c&gt;
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.uint8">
<summary>
 An abbreviation for the CLI type &lt;c&gt;System.Byte&lt;/c&gt;
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.unativeint">
<summary>
 An abbreviation for the CLI type &lt;c&gt;System.UIntPtr&lt;/c&gt;
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.unit">
<summary>
 The type &apos;unit&apos;, which has only one value &quot;()&quot;. This value is special and
 always uses the representation &apos;null&apos;.
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.MatchFailureException">
<summary>
 Non-exhaustive match failures will raise the MatchFailureException exception
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.CompilerServices.GeneratedSequenceBase`1.LastGenerated">
<summary>
 The F# compiler emits implementations of this method for compiled sequence expressions
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.CompilerServices.GeneratedSequenceBase`1.CheckClose">
<summary>
 The F# compiler emits implementations of this method for compiled sequence expressions
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.CompilerServices.GeneratedSequenceBase`1.GetFreshEnumerator">
<summary>
 The F# compiler emits implementations of this method for compiled sequence expressions
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.CompilerServices.GeneratedSequenceBase`1.GenerateNext(Microsoft.FSharp.Core.byref{System.Collections.Generic.IEnumerable{`0}})">
<summary>
 The F# compiler emits implementations of this method for compiled sequence expressions
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.CompilerServices.GeneratedSequenceBase`1.Close">
<summary>
 The F# compiler emits implementations of this method for compiled sequence expressions
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.CompilerServices.GeneratedSequenceBase`1..ctor">
<summary>
 The F# compiler emits implementations of this method for compiled sequence expressions
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.CompilerServices.GeneratedSequenceBase`1">
<summary>
 The F# compiler emits implementations of this type for compiled sequence expressions
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.CompilerServices.RuntimeHelpers.StructBox`1.Value">

</member>
<member name="P:Microsoft.FSharp.Core.CompilerServices.RuntimeHelpers.StructBox`1.Comparer">

</member>
<member name="M:Microsoft.FSharp.Core.CompilerServices.RuntimeHelpers.StructBox`1..ctor(`0)">

</member>
<member name="T:Microsoft.FSharp.Core.CompilerServices.RuntimeHelpers.StructBox`1">

</member>
<member name="M:Microsoft.FSharp.Core.CompilerServices.RuntimeHelpers.CreateEvent``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.FSharpFunc`2{System.Object,Microsoft.FSharp.Core.FSharpFunc`2{``1,Microsoft.FSharp.Core.Unit}},``0})">

</member>
<member name="M:Microsoft.FSharp.Core.CompilerServices.RuntimeHelpers.EnumerateUsing``3(``0,Microsoft.FSharp.Core.FSharpFunc`2{``0,``1})">
<summary>
 The F# compiler emits calls to this function to implement the &apos;use&apos; operator for F# sequence expressions
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.CompilerServices.RuntimeHelpers.EnumerateFromFunctions``2(Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.Unit,``0},Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Boolean},Microsoft.FSharp.Core.FSharpFunc`2{``0,``1})">
<summary>
 The F# compiler emits calls to this function to implement the compiler-intrinsic
 conversions from untyped System.Collections.IEnumerable sequences to typed sequences
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.CompilerServices.RuntimeHelpers.EnumerateThenFinally``1(System.Collections.Generic.IEnumerable{``0},Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
<summary>
 The F# compiler emits calls to this function to 
 implement the &apos;try/finally&apos; operator for F# sequence expressions
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.CompilerServices.RuntimeHelpers.EnumerateWhile``1(Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.Unit,System.Boolean},System.Collections.Generic.IEnumerable{``0})">
<summary>
 The F# compiler emits calls to this function to 
 implement the &apos;while&apos; operator for F# sequence expressions
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.CompilerServices.RuntimeHelpers">
<summary>
 A group of functions used as part of the compiled representation of F# sequence expressions
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.ExtraTopLevelOperators.IEvent">

</member>
<member name="P:Microsoft.FSharp.Core.ExtraTopLevelOperators.Array3">

</member>
<member name="P:Microsoft.FSharp.Core.ExtraTopLevelOperators.Array2">

</member>
<member name="M:Microsoft.FSharp.Core.ExtraTopLevelOperators.LazyPattern``1(System.Lazy{``0})">
<summary>
 An active pattern to force the execution of values of type &lt;c&gt;Lazy&amp;lt;_&amp;gt;&lt;/c&gt;
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.ExtraTopLevelOperators.SpliceUntypedExpression``1(Microsoft.FSharp.Quotations.FSharpExpr)">
<summary>
 Special prefix operator for splicing untyped expressions into quotation holes
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.ExtraTopLevelOperators.SpliceExpression``1(Microsoft.FSharp.Quotations.FSharpExpr{``0})">
<summary>
 Special prefix operator for splicing typed expressions into quotation holes
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.ExtraTopLevelOperators.CreateArray2D``2(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Builds a 2D array from a sequence of sequences of elements
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.ExtraTopLevelOperators.CreateDictionary``2(System.Collections.Generic.IEnumerable{System.Tuple`2{``0,``1}})">
<summary>
 Builds a read-only lookup table from a sequence of key/value pairs. The key objects are indexed using generic hashing and equality.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.ExtraTopLevelOperators.ToSByte``1(``0)">
<summary>
 Converts the argument to signed byte. This is a direct conversion for all 
 primitive numeric types. For strings, the input is converted using &lt;c&gt;SByte.Parse()&lt;/c&gt;  with InvariantCulture settings. Otherwise the operation requires and invokes a &lt;c&gt;ToSByte&lt;/c&gt; method on the input type
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.ExtraTopLevelOperators.ToByte``1(``0)">
<summary>
 Converts the argument to byte. This is a direct conversion for all 
 primitive numeric types. For strings, the input is converted using &lt;c&gt;Byte.Parse()&lt;/c&gt; on strings and otherwise requires a &lt;c&gt;ToByte&lt;/c&gt; method on the input type
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.ExtraTopLevelOperators.ToDouble``1(``0)">
<summary>
 Converts the argument to 64-bit float. This is a direct conversion for all 
 primitive numeric types. For strings, the input is converted using &lt;c&gt;Double.Parse()&lt;/c&gt;  with InvariantCulture settings. Otherwise the operation requires and invokes a &lt;c&gt;ToDouble&lt;/c&gt; method on the input type
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.ExtraTopLevelOperators.ToSingle``1(``0)">
<summary>
 Converts the argument to 32-bit float. This is a direct conversion for all 
 primitive numeric types. For strings, the input is converted using &lt;c&gt;Single.Parse()&lt;/c&gt;  with InvariantCulture settings. Otherwise the operation requires and invokes a &lt;c&gt;ToSingle&lt;/c&gt; method on the input type
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.ExtraTopLevelOperators.DefaultAsyncBuilder">
<summary>
 Build an aysnchronous workflow using computation expression syntax
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.ExtraTopLevelOperators.CreateSet``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Builds a set from a sequence of objects. The objects are indexed using generic comparison
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.ExtraTopLevelOperators.PrintFormatLineToTextWriter``1(System.IO.TextWriter,Microsoft.FSharp.Core.PrintfFormat{``0,System.IO.TextWriter,Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
<summary>
 Print to a file using the given format, and add a newline
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.ExtraTopLevelOperators.PrintFormatToTextWriter``1(System.IO.TextWriter,Microsoft.FSharp.Core.PrintfFormat{``0,System.IO.TextWriter,Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
<summary>
 Print to a file using the given format
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.ExtraTopLevelOperators.PrintFormatToStringThenFail``2(Microsoft.FSharp.Core.PrintfFormat{``0,Microsoft.FSharp.Core.Unit,System.String,``1})">
<summary>
 Print to a string buffer and raise an exception with the given
 result.   Helper printers must return strings.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.ExtraTopLevelOperators.PrintFormatToString``1(Microsoft.FSharp.Core.PrintfFormat{``0,Microsoft.FSharp.Core.Unit,System.String,System.String})">
<summary>
 Print to a string using the given format
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.ExtraTopLevelOperators.PrintFormatLineToError``1(Microsoft.FSharp.Core.PrintfFormat{``0,System.IO.TextWriter,Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
<summary>
 Print to &lt;c&gt;stderr&lt;/c&gt; using the given format, and add a newline
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.ExtraTopLevelOperators.PrintFormatToError``1(Microsoft.FSharp.Core.PrintfFormat{``0,System.IO.TextWriter,Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
<summary>
 Print to &lt;c&gt;stderr&lt;/c&gt; using the given format
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.ExtraTopLevelOperators.PrintFormatLine``1(Microsoft.FSharp.Core.PrintfFormat{``0,System.IO.TextWriter,Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
<summary>
 Print to &lt;c&gt;stdout&lt;/c&gt; using the given format, and add a newline
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.ExtraTopLevelOperators.PrintFormat``1(Microsoft.FSharp.Core.PrintfFormat{``0,System.IO.TextWriter,Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
<summary>
 Print to &lt;c&gt;stdout&lt;/c&gt; using the given format
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.ExtraTopLevelOperators.PrintAny``1(``0)">

</member>
<member name="M:Microsoft.FSharp.Core.ExtraTopLevelOperators.OutputAny``1(System.IO.TextWriter,``0)">

</member>
<member name="M:Microsoft.FSharp.Core.ExtraTopLevelOperators.AnyToString``1(``0)">

</member>
<member name="T:Microsoft.FSharp.Core.ExtraTopLevelOperators">

</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.DivideByInt``1(``0,System.Int32)">
<summary>
 Divide a floating point value by an integer
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.GenericOne``1">
<summary>
 Resolves to the one value for any primitive numeric type or any type with a static member called &apos;One&apos;
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.GenericZero``1">
<summary>
 Resolves to the zero value for any primitive numeric type or any type with a static member called &apos;Zero&apos;
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.DivideByIntDynamic``1(``0,System.Int32)">
<summary>
 A compiler intrinsic that implements dynamic invocations for the DivideByInt primitive
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.CheckedMultiplyDynamic``3(``0,``1)">
<summary>
 A compiler intrinsic that implements dynamic invocations to the checked &apos;+&apos; operator
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.MultiplyDynamic``3(``0,``1)">
<summary>
 A compiler intrinsic that implements dynamic invocations to the &apos;+&apos; operator
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.CheckedAdditionDynamic``3(``0,``1)">
<summary>
 A compiler intrinsic that implements dynamic invocations to the checked &apos;+&apos; operator
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.AdditionDynamic``3(``0,``1)">
<summary>
 A compiler intrinsic that implements dynamic invocations to the &apos;+&apos; operator
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.GenericOneDynamic``1">
<summary>
 Resolves to the zero value for any primitive numeric type or any type with a static member called &apos;Zero&apos;
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.GenericZeroDynamic``1">
<summary>
 Resolves to the zero value for any primitive numeric type or any type with a static member called &apos;Zero&apos;
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.ParseUInt64(System.String)">
<summary>
 Parse an uint64 according to the rules used by the overloaded &apos;uint64&apos; conversion operator when applied to strings
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.ParseInt64(System.String)">
<summary>
 Parse an int64 according to the rules used by the overloaded &apos;int64&apos; conversion operator when applied to strings
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.ParseUInt32(System.String)">
<summary>
 Parse an uint32 according to the rules used by the overloaded &apos;uint32&apos; conversion operator when applied to strings
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.ParseInt32(System.String)">
<summary>
 Parse an int32 according to the rules used by the overloaded &apos;int32&apos; conversion operator when applied to strings
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.EnumToValue``2(``0)">
<summary>
 Get the underlying value for an enum value
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.EnumOfValue``2(``0)">
<summary>
 Build an enum value from an underlying value
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.DefaultValue``1">
<summary>
 Generate a null value for reference types.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.GenericHashWithComparer``1(System.Collections.IEqualityComparer,``0)">
<summary>
 Recursively hash a part of a value according to its structure. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.GenericLimitedHash``1(System.Int32,``0)">
<summary>
 Hash a value according to its structure. Use the given limit to restrict the hash when hashing F#
 records, lists and union types.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.GenericHash``1(``0)">
<summary>
 Hash a value according to its structure. This hash is not limited by an overall node count when hashing F#
 records, lists and union types.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.FastLimitedGenericEqualityComparer``1(System.Int32)">
<summary>
 Make an F# hash/equality object for the given type using node-limited hashing when hashing F#
 records, lists and union types.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.FastGenericEqualityComparer``1">
<summary>
 Make an F# hash/equality object for the given type
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.FastGenericComparerCanBeNull``1">
<summary>
 Make an F# comparer object for the given type, where it can be null if System.Collections.Generic.Comparer&lt;&apos;T&gt;.Default
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.FastGenericComparer``1">
<summary>
 Make an F# comparer object for the given type
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.LanguagePrimitives.GenericComparer">
<summary>
 A static F# comparer object
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.LanguagePrimitives.GenericEqualityERComparer">
<summary>
 Return an F# comparer object suitable for hashing and equality. This hashing behaviour
 of the returned comparer is not limited by an overall node count when hashing F#
 records, lists and union types.  This equality comparer has equivalence 
 relation semantics ([nan] = [nan]).
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.LanguagePrimitives.GenericEqualityComparer">
<summary>
 Return an F# comparer object suitable for hashing and equality. This hashing behaviour
 of the returned comparer is not limited by an overall node count when hashing F#
 records, lists and union types.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.PhysicalHash``1(``0)">
<summary>
 The physical hash. Hashes on the object identity, except for value types,
 where we hash on the contents.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.PhysicalEquality``1(``0,``0)">
<summary>
 Reference/physical equality. 
 True if boxed versions of the inputs are reference-equal, OR if
 both are primitive numeric types and the implementation of Object.Equals for the type
 of the first argument returns true on the boxed versions of the inputs. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.GenericMaximum``1(``0,``0)">
<summary>
 Take the maximum of two values structurally according to the order given by GenericComparison
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.GenericMinimum``1(``0,``0)">
<summary>
 Take the minimum of two values structurally according to the order given by GenericComparison
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.GenericGreaterOrEqual``1(``0,``0)">
<summary>
 Compare two values   
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.GenericLessOrEqual``1(``0,``0)">
<summary>
 Compare two values   
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.GenericGreaterThan``1(``0,``0)">
<summary>
 Compare two values   
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.GenericLessThan``1(``0,``0)">
<summary>
 Compare two values   
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.GenericComparisonWithComparer``1(System.Collections.IComparer,``0,``0)">
<summary>
 Compare two values. May be called as a recursive case from an implementation of System.IComparable to
 ensure consistent NaN comparison semantics.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.GenericComparison``1(``0,``0)">
<summary>
 Compare two values 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.GenericEqualityWithComparer``1(System.Collections.IEqualityComparer,``0,``0)">
<summary>
 Compare two values for equality
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.GenericEqualityER``1(``0,``0)">
<summary>
 Compare two values for equality using equivalence relation semantics ([nan] = [nan])
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.GenericEquality``1(``0,``0)">
<summary>
 Compare two values for equality using partial equivalence relation semantics ([nan] &lt;&gt; [nan])
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.FastCompareTuple5``5(System.Collections.IComparer,System.Tuple`5{``0,``1,``2,``3,``4},System.Tuple`5{``0,``1,``2,``3,``4})">
<summary>
 A primitive entry point used by the F# compiler for optimization purposes. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.FastCompareTuple4``4(System.Collections.IComparer,System.Tuple`4{``0,``1,``2,``3},System.Tuple`4{``0,``1,``2,``3})">
<summary>
 A primitive entry point used by the F# compiler for optimization purposes. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.FastCompareTuple3``3(System.Collections.IComparer,System.Tuple`3{``0,``1,``2},System.Tuple`3{``0,``1,``2})">
<summary>
 A primitive entry point used by the F# compiler for optimization purposes. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.FastCompareTuple2``2(System.Collections.IComparer,System.Tuple`2{``0,``1},System.Tuple`2{``0,``1})">
<summary>
 A primitive entry point used by the F# compiler for optimization purposes. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.FastEqualsTuple5``5(System.Collections.IEqualityComparer,System.Tuple`5{``0,``1,``2,``3,``4},System.Tuple`5{``0,``1,``2,``3,``4})">
<summary>
 A primitive entry point used by the F# compiler for optimization purposes. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.FastEqualsTuple4``4(System.Collections.IEqualityComparer,System.Tuple`4{``0,``1,``2,``3},System.Tuple`4{``0,``1,``2,``3})">
<summary>
 A primitive entry point used by the F# compiler for optimization purposes. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.FastEqualsTuple3``3(System.Collections.IEqualityComparer,System.Tuple`3{``0,``1,``2},System.Tuple`3{``0,``1,``2})">
<summary>
 A primitive entry point used by the F# compiler for optimization purposes. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.FastEqualsTuple2``2(System.Collections.IEqualityComparer,System.Tuple`2{``0,``1},System.Tuple`2{``0,``1})">
<summary>
 A primitive entry point used by the F# compiler for optimization purposes. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.FastHashTuple5``5(System.Collections.IEqualityComparer,System.Tuple`5{``0,``1,``2,``3,``4})">
<summary>
 A primitive entry point used by the F# compiler for optimization purposes. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.FastHashTuple4``4(System.Collections.IEqualityComparer,System.Tuple`4{``0,``1,``2,``3})">
<summary>
 A primitive entry point used by the F# compiler for optimization purposes. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.FastHashTuple3``3(System.Collections.IEqualityComparer,System.Tuple`3{``0,``1,``2})">
<summary>
 A primitive entry point used by the F# compiler for optimization purposes. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.FastHashTuple2``2(System.Collections.IEqualityComparer,System.Tuple`2{``0,``1})">
<summary>
 A primitive entry point used by the F# compiler for optimization purposes. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.GenericLessOrEqualIntrinsic``1(``0,``0)">
<summary>
 A primitive entry point used by the F# compiler for optimization purposes. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.GenericGreaterOrEqualIntrinsic``1(``0,``0)">
<summary>
 A primitive entry point used by the F# compiler for optimization purposes. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.GenericGreaterThanIntrinsic``1(``0,``0)">
<summary>
 A primitive entry point used by the F# compiler for optimization purposes. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.GenericLessThanIntrinsic``1(``0,``0)">
<summary>
 A primitive entry point used by the F# compiler for optimization purposes. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.GenericEqualityWithComparerIntrinsic``1(System.Collections.IEqualityComparer,``0,``0)">
<summary>
 A primitive entry point used by the F# compiler for optimization purposes. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.GenericEqualityERIntrinsic``1(``0,``0)">
<summary>
 A primitive entry point used by the F# compiler for optimization purposes. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.GenericEqualityIntrinsic``1(``0,``0)">
<summary>
 A primitive entry point used by the F# compiler for optimization purposes. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.GenericComparisonIntrinsic``1(``0,``0)">
<summary>
 A primitive entry point used by the F# compiler for optimization purposes. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.GenericComparisonWithComparerIntrinsic``1(System.Collections.IComparer,``0,``0)">
<summary>
 A primitive entry point used by the F# compiler for optimization purposes. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.GenericHashWithComparerIntrinsic``1(System.Collections.IEqualityComparer,``0)">
<summary>
 A primitive entry point used by the F# compiler for optimization purposes. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.LimitedGenericHashIntrinsic``1(System.Int32,``0)">
<summary>
 A primitive entry point used by the F# compiler for optimization purposes. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.GenericHashIntrinsic``1(``0)">
<summary>
 A primitive entry point used by the F# compiler for optimization purposes. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.PhysicalEqualityIntrinsic``1(``0,``0)">
<summary>
 A primitive entry point used by the F# compiler for optimization purposes. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.PhysicalHashIntrinsic``1(``0)">
<summary>
 A primitive entry point used by the F# compiler for optimization purposes. 
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare">
<summary>
 The F# compiler emits calls to some of the functions in this module as part of the compiled form of some language constructs
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicFunctions.SetArray4D``1(``0[,,,]`1,System.Int32,System.Int32,System.Int32,System.Int32,``0)">
<summary>
 The standard overloaded associative (4-indexed) mutation operator
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicFunctions.SetArray3D``1(``0[,,]`1,System.Int32,System.Int32,System.Int32,``0)">
<summary>
 The standard overloaded associative (3-indexed) mutation operator
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicFunctions.SetArray2D``1(``0[,]`1,System.Int32,System.Int32,``0)">
<summary>
 The standard overloaded associative (2-indexed) mutation operator
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicFunctions.SetArray``1(``0[]`1,System.Int32,``0)">
<summary>
 The standard overloaded associative (indexed) mutation operator
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicFunctions.GetArray4D``1(``0[,,,]`1,System.Int32,System.Int32,System.Int32,System.Int32)">
<summary>
 The standard overloaded associative (4-indexed) lookup operator
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicFunctions.GetArray3D``1(``0[,,]`1,System.Int32,System.Int32,System.Int32)">
<summary>
 The standard overloaded associative (3-indexed) lookup operator
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicFunctions.GetArray2D``1(``0[,]`1,System.Int32,System.Int32)">
<summary>
 The standard overloaded associative (2-indexed) lookup operator
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicFunctions.GetArray``1(``0[]`1,System.Int32)">
<summary>
 The standard overloaded associative (indexed) lookup operator
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicFunctions.CheckThis``1(``0)">
<summary>
 A compiler intrinsic for checking initialization soundness of recursive bindings
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicFunctions.FailStaticInit">
<summary>
 A compiler intrinsic for checking initialization soundness of recursive static bindings
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicFunctions.FailInit">
<summary>
 A compiler intrinsic for checking initialization soundness of recursive bindings
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicFunctions.Dispose``1(``0)">
<summary>
 A compiler intrinsic for the efficient compilation of sequence expressions
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicFunctions.MakeDecimal(System.Int32,System.Int32,System.Int32,System.Boolean,System.Byte)">
<summary>
 This function implements parsing of decimal constants
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicFunctions.CreateInstance``1">
<summary>
 This function implements calls to default constructors
 acccessed by &apos;new&apos; constraints.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicFunctions.GetString(System.String,System.Int32)">
<summary>
 Primitive used by pattern match compilation 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicFunctions.TypeTestFast``1(System.Object)">
<summary>
 A compiler intrinsic that implements the &apos;:?&apos; operator
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicFunctions.TypeTestGeneric``1(System.Object)">
<summary>
 A compiler intrinsic that implements the &apos;:?&apos; operator
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicFunctions.UnboxFast``1(System.Object)">
<summary>
 A compiler intrinsic that implements the &apos;:?&gt;&apos; operator
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicFunctions.UnboxGeneric``1(System.Object)">
<summary>
 A compiler intrinsic that implements the &apos;:?&gt;&apos; operator
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicFunctions">
<summary>
 The F# compiler emits calls to some of the functions in this module as part of the compiled form of some language constructs
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicOperators.op_IntegerAddressOf``1(``0)">
<summary>
 Address-of. Uses of this value may result in the generation of unverifiable code.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicOperators.op_AddressOf``1(``0)">
<summary>
 Address-of. Uses of this value may result in the generation of unverifiable code.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicOperators.op_BooleanOr(System.Boolean,System.Boolean)">
<summary>
 Binary &apos;or&apos;. When used as a binary operator the right hand value is evaluated only on demand
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicOperators.Or(System.Boolean,System.Boolean)">
<summary>
 Binary &apos;or&apos;. When used as a binary operator the right hand value is evaluated only on demand
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicOperators.op_BooleanAnd(System.Boolean,System.Boolean)">
<summary>
 Binary &apos;and&apos;. When used as a binary operator the right hand value is evaluated only on demand
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicOperators.op_Amp(System.Boolean,System.Boolean)">
<summary>
 Binary &apos;and&apos;. When used as a binary operator the right hand value is evaluated only on demand
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicOperators">
<summary>
 The F# compiler emits calls to some of the functions in this module as part of the compiled form of some language constructs
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.LanguagePrimitives.ErrorStrings.InputMustBeNonNegativeString">

</member>
<member name="P:Microsoft.FSharp.Core.LanguagePrimitives.ErrorStrings.NoNegateMinValueString">

</member>
<member name="P:Microsoft.FSharp.Core.LanguagePrimitives.ErrorStrings.AddressOpNotFirstClassString">

</member>
<member name="P:Microsoft.FSharp.Core.LanguagePrimitives.ErrorStrings.InputArrayEmptyString">

</member>
<member name="P:Microsoft.FSharp.Core.LanguagePrimitives.ErrorStrings.InputSequenceEmptyString">

</member>
<member name="T:Microsoft.FSharp.Core.LanguagePrimitives.ErrorStrings">
<summary>
 For internal use only
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.LanguagePrimitives">
<summary>
 Language primitives associated with the F# language
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.NumericLiterals.NumericLiteralN.FromString``1(System.String)">

</member>
<member name="M:Microsoft.FSharp.Core.NumericLiterals.NumericLiteralN.FromInt64``1(System.Int64)">

</member>
<member name="M:Microsoft.FSharp.Core.NumericLiterals.NumericLiteralN.FromInt32``1(System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Core.NumericLiterals.NumericLiteralN.FromOne``1">

</member>
<member name="M:Microsoft.FSharp.Core.NumericLiterals.NumericLiteralN.FromZero``1">

</member>
<member name="T:Microsoft.FSharp.Core.NumericLiterals.NumericLiteralN">
<summary>
 Provide a default implementation of the F# numeric literal syntax &apos;dddN&apos; 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.NumericLiterals.NumericLiteralI.FromStringDynamic(System.String)">
<summary>
 Provides a default implementations of F# numeric literal syntax  for literals fo the form &apos;dddI&apos; 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.NumericLiterals.NumericLiteralI.FromInt64Dynamic(System.Int64)">
<summary>
 Provides a default implementations of F# numeric literal syntax  for literals fo the form &apos;dddI&apos; 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.NumericLiterals.NumericLiteralI.FromString``1(System.String)">
<summary>
 Provides a default implementations of F# numeric literal syntax  for literals fo the form &apos;dddI&apos; 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.NumericLiterals.NumericLiteralI.FromInt64``1(System.Int64)">
<summary>
 Provides a default implementations of F# numeric literal syntax  for literals fo the form &apos;dddI&apos; 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.NumericLiterals.NumericLiteralI.FromInt32``1(System.Int32)">
<summary>
 Provides a default implementations of F# numeric literal syntax  for literals fo the form &apos;dddI&apos; 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.NumericLiterals.NumericLiteralI.FromOne``1">
<summary>
 Provides a default implementations of F# numeric literal syntax  for literals fo the form &apos;dddI&apos; 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.NumericLiterals.NumericLiteralI.FromZero``1">
<summary>
 Provides a default implementations of F# numeric literal syntax  for literals fo the form &apos;dddI&apos; 
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.NumericLiterals.NumericLiteralI">
<summary>
 Provides a default implementations of F# numeric literal syntax  for literals fo the form &apos;dddI&apos; 
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.NumericLiterals">
<summary>
 Provides a default implementations of F# numeric literal syntax  for literals fo the form &apos;dddI&apos; 
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.Operators.InvalidArgumentException">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.InvalidArgumentPattern(System.Exception)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.InvalidArgument(System.String)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.invalid_op``1(System.String)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.KeyValuePattern``2(System.Collections.Generic.KeyValuePair{``0,``1})">
<summary>
 An active pattern to match values of type &lt;c&gt;System.Collections.Generic.KeyValuePair&lt;/c&gt;
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.ToChar``1(``0)">
<summary>
 Converts the argument to character. Numeric inputs are converted according to the UTF-16 
 encoding for characters. String inputs must be exactly one character long. For other
 input types the operation requires an appropriate static conversion method on the input type.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.ToDecimal``1(``0)">
<summary>
 Converts the argument to System.Decimal using a direct conversion for all 
 primitive numeric types. For strings, the input is converted using &lt;c&gt;UInt64.Parse()&lt;/c&gt;  
 with InvariantCulture settings. Otherwise the operation requires an appropriate
 static conversion method on the input type.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.ToString``1(``0)">
<summary>
 Converts the argument to a string using &lt;c&gt;ToString&lt;/c&gt;.

 For standard integer and floating point values the &lt;c&gt;ToString&lt;/c&gt; conversion 
 uses &lt;c&gt;CultureInfo.InvariantCulture&lt;/c&gt;. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.ToUIntPtr``1(``0)">
<summary>
 Converts the argument to unsigned native integer using a direct conversion for all 
 primitive numeric types. Otherwise the operation requires an appropriate
 static conversion method on the input type.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.ToIntPtr``1(``0)">
<summary>
 Converts the argument to signed native integer. This is a direct conversion for all 
 primitive numeric types. Otherwise the operation requires an appropriate
 static conversion method on the input type.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.ToDouble``1(``0)">
<summary>
 Converts the argument to 64-bit float. This is a direct conversion for all 
 primitive numeric types. For strings, the input is converted using &lt;c&gt;Double.Parse()&lt;/c&gt;  
 with InvariantCulture settings. Otherwise the operation requires an appropriate
 static conversion method on the input type.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.ToSingle``1(``0)">
<summary>
 Converts the argument to 32-bit float. This is a direct conversion for all 
 primitive numeric types. For strings, the input is converted using &lt;c&gt;Single.Parse()&lt;/c&gt;  
 with InvariantCulture settings. Otherwise the operation requires an appropriate
 static conversion method on the input type.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.ToUInt64``1(``0)">
<summary>
 Converts the argument to unsigned 64-bit integer. This is a direct conversion for all 
 primitive numeric types. For strings, the input is converted using &lt;c&gt;UInt64.Parse()&lt;/c&gt;  
 with InvariantCulture settings. Otherwise the operation requires an appropriate
 static conversion method on the input type.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.ToInt64``1(``0)">
<summary>
 Converts the argument to signed 64-bit integer. This is a direct conversion for all 
 primitive numeric types. For strings, the input is converted using &lt;c&gt;Int64.Parse()&lt;/c&gt; 
 with InvariantCulture settings. Otherwise the operation requires an appropriate
 static conversion method on the input type.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.ToUInt32``1(``0)">
<summary>
 Converts the argument to unsigned 32-bit integer. This is a direct conversion for all 
 primitive numeric types. For strings, the input is converted using &lt;c&gt;UInt32.Parse()&lt;/c&gt;  
 with InvariantCulture settings. Otherwise the operation requires an appropriate
 static conversion method on the input type.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.ToInt32``1(``0)">
<summary>
 Converts the argument to signed 32-bit integer. This is a direct conversion for all 
 primitive numeric types. For strings, the input is converted using &lt;c&gt;Int32.Parse()&lt;/c&gt;  
 with InvariantCulture settings. Otherwise the operation requires an appropriate
 static conversion method on the input type.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.ToEnum``1(System.Int32)">
<summary>
 Converts the argument to a particular enum type.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.ToInt``1(``0)">
<summary>
 Converts the argument to signed 32-bit integer. This is a direct conversion for all 
 primitive numeric types. For strings, the input is converted using &lt;c&gt;Int32.Parse()&lt;/c&gt;  
 with InvariantCulture settings. Otherwise the operation requires an appropriate
 static conversion method on the input type.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.ToUInt16``1(``0)">
<summary>
 Converts the argument to unsigned 16-bit integer. This is a direct conversion for all 
 primitive numeric types. For strings, the input is converted using &lt;c&gt;UInt16.Parse()&lt;/c&gt;  
 with InvariantCulture settings. Otherwise the operation requires an appropriate
 static conversion method on the input type.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.ToInt16``1(``0)">
<summary>
 Converts the argument to signed 16-bit integer. This is a direct conversion for all 
 primitive numeric types. For strings, the input is converted using &lt;c&gt;Int16.Parse()&lt;/c&gt;  
 with InvariantCulture settings. Otherwise the operation requires an appropriate
 static conversion method on the input type.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.ToSByte``1(``0)">
<summary>
 Converts the argument to signed byte. This is a direct conversion for all 
 primitive numeric types. For strings, the input is converted using &lt;c&gt;SByte.Parse()&lt;/c&gt;  
 with InvariantCulture settings. Otherwise the operation requires an appropriate
 static conversion method on the input type.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.ToByte``1(``0)">
<summary>
 Converts the argument to byte. This is a direct conversion for all 
 primitive numeric types. For strings, the input is converted using &lt;c&gt;Byte.Parse()&lt;/c&gt; 
 with InvariantCulture settings. Otherwise the operation requires an appropriate
 static conversion method on the input type.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.PowInteger``1(``0,System.Int32)">
<summary>
 Overloaded power operator. If &lt;c&gt;n &gt; 0&lt;/c&gt; then equivalent to &lt;c&gt;x*...*x&lt;/c&gt; for &lt;c&gt;n&lt;/c&gt; occurrences of &lt;c&gt;x&lt;/c&gt;. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_Exponentiation``1(``0,``0)">
<summary>
 Overloaded power operator.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Truncate``1(``0)">
<summary>
 Overloaded truncate operator.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Tanh``1(``0)">
<summary>
 Hyperbolic tangent of the given number
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Tan``1(``0)">
<summary>
 Tangent of the given number
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Sinh``1(``0)">
<summary>
 Hyperbolic sine of the given number
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Sin``1(``0)">
<summary>
 Sine of the given number
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Cosh``1(``0)">
<summary>
 Hyperbolic cosine  of the given number
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Cos``1(``0)">
<summary>
 Cosine of the given number
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Sqrt``2(``0)">
<summary>
 Square root of the given number
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Log10``1(``0)">
<summary>
 Logarithm to base 10 of the given number
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Log``1(``0)">
<summary>
 Natural logarithm of the given number
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Round``1(``0)">
<summary>
 Round the given number
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Sign``1(``0)">
<summary>
 Sign of the given number
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Floor``1(``0)">
<summary>
 Floor of the given number
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Exp``1(``0)">
<summary>
 Exponential of the given number
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Ceiling``1(``0)">
<summary>
 Ceiling of the given number
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Atan2``2(``0,``0)">
<summary>
 Inverse tangent of &lt;c&gt;x/y&lt;/c&gt; where &lt;c&gt;x&lt;/c&gt; and &lt;c&gt;y&lt;/c&gt; are specified separately
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Atan``1(``0)">
<summary>
 Inverse tangent of the given number
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Asin``1(``0)">
<summary>
 Inverse sine of the given number
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Acos``1(``0)">
<summary>
 Inverse cosine of the given number
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Abs``1(``0)">
<summary>
 Absolute value of the given number
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.limitedHash``1(System.Int32,``0)">
<summary>
 A generic hash function. This function has the same behaviour as &apos;hash&apos;, 
 however the default structural hashing for F# union, record and tuple 
 types stops when the given limit of nodes is reached. The exact behaviour of 
 the function can be adjusted on a type-by-type basis by implementing 
 GetHashCode for each type.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Hash``1(``0)">
<summary>
 A generic hash function, designed to return equal hash values for items that are 
 equal according to the &quot;=&quot; operator. By default it will use structural hashing
 for F# union, record and tuple types, hashing the complete contents of the 
 type. The exact behaviour of the function can be adjusted on a 
 type-by-type basis by implementing GetHashCode for each type.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.SizeOf``1">
<summary>
 Returns the internal size of a type in bytes. For example, &lt;c&gt;sizeof&lt;int&gt;&lt;/c&gt; returns 4.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.TypeDefOf``1">
<summary>
 Generate a System.Type representation for a type definition. If the
 input type is a generic type instantiation then return the 
 generic type definition associated with all such instantiations.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.TypeOf``1">
<summary>
 Generate a System.Type runtime representation of a static type.
 The static type is still maintained on the value returned.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Using``2(``0,Microsoft.FSharp.Core.FSharpFunc`2{``0,``1})">
<summary>
 Clean up resources associated with the input object after the completion of the given function.
 Cleanup occurs even when an exception is raised by the protected
 code. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Lock``2(``0,Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.Unit,``1})">
<summary>
 Execute the function as a mutual-exlcusion region using the input value as a lock. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_RangeStep``2(``0,``1,``0)">
<summary>
 The standard overloaded skip range operator, e.g. &lt;c&gt;[n..skip..m]&lt;/c&gt; for lists, &lt;c&gt;seq {n..skip..m}&lt;/c&gt; for sequences
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_Range``1(``0,``0)">
<summary>
 The standard overloaded range operator, e.g. &lt;c&gt;[n..m]&lt;/c&gt; for lists, &lt;c&gt;seq {n..m}&lt;/c&gt; for sequences
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.ConsoleOut``1">
<summary>
 Reads the value of the property &lt;c&gt;System.Console.Out&lt;/c&gt;.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.ConsoleError``1">
<summary>
 Reads the value of the property &lt;c&gt;System.Console.Error&lt;/c&gt;. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.ConsoleIn``1">
<summary>
 Reads the value of the property &lt;c&gt;System.Console.In&lt;/c&gt;. 
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.Operators.NaNSingle">
<summary>
 Equivalent to &lt;c&gt;System.Single.NaN&lt;/c&gt;
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.Operators.InfinitySingle">
<summary>
 Equivalent to &lt;c&gt;System.Single.PositiveInfinity&lt;/c&gt;
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.Operators.NaN">
<summary>
 Equivalent to &lt;c&gt;System.Double.NaN&lt;/c&gt;
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.Operators.Infinity">
<summary>
 Equivalent to &lt;c&gt;System.Double.PositiveInfinity&lt;/c&gt;
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Exit``1(System.Int32)">
<summary>
 Exit the current hardware isolated process, if security settings permit,
 otherwise raise an exception. Calls &lt;c&gt;System.Environment.Exit&lt;/c&gt;.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.CreateSequence``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Builds a sequence using sequence expression syntax
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Not(System.Boolean)">
<summary>
 Negate a logical value. &lt;c&gt;not true&lt;/c&gt; equals &lt;c&gt;false&lt;/c&gt; and &lt;c&gt;not false&lt;/c&gt; equals &lt;c&gt;true&lt;/c&gt;
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_Append``1(Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Concatenate two lists.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Increment(Microsoft.FSharp.Core.FSharpRef{System.Int32})">
<summary>
 Increment a mutable reference cell containing an integer
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Decrement(Microsoft.FSharp.Core.FSharpRef{System.Int32})">
<summary>
 Decrement a mutable reference cell containing an integer
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_Dereference``1(Microsoft.FSharp.Core.FSharpRef{``0})">
<summary>
 Dereference a mutable reference cell
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_ColonEquals``1(Microsoft.FSharp.Core.FSharpRef{``0},``0)">
<summary>
 Assign to a mutable reference cell
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Ref``1(``0)">
<summary>
 Create a mutable reference cell
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Identity``1(``0)">
<summary>
 The identity function
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.InvalidOp``1(System.String)">
<summary>
 Throw an &lt;c&gt;InvalidOperationException&lt;/c&gt; exception
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.NullArg``1(System.String)">
<summary>
 Throw an &lt;c&gt;ArgumentNullException&lt;/c&gt; exception
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.InvalidArg``1(System.String,System.String)">
<summary>
 Throw an &lt;c&gt;ArgumentException&lt;/c&gt; exception
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.FailWith``1(System.String)">
<summary>
 Throw a &lt;c&gt;FailureException&lt;/c&gt; exception
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Box``1(``0)">
<summary>
 Boxes a strongly typed value.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Unbox``1(System.Object)">
<summary>
 Unboxes a strongly typed value. This is the inverse of &lt;c&gt;box&lt;/c&gt;, unbox&lt;t&gt;(box&lt;t&gt; a) equals a.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Ignore``1(``0)">
<summary>
 Ignore the passed value. This is often used to throw away results of a computation.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Min``1(``0,``0)">
<summary>
 Minimum based on generic comparison
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Max``1(``0,``0)">
<summary>
 Maximum based on generic comparison
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Compare``1(``0,``0)">
<summary>
 Generic comparison
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Snd``2(System.Tuple`2{``0,``1})">
<summary>
 Return the second element of a tuple, &lt;c&gt;snd (a,b) = b&lt;/c&gt;.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Fst``2(System.Tuple`2{``0,``1})">
<summary>
 Return the first element of a tuple, &lt;c&gt;fst (a,b) = a&lt;/c&gt;.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.FailurePattern(System.Exception)">
<summary>
 Matches &lt;c&gt;System.Exception&lt;/c&gt; objects whose runtime type is precisely &lt;c&gt;System.Exception&lt;/c&gt;
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Failure(System.String)">
<summary>
 Builds a &lt;c&gt;System.Exception&lt;/c&gt; object 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Reraise``1">
<summary>
 Rethrows an exception. This should only be used when handling an exception
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Rethrow``1">
<summary>
 Rethrows an exception. This should only be used when handling an exception
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Raise``1(System.Exception)">
<summary>
 Raises an exception
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_Concatenate(System.String,System.String)">
<summary>
 Concatenate two strings. The operator &apos;+&apos; may also be used.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.DefaultArg``1(Microsoft.FSharp.Core.FSharpOption{``0},``0)">
<summary>
 Used to specify a default value for an optional argument in the implementation of a function
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_PipeLeft3``4(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,Microsoft.FSharp.Core.FSharpFunc`2{``2,``3}}},``0,``1,``2)">
<summary>
 Apply a function to three values, the values being a triple on the right, the function on the left
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_PipeLeft2``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,``2}},``0,``1)">
<summary>
 Apply a function to two values, the values being a pair on the right, the function on the left
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_PipeLeft``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},``0)">
<summary>
 Apply a function to a value, the value being on the right, the function on the left
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_PipeRight3``4(``0,``1,``2,Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,Microsoft.FSharp.Core.FSharpFunc`2{``2,``3}}})">
<summary>
 Apply a function to three values, the values being a triple on the left, the function on the right
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_PipeRight2``3(``0,``1,Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,``2}})">
<summary>
 Apply a function to two values, the values being a pair on the left, the function on the right
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_PipeRight``2(``0,Microsoft.FSharp.Core.FSharpFunc`2{``0,``1})">
<summary>
 Apply a function to a value, the value being on the left, the function on the right
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_ComposeLeft``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},Microsoft.FSharp.Core.FSharpFunc`2{``2,``0})">
<summary>
 Compose two functions, the function on the right being applied first
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_ComposeRight``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},Microsoft.FSharp.Core.FSharpFunc`2{``1,``2})">
<summary>
 Compose two functions, the function on the left being applied first
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_Inequality``1(``0,``0)">
<summary>
Structural inequality
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_Equality``1(``0,``0)">
<summary>
Structural equality
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_LessThanOrEqual``1(``0,``0)">
<summary>
Structural less-than-or-equal comparison
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_GreaterThanOrEqual``1(``0,``0)">
<summary>
Structural greater-than-or-equal
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_GreaterThan``1(``0,``0)">
<summary>
 Structural greater-than
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_LessThan``1(``0,``0)">
<summary>
 Structural less-than comparison
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_UnaryPlus``1(``0)">
<summary>
 Overloaded prefix=plus operator
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_LogicalNot``1(``0)">
<summary>
 Overloaded logical-NOT operator
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_RightShift``1(``0,System.Int32)">
<summary>
 Overloaded byte-shift right operator by a specified number of bits
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_LeftShift``1(``0,System.Int32)">
<summary>
 Overloaded byte-shift left operator by a specified number of bits
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_ExclusiveOr``1(``0,``0)">
<summary>
 Overloaded logical-XOR operator
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_BitwiseOr``1(``0,``0)">
<summary>
 Overloaded logical-OR operator
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_BitwiseAnd``1(``0,``0)">
<summary>
 Overloaded logical-AND operator
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_Modulus``3(``0,``1)">
<summary>
 Overloaded modulo operator
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_Division``3(``0,``1)">
<summary>
 Overloaded division operator
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_Multiply``3(``0,``1)">
<summary>
 Overloaded multiplication operator
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_Subtraction``3(``0,``1)">
<summary>
 Overloaded subtraction operator
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_Addition``3(``0,``1)">
<summary>
 Overloaded addition operator
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_UnaryNegation``1(``0)">
<summary>
 Overloaded unary negation.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Checked.ToChar``1(``0)">
<summary>
 Converts the argument to character. Numeric inputs are converted using a checked 
 conversion according to the UTF-16 encoding for characters. String inputs must 
 be exactly one character long. For other input types the operation requires an 
 appropriate static conversion method on the input type.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Checked.ToUIntPtr``1(``0)">
<summary>
 Converts the argument to byte. This is a direct, checked conversion for all 
 primitive numeric types. Otherwise the operation requires an appropriate
 static conversion method on the input type.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Checked.ToIntPtr``1(``0)">
<summary>
 Converts the argument to byte. This is a direct, checked conversion for all 
 primitive numeric types. Otherwise the operation requires an appropriate
 static conversion method on the input type.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Checked.ToUInt64``1(``0)">
<summary>
 Converts the argument to byte. This is a direct, checked conversion for all 
 primitive numeric types. For strings, the input is converted using &lt;c&gt;System.UInt64.Parse()&lt;/c&gt; 
 with InvariantCulture settings. Otherwise the operation requires an appropriate
 static conversion method on the input type.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Checked.ToInt64``1(``0)">
<summary>
 Converts the argument to byte. This is a direct, checked conversion for all 
 primitive numeric types. For strings, the input is converted using &lt;c&gt;System.Int64.Parse()&lt;/c&gt; 
 with InvariantCulture settings. Otherwise the operation requires an appropriate
 static conversion method on the input type.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Checked.ToUInt32``1(``0)">
<summary>
 Converts the argument to byte. This is a direct, checked conversion for all 
 primitive numeric types. For strings, the input is converted using &lt;c&gt;System.UInt32.Parse()&lt;/c&gt; 
 with InvariantCulture settings. Otherwise the operation requires an appropriate
 static conversion method on the input type.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Checked.ToInt32``1(``0)">
<summary>
 Converts the argument to byte. This is a direct, checked conversion for all 
 primitive numeric types. For strings, the input is converted using &lt;c&gt;System.Int32.Parse()&lt;/c&gt; 
 with InvariantCulture settings. Otherwise the operation requires an appropriate
 static conversion method on the input type.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Checked.ToInt``1(``0)">
<summary>
 Converts the argument to byte. This is a direct, checked conversion for all 
 primitive numeric types. For strings, the input is converted using &lt;c&gt;System.Int32.Parse()&lt;/c&gt; 
 with InvariantCulture settings. Otherwise the operation requires an appropriate
 static conversion method on the input type.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Checked.ToUInt16``1(``0)">
<summary>
 Converts the argument to byte. This is a direct, checked conversion for all 
 primitive numeric types. For strings, the input is converted using &lt;c&gt;System.UInt16.Parse()&lt;/c&gt; 
 with InvariantCulture settings. Otherwise the operation requires an appropriate
 static conversion method on the input type.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Checked.ToInt16``1(``0)">
<summary>
 Converts the argument to byte. This is a direct, checked conversion for all 
 primitive numeric types. For strings, the input is converted using &lt;c&gt;System.Int16.Parse()&lt;/c&gt; 
 with InvariantCulture settings. Otherwise the operation requires an appropriate
 static conversion method on the input type.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Checked.ToSByte``1(``0)">
<summary>
 Converts the argument to byte. This is a direct, checked conversion for all 
 primitive numeric types. For strings, the input is converted using &lt;c&gt;System.SByte.Parse()&lt;/c&gt; 
 with InvariantCulture settings. Otherwise the operation requires an appropriate
 static conversion method on the input type.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Checked.ToByte``1(``0)">
<summary>
 Converts the argument to byte. This is a direct, checked conversion for all 
 primitive numeric types. For strings, the input is converted using &lt;c&gt;System.Byte.Parse()&lt;/c&gt; 
 with InvariantCulture settings. Otherwise the operation requires an appropriate
 static conversion method on the input type.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Checked.op_Multiply``3(``0,``1)">
<summary>
 Overloaded multiplication operator (checks for overflow)
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Checked.op_Addition``3(``0,``1)">
<summary>
 Overloaded addition operator (checks for overflow)
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Checked.op_Subtraction``3(``0,``1)">
<summary>
 Overloaded subtraction operator (checks for overflow)
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Checked.op_UnaryNegation``1(``0)">
<summary>
 Overloaded unary negation (checks for overflow)
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.Operators.Checked">
<summary>
 This module contains the basic arithmetic operations with overflow checks.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Unchecked.Hash``1(``0)">
<summary>
 Perform generic hashing on a value where the type of the value is not 
 statically required to satisfy the &apos;equality&apos; constraint. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Unchecked.Equals``1(``0,``0)">
<summary>
 Perform generic equality on two values where the type of the values is not 
 statically required to satisfy the &apos;equality&apos; constraint. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Unchecked.Compare``1(``0,``0)">
<summary>
 Perform generic comparison on two values where the type of the values is not 
 statically required to have the &apos;comparison&apos; constraint. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Unchecked.DefaultOf``1">
<summary>
 Generate a defult value for any type. This is null for reference types, 
 For structs, this is struct value where all fields have the default value. 
 This function is unsafe in the sense that some F# values do not have proper &lt;c&gt;null&lt;/c&gt; values.
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.Operators.Unchecked">
<summary>
 This module contains basic operations which do not apply runtime and/or static checks
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.PowGeneric``1(``0,Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``0,``0}},``0,System.Int32)">
<summary>
 This is a library intrinsic. Calls to this function may be generated by uses of the generic &apos;pown&apos; operator 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.PowDecimal(System.Decimal,System.Int32)">
<summary>
 This is a library intrinsic. Calls to this function may be generated by uses of the generic &apos;pown&apos; operator on values of type &apos;decimal&apos;
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.PowDouble(System.Double,System.Int32)">
<summary>
 This is a library intrinsic. Calls to this function may be generated by uses of the generic &apos;pown&apos; operator on values of type &apos;float&apos;
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.PowSingle(System.Single,System.Int32)">
<summary>
 This is a library intrinsic. Calls to this function may be generated by uses of the generic &apos;pown&apos; operator on values of type &apos;float32&apos;
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.PowUIntPtr(System.UIntPtr,System.Int32)">
<summary>
 This is a library intrinsic. Calls to this function may be generated by uses of the generic &apos;pown&apos; operator on values of type &apos;unativeint&apos;
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.PowIntPtr(System.IntPtr,System.Int32)">
<summary>
 This is a library intrinsic. Calls to this function may be generated by uses of the generic &apos;pown&apos; operator on values of type &apos;nativeint&apos;
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.PowUInt64(System.UInt64,System.Int32)">
<summary>
 This is a library intrinsic. Calls to this function may be generated by uses of the generic &apos;pown&apos; operator on values of type &apos;uint64&apos;
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.PowInt64(System.Int64,System.Int32)">
<summary>
 This is a library intrinsic. Calls to this function may be generated by uses of the generic &apos;pown&apos; operator on values of type &apos;int64&apos;
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.PowUInt32(System.UInt32,System.Int32)">
<summary>
 This is a library intrinsic. Calls to this function may be generated by uses of the generic &apos;pown&apos; operator on values of type &apos;uint32&apos;
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.PowInt32(System.Int32,System.Int32)">
<summary>
 This is a library intrinsic. Calls to this function may be generated by uses of the generic &apos;pown&apos; operator on values of type &apos;int32&apos;
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.PowUInt16(System.UInt16,System.Int32)">
<summary>
 This is a library intrinsic. Calls to this function may be generated by uses of the generic &apos;pown&apos; operator on values of type &apos;uint16&apos;
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.PowInt16(System.Int16,System.Int32)">
<summary>
 This is a library intrinsic. Calls to this function may be generated by uses of the generic &apos;pown&apos; operator on values of type &apos;int16&apos;
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.PowSByte(System.SByte,System.Int32)">
<summary>
 This is a library intrinsic. Calls to this function may be generated by uses of the generic &apos;pown&apos; operator on values of type &apos;sbyte&apos;
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.PowByte(System.Byte,System.Int32)">
<summary>
 This is a library intrinsic. Calls to this function may be generated by uses of the generic &apos;pown&apos; operator on values of type &apos;byte&apos;
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.PowDynamic``1(``0,``0)">
<summary>
 This is a library intrinsic. Calls to this function may be generated by evaluating quotations.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.TanhDynamic``1(``0)">
<summary>
 This is a library intrinsic. Calls to this function may be generated by evaluating quotations.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.TanDynamic``1(``0)">
<summary>
 This is a library intrinsic. Calls to this function may be generated by evaluating quotations.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.SinhDynamic``1(``0)">
<summary>
 This is a library intrinsic. Calls to this function may be generated by evaluating quotations.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.SinDynamic``1(``0)">
<summary>
 This is a library intrinsic. Calls to this function may be generated by evaluating quotations.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.CoshDynamic``1(``0)">
<summary>
 This is a library intrinsic. Calls to this function may be generated by evaluating quotations.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.CosDynamic``1(``0)">
<summary>
 This is a library intrinsic. Calls to this function may be generated by evaluating quotations.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.SqrtDynamic``2(``0)">
<summary>
 This is a library intrinsic. Calls to this function may be generated by evaluating quotations.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.Log10Dynamic``1(``0)">
<summary>
 This is a library intrinsic. Calls to this function may be generated by evaluating quotations.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.LogDynamic``1(``0)">
<summary>
 This is a library intrinsic. Calls to this function may be generated by evaluating quotations.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.SignDynamic``1(``0)">
<summary>
 This is a library intrinsic. Calls to this function may be generated by evaluating quotations.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.RoundDynamic``1(``0)">
<summary>
 This is a library intrinsic. Calls to this function may be generated by evaluating quotations.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.TruncateDynamic``1(``0)">
<summary>
 This is a library intrinsic. Calls to this function may be generated by evaluating quotations.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.FloorDynamic``1(``0)">
<summary>
 This is a library intrinsic. Calls to this function may be generated by evaluating quotations.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.ExpDynamic``1(``0)">
<summary>
 This is a library intrinsic. Calls to this function may be generated by evaluating quotations.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.CeilingDynamic``1(``0)">
<summary>
 This is a library intrinsic. Calls to this function may be generated by evaluating quotations.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.Atan2Dynamic``2(``0,``0)">
<summary>
 This is a library intrinsic. Calls to this function may be generated by evaluating quotations.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.AtanDynamic``1(``0)">
<summary>
 This is a library intrinsic. Calls to this function may be generated by evaluating quotations.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.AsinDynamic``1(``0)">
<summary>
 This is a library intrinsic. Calls to this function may be generated by evaluating quotations.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.AcosDynamic``1(``0)">
<summary>
 This is a library intrinsic. Calls to this function may be generated by evaluating quotations.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.AbsDynamic``1(``0)">
<summary>
 This is a library intrinsic. Calls to this function may be generated by evaluating quotations.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.RangeStepGeneric``2(``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,Microsoft.FSharp.Core.FSharpFunc`2{``0,``1}},``1,``0,``1)">
<summary>
 Generate a range of values using the given zero, add, start, step and stop values
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.RangeGeneric``1(``0,Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``0,``0}},``0,``0)">
<summary>
 Generate a range of values using the given zero, add, start, step and stop values
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.RangeChar(System.Char,System.Char)">
<summary>
 Generate a range of char values
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.RangeByte(System.Byte,System.Byte,System.Byte)">
<summary>
 Generate a range of byte values
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.RangeSByte(System.SByte,System.SByte,System.SByte)">
<summary>
 Generate a range of sbyte values
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.RangeUInt16(System.UInt16,System.UInt16,System.UInt16)">
<summary>
 Generate a range of uint16 values
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.RangeInt16(System.Int16,System.Int16,System.Int16)">
<summary>
 Generate a range of int16 values
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.RangeUIntPtr(System.UIntPtr,System.UIntPtr,System.UIntPtr)">
<summary>
 Generate a range of unativeint values
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.RangeIntPtr(System.IntPtr,System.IntPtr,System.IntPtr)">
<summary>
 Generate a range of nativeint values
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.RangeUInt32(System.UInt32,System.UInt32,System.UInt32)">
<summary>
 Generate a range of uint32 values
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.RangeUInt64(System.UInt64,System.UInt64,System.UInt64)">
<summary>
 Generate a range of uint64 values
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.RangeInt64(System.Int64,System.Int64,System.Int64)">
<summary>
 Generate a range of int64 values
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.RangeSingle(System.Single,System.Single,System.Single)">
<summary>
 Generate a range of float32 values
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.RangeDouble(System.Double,System.Double,System.Double)">
<summary>
 Generate a range of float values
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.RangeInt32(System.Int32,System.Int32,System.Int32)">
<summary>
 Generate a range of integers  
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.GetStringSlice(System.String,Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
<summary>
 Get a slice from a string
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.SetArraySlice4D``1(``0[,,,]`1,Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},``0[,,,]`1)">
<summary>
 Set a slice of an array
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.GetArraySlice4D``1(``0[,,,]`1,Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
<summary>
 Get a slice of an array
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.SetArraySlice3D``1(``0[,,]`1,Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},``0[,,]`1)">
<summary>
 Set a slice of an array
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.GetArraySlice3D``1(``0[,,]`1,Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
<summary>
 Get a slice of an array
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.SetArraySlice2D``1(``0[,]`1,Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},``0[,]`1)">
<summary>
 Set a slice of an array
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.GetArraySlice2D``1(``0[,]`1,Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
<summary>
 Get a slice of an array
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.SetArraySlice``1(``0[]`1,Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},``0[]`1)">
<summary>
 Set a slice of an array
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.OperatorIntrinsics.GetArraySlice``1(``0[]`1,Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
<summary>
 Get a slice of an array
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.Operators.OperatorIntrinsics">
<summary>
 A module of compiler intrinsic functions for efficient implementations of F# integer ranges
 and dynamic invocations of other F# operators
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.Operators">
<summary>
 Basic F# Operators. This module is automatically opened in all F# code.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.OptimizedClosures.FSharpFunc`6.Invoke(`0,`1,`2,`3,`4)">
<summary>
 Invoke an F# first class function value that accepts five curried arguments 
 without intervening execution
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.OptimizedClosures.FSharpFunc`6.Adapt(Microsoft.FSharp.Core.FSharpFunc`2{`0,Microsoft.FSharp.Core.FSharpFunc`2{`1,Microsoft.FSharp.Core.FSharpFunc`2{`2,Microsoft.FSharp.Core.FSharpFunc`2{`3,Microsoft.FSharp.Core.FSharpFunc`2{`4,`5}}}}})">
<summary>
 Adapt an F# first class function value to be an optimized function value that can 
 accept five curried arguments without intervening execution. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.OptimizedClosures.FSharpFunc`6..ctor">
<summary>
 Construct an optimized function value that can accept five curried 
 arguments without intervening execution.
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.OptimizedClosures.FSharpFunc`6">
<summary>
 The CLI type used to represent F# function values that accept five curried arguments 
 without intervening execution. This type should not typically used directly from 
 either F# code or from other CLI languages.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.OptimizedClosures.FSharpFunc`5.Invoke(`0,`1,`2,`3)">
<summary>
 Invoke an F# first class function value that accepts four curried arguments 
 without intervening execution
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.OptimizedClosures.FSharpFunc`5.Adapt(Microsoft.FSharp.Core.FSharpFunc`2{`0,Microsoft.FSharp.Core.FSharpFunc`2{`1,Microsoft.FSharp.Core.FSharpFunc`2{`2,Microsoft.FSharp.Core.FSharpFunc`2{`3,`4}}}})">
<summary>
 Adapt an F# first class function value to be an optimized function value that can 
 accept four curried arguments without intervening execution. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.OptimizedClosures.FSharpFunc`5..ctor">
<summary>
 Construct an optimized function value that can accept four curried 
 arguments without intervening execution.
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.OptimizedClosures.FSharpFunc`5">
<summary>
 The CLI type used to represent F# function values that accept four curried arguments 
 without intervening execution. This type should not typically used directly from 
 either F# code or from other CLI languages.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.OptimizedClosures.FSharpFunc`4.Invoke(`0,`1,`2)">
<summary>
 Invoke an F# first class function value that accepts three curried arguments 
 without intervening execution
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.OptimizedClosures.FSharpFunc`4.Adapt(Microsoft.FSharp.Core.FSharpFunc`2{`0,Microsoft.FSharp.Core.FSharpFunc`2{`1,Microsoft.FSharp.Core.FSharpFunc`2{`2,`3}}})">
<summary>
 Adapt an F# first class function value to be an optimized function value that can 
 accept three curried arguments without intervening execution. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.OptimizedClosures.FSharpFunc`4..ctor">
<summary>
 Construct an optimized function value that can accept three curried 
 arguments without intervening execution.
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.OptimizedClosures.FSharpFunc`4">
<summary>
 The CLI type used to represent F# function values that accept
 three iterated (curried) arguments without intervening execution. This type should not
 typically used directly from either F# code or from other CLI languages.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.OptimizedClosures.FSharpFunc`3.Invoke(`0,`1)">
<summary>
 Invoke the optimized function value with two curried arguments 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.OptimizedClosures.FSharpFunc`3.Adapt(Microsoft.FSharp.Core.FSharpFunc`2{`0,Microsoft.FSharp.Core.FSharpFunc`2{`1,`2}})">
<summary>
 Adapt an F# first class function value to be an optimized function value that can 
 accept two curried arguments without intervening execution. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.OptimizedClosures.FSharpFunc`3..ctor">
<summary>
 Construct an optimized function value that can accept two curried 
 arguments without intervening execution.
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.OptimizedClosures.FSharpFunc`3">
<summary>
 The CLI type used to represent F# function values that accept
 two iterated (curried) arguments without intervening execution. This type should not
 typically used directly from either F# code or from other CLI languages.
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.OptimizedClosures">
<summary>
 An implementation module used to hold some private implementations of function
 value invocation.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.OptionModule.CompatibleToList``1(Microsoft.FSharp.Core.FSharpOption{``0})">

</member>
<member name="M:Microsoft.FSharp.Core.OptionModule.CompatibleToArray``1(Microsoft.FSharp.Core.FSharpOption{``0})">

</member>
<member name="M:Microsoft.FSharp.Core.OptionModule.ToList``1(Microsoft.FSharp.Core.FSharpOption{``0})">
<summary>
 Convert the option to a list of length 0 or 1
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.OptionModule.ToArray``1(Microsoft.FSharp.Core.FSharpOption{``0})">
<summary>
 Convert the option to an array of length 0 or 1
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.OptionModule.Bind``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpOption{``1}},Microsoft.FSharp.Core.FSharpOption{``0})">
 <c>bind f inp</c> evaluates to <c>match inp with None -> None | Some x -> f x</c>
</member>
<member name="M:Microsoft.FSharp.Core.OptionModule.Map``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},Microsoft.FSharp.Core.FSharpOption{``0})">
 <c>map f inp</c> evaluates to <c>match inp with None -> None | Some x -> Some (f x)</c>
</member>
<member name="M:Microsoft.FSharp.Core.OptionModule.Iterate``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpOption{``0})">
 <c>iter f inp</c> executes <c>match inp with None -> () | Some x -> f x</c>
</member>
<member name="M:Microsoft.FSharp.Core.OptionModule.ForAll``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Boolean},Microsoft.FSharp.Core.FSharpOption{``0})">
 <c>forall p inp" evaluates to "match inp with None -> true | Some x -> p x</c>
</member>
<member name="M:Microsoft.FSharp.Core.OptionModule.Exists``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Boolean},Microsoft.FSharp.Core.FSharpOption{``0})">
 <c>exists p inp</c> evaluates to <c>match inp with None -> false | Some x -> p x</c>
</member>
<member name="M:Microsoft.FSharp.Core.OptionModule.FoldBack``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,``1}},Microsoft.FSharp.Core.FSharpOption{``0},``1)">
 <c>fold f inp s</c> evaluates to "match inp with None -> s | Some x -> f x s"
</member>
<member name="M:Microsoft.FSharp.Core.OptionModule.Fold``2(Microsoft.FSharp.Core.FSharpFunc`2{``1,Microsoft.FSharp.Core.FSharpFunc`2{``0,``1}},``1,Microsoft.FSharp.Core.FSharpOption{``0})">
 <c>fold f s inp</c> evaluates to <c>match inp with None -> s | Some x -> f s x</c>
</member>
<member name="M:Microsoft.FSharp.Core.OptionModule.Count``1(Microsoft.FSharp.Core.FSharpOption{``0})">
 <c>count inp</c> evaluates to <c>match inp with None -> 0 | Some _ -> 1</c>
</member>
<member name="M:Microsoft.FSharp.Core.OptionModule.GetValue``1(Microsoft.FSharp.Core.FSharpOption{``0})">
<summary>
 Gets the value associated with the option.  If the option is None then
 raises ArgumentException
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.OptionModule.IsNone``1(Microsoft.FSharp.Core.FSharpOption{``0})">
<summary>
 Returns true if the option is None
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.OptionModule.IsSome``1(Microsoft.FSharp.Core.FSharpOption{``0})">
<summary>
 Returns true if the option is not None
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.OptionModule">
<summary>
 Basic operations on options.  
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.PrintfModule.TextWriterFormat`1">
<summary>
 Represents a statically-analyzed format associated with writing to a &lt;c&gt;System.IO.TextWriter&lt;/c&gt;. The type parameter indicates the
 arguments and return type of the format operation.
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.PrintfModule.StringFormat`1">
<summary>
 Represents a statically-analyzed format when formatting builds a string. The type parameter indicates the
 arguments and return type of the format operation.
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.PrintfModule.BuilderFormat`1">
<summary>
 Represents a statically-analyzed format associated with writing to a &lt;c&gt;System.Text.StringBuilder&lt;/c&gt;. The type parameter indicates the
 arguments and return type of the format operation.
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.PrintfModule.TextWriterFormat`2">
<summary>
 Represents a statically-analyzed format associated with writing to a &lt;c&gt;System.IO.TextWriter&lt;/c&gt;. The first type parameter indicates the
 arguments of the format operation and the last the overall return type.
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.PrintfModule.StringFormat`2">
<summary>
 Represents a statically-analyzed format when formatting builds a string. The first type parameter indicates the
 arguments of the format operation and the last the overall return type.
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.PrintfModule.BuilderFormat`2">
<summary>
 Represents a statically-analyzed format associated with writing to a &lt;c&gt;System.Text.StringBuilder&lt;/c&gt;. The first type parameter indicates the
 arguments of the format operation and the last the overall return type.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.PrintfModule.PrintFormatToStringThenFail``2(Microsoft.FSharp.Core.PrintfFormat{``0,Microsoft.FSharp.Core.Unit,System.String,``1})">
<summary>
 Print to a string buffer and raise an exception with the given
 result. Helper printers must return strings.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.PrintfModule.PrintFormatToStringThen``2(Microsoft.FSharp.Core.FSharpFunc`2{System.String,``0},Microsoft.FSharp.Core.PrintfFormat{``1,Microsoft.FSharp.Core.Unit,System.String,``0})">
<summary>
 sprintf, but call the given &apos;final&apos; function to generate the result.
 See &lt;c&gt;kprintf&lt;/c&gt;.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.PrintfModule.PrintFormatThen``2(Microsoft.FSharp.Core.FSharpFunc`2{System.String,``0},Microsoft.FSharp.Core.PrintfFormat{``1,Microsoft.FSharp.Core.Unit,System.String,``0})">
<summary>
 printf, but call the given &apos;final&apos; function to generate the result.
 For example, these let the printing force a flush after all output has 
 been entered onto the channel, but not before. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.PrintfModule.PrintFormatToTextWriterThen``2(Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.Unit,``0},System.IO.TextWriter,Microsoft.FSharp.Core.PrintfFormat{``1,System.IO.TextWriter,Microsoft.FSharp.Core.Unit,``0})">
<summary>
 fprintf, but call the given &apos;final&apos; function to generate the result.
 See &lt;c&gt;kprintf&lt;/c&gt;.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.PrintfModule.PrintFormatToStringBuilderThen``2(Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.Unit,``0},System.Text.StringBuilder,Microsoft.FSharp.Core.PrintfFormat{``1,System.Text.StringBuilder,Microsoft.FSharp.Core.Unit,``0})">
<summary>
 bprintf, but call the given &apos;final&apos; function to generate the result.
 See &lt;c&gt;kprintf&lt;/c&gt;.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.PrintfModule.PrintFormatToStringThen``1(Microsoft.FSharp.Core.PrintfFormat{``0,Microsoft.FSharp.Core.Unit,System.String,System.String})">
<summary>
 Print to a string via an internal string buffer and return 
 the result as a string.  Helper printers must return strings.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.PrintfModule.PrintFormatLine``1(Microsoft.FSharp.Core.PrintfFormat{``0,System.IO.TextWriter,Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
<summary>
 Formatted printing to stdout, adding a newline 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.PrintfModule.PrintFormat``1(Microsoft.FSharp.Core.PrintfFormat{``0,System.IO.TextWriter,Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
<summary>
 Formatted printing to stdout
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.PrintfModule.PrintFormatLineToError``1(Microsoft.FSharp.Core.PrintfFormat{``0,System.IO.TextWriter,Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
<summary>
 Formatted printing to stderr, adding a newline 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.PrintfModule.PrintFormatToError``1(Microsoft.FSharp.Core.PrintfFormat{``0,System.IO.TextWriter,Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
<summary>
 Formatted printing to stderr
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.PrintfModule.PrintFormatLineToTextWriter``1(System.IO.TextWriter,Microsoft.FSharp.Core.PrintfFormat{``0,System.IO.TextWriter,Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
<summary>
 Print to a text writer, adding a newline
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.PrintfModule.PrintFormatToTextWriter``1(System.IO.TextWriter,Microsoft.FSharp.Core.PrintfFormat{``0,System.IO.TextWriter,Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
<summary>
 Print to a text writer 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.PrintfModule.PrintFormatToStringBuilder``1(System.Text.StringBuilder,Microsoft.FSharp.Core.PrintfFormat{``0,System.Text.StringBuilder,Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
<summary>
 Print to a &lt;c&gt;System.Text.StringBuilder&lt;/c&gt;
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.PrintfModule">
<summary>
 Extensible printf-style formatting for numbers and other datatypes

 Format specifications are strings with &quot;%&quot; markers indicating format 
 placeholders. Format placeholders consist of:
  &lt;c&gt;
    %[flags][width][.precision][type]
  &lt;/c&gt;
 where the type is interpreted as follows:
  &lt;c&gt;
     %b:         bool, formatted as &quot;true&quot; or &quot;false&quot;
     %s:         string, formatted as its unescaped contents
     %d, %i:     any basic integer type formatted as a decimal integer, signed if the basic integer type is signed.
     %u:         any basic integer type formatted as an unsigned decimal integer
     %x, %X, %o: any basic integer type formatted as an unsigned hexadecimal 
                 (a-f)/Hexadecimal (A-F)/Octal integer
 
     %e, %E, %f, %F, %g, %G: 
                 any basic floating point type (float,float32) formatted
                 using a C-style floating point format specifications, i.e
 
     %e, %E: Signed value having the form [-]d.dddde[sign]ddd where 
                 d is a single decimal digit, dddd is one or more decimal
                 digits, ddd is exactly three decimal digits, and sign 
                 is + or -
 
     %f:     Signed value having the form [-]dddd.dddd, where dddd is one
                 or more decimal digits. The number of digits before the 
                 decimal point depends on the magnitude of the number, and 
                 the number of digits after the decimal point depends on 
                 the requested precision.
 
     %g, %G: Signed value printed in f or e format, whichever is 
                 more compact for the given value and precision.
 
 
    %M:      System.Decimal value
 
    %O:      Any value, printed by boxing the object and using it&apos;s ToString method(s)
 
    %A:      Any value, printed with the default layout settings 
 
    %a:      A general format specifier, requires two arguments:
                 (1) a function which accepts two arguments:
                     (a) a context parameter of the appropriate type for the
                         given formatting function (e.g. an #System.IO.TextWriter)
                     (b) a value to print
                         and which either outputs or returns appropriate text.
 
                 (2) the particular value to print
 
 
    %t:      A general format specifier, requires one argument:
                 (1) a function which accepts a context parameter of the
                     appropriate type for the given formatting function (e.g. 
                     an System.IO.TextWriter)and which either outputs or returns 
                     appropriate text.

  Basic integer types are:
     byte,sbyte,int16,uint16,int32,uint32,int64,uint64,nativeint,unativeint
  Basic floating point types are:
     float, float32
 &lt;/c&gt;
 The optional width is an integer indicating the minimal width of the
 result. For instance, %6d prints an integer, prefixing it with spaces
 to fill at least 6 characters. If width is &apos;*&apos;, then an extra integer
 argument is taken to specify the corresponding width.
 &lt;c&gt;
     any number
     &apos;*&apos;: 
 &lt;/c&gt;
 Valid flags are:
 &lt;c&gt;
     0: add zeros instead of spaces to make up the required width
     &apos;-&apos;: left justify the result within the width specified
     &apos;+&apos;: add a &apos;+&apos; character if the number is positive (to match a &apos;-&apos; sign 
          for negatives)
     &apos; &apos;: add an extra space if the number is positive (to match a &apos;-&apos; 
              sign for negatives)
 &lt;/c&gt;
 The printf &apos;#&apos; flag is invalid and a compile-time error will be reported if it is used.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.SR.GetString3(System.String,System.String,System.String,System.String)">

</member>
<member name="M:Microsoft.FSharp.Core.SR.GetString2(System.String,System.String,System.String)">

</member>
<member name="M:Microsoft.FSharp.Core.SR.GetString1(System.String,System.String)">

</member>
<member name="M:Microsoft.FSharp.Core.SR.GetString(System.String)">

</member>
<member name="P:Microsoft.FSharp.Core.SR.controlContinuationInvokedMultipleTimes">

</member>
<member name="P:Microsoft.FSharp.Core.SR.QtypeArgumentOutOfRange">

</member>
<member name="P:Microsoft.FSharp.Core.SR.QfailedToBindAssembly">

</member>
<member name="P:Microsoft.FSharp.Core.SR.QcannotBindFunction">

</member>
<member name="P:Microsoft.FSharp.Core.SR.QcannotBindProperty">

</member>
<member name="P:Microsoft.FSharp.Core.SR.QcannotBindToMethod">

</member>
<member name="P:Microsoft.FSharp.Core.SR.QcannotTakeAddress">

</member>
<member name="P:Microsoft.FSharp.Core.SR.QillFormedAppOrLet">

</member>
<member name="P:Microsoft.FSharp.Core.SR.QwrongNumOfTypeArgs">

</member>
<member name="P:Microsoft.FSharp.Core.SR.QfailedToBindTypeInAssembly">

</member>
<member name="P:Microsoft.FSharp.Core.SR.QfailedToBindConstructor">

</member>
<member name="P:Microsoft.FSharp.Core.SR.QfailedToBindField">

</member>
<member name="P:Microsoft.FSharp.Core.SR.QfailedToBindProperty">

</member>
<member name="P:Microsoft.FSharp.Core.SR.QparentCannotBeNull">

</member>
<member name="P:Microsoft.FSharp.Core.SR.QreadingSetOnly">

</member>
<member name="P:Microsoft.FSharp.Core.SR.QwritingGetOnly">

</member>
<member name="P:Microsoft.FSharp.Core.SR.QnonStaticNoReceiverObject">

</member>
<member name="P:Microsoft.FSharp.Core.SR.QstaticWithReceiverObject">

</member>
<member name="P:Microsoft.FSharp.Core.SR.QunionNeedsDiffNumArgs">

</member>
<member name="P:Microsoft.FSharp.Core.SR.QincompatibleRecordLength">

</member>
<member name="P:Microsoft.FSharp.Core.SR.QtupleAccessOutOfRange">

</member>
<member name="P:Microsoft.FSharp.Core.SR.QtupleLengthsDiffer">

</member>
<member name="P:Microsoft.FSharp.Core.SR.QinvalidFuncType">

</member>
<member name="P:Microsoft.FSharp.Core.SR.QincorrectInstanceType">

</member>
<member name="P:Microsoft.FSharp.Core.SR.QincorrectType">

</member>
<member name="P:Microsoft.FSharp.Core.SR.QincorrectNumArgs">

</member>
<member name="P:Microsoft.FSharp.Core.SR.QtmmExprHasWrongType">

</member>
<member name="P:Microsoft.FSharp.Core.SR.QtmmRaw">

</member>
<member name="P:Microsoft.FSharp.Core.SR.QtmmFunTypeNotMatchDelegate">

</member>
<member name="P:Microsoft.FSharp.Core.SR.QtmmBodyMustBeUnit">

</member>
<member name="P:Microsoft.FSharp.Core.SR.QtmmGuardMustBeBool">

</member>
<member name="P:Microsoft.FSharp.Core.SR.QtmmLoopBodyMustBeLambdaTakingInteger">

</member>
<member name="P:Microsoft.FSharp.Core.SR.QtmmLowerUpperBoundMustBeInt">

</member>
<member name="P:Microsoft.FSharp.Core.SR.QtmmBadFieldType">

</member>
<member name="P:Microsoft.FSharp.Core.SR.QtmmInitArray">

</member>
<member name="P:Microsoft.FSharp.Core.SR.QtmmCondMustBeBool">

</member>
<member name="P:Microsoft.FSharp.Core.SR.QtmmTrueAndFalseMustMatch">

</member>
<member name="P:Microsoft.FSharp.Core.SR.QtmmExprTypeMismatch">

</member>
<member name="P:Microsoft.FSharp.Core.SR.QtmmIncorrectArgForUnion">

</member>
<member name="P:Microsoft.FSharp.Core.SR.QtmmIncorrectArgForRecord">

</member>
<member name="P:Microsoft.FSharp.Core.SR.QtmmExprNotMatchTuple">

</member>
<member name="P:Microsoft.FSharp.Core.SR.QtmmTuple">

</member>
<member name="P:Microsoft.FSharp.Core.SR.QtmmVarTypeNotMatchRHS">

</member>
<member name="P:Microsoft.FSharp.Core.SR.QtmmFunctionArgTypeMismatch">

</member>
<member name="P:Microsoft.FSharp.Core.SR.QtmmInvalidParam">

</member>
<member name="P:Microsoft.FSharp.Core.SR.QtmmExpectedFunction">

</member>
<member name="P:Microsoft.FSharp.Core.SR.QunexpectedHole">

</member>
<member name="P:Microsoft.FSharp.Core.SR.QunrecognizedMethodCall">

</member>
<member name="P:Microsoft.FSharp.Core.SR.QexpectedOneType">

</member>
<member name="P:Microsoft.FSharp.Core.SR.QexpectedTwoTypes">

</member>
<member name="P:Microsoft.FSharp.Core.SR.QinvalidCaseIndex">

</member>
<member name="P:Microsoft.FSharp.Core.SR.QmissingUnionCase">

</member>
<member name="P:Microsoft.FSharp.Core.SR.QmissingRecordField">

</member>
<member name="P:Microsoft.FSharp.Core.SR.optionValueWasNone">

</member>
<member name="P:Microsoft.FSharp.Core.SR.thisValueCannotBeMutated">

</member>
<member name="P:Microsoft.FSharp.Core.SR.moveNextNotCalledOrFinished">

</member>
<member name="P:Microsoft.FSharp.Core.SR.constructorForUnionCaseNotFound">

</member>
<member name="P:Microsoft.FSharp.Core.SR.multipleCompilationMappings">

</member>
<member name="P:Microsoft.FSharp.Core.SR.printfBadFloatValue">

</member>
<member name="P:Microsoft.FSharp.Core.SR.printfExpectedPrecision">

</member>
<member name="P:Microsoft.FSharp.Core.SR.printfExpectedWidth">

</member>
<member name="P:Microsoft.FSharp.Core.SR.printfBadIntegerForDynamicFomatter">

</member>
<member name="P:Microsoft.FSharp.Core.SR.printfBadFormatSpecifier">

</member>
<member name="P:Microsoft.FSharp.Core.SR.printfSpecifierAfterIllegal">

</member>
<member name="P:Microsoft.FSharp.Core.SR.printfWidthSpecifierIllegal">

</member>
<member name="P:Microsoft.FSharp.Core.SR.printfPrecisonSpecifierIllegal">

</member>
<member name="P:Microsoft.FSharp.Core.SR.printfHashFormatSpecifierIllegal">

</member>
<member name="P:Microsoft.FSharp.Core.SR.printfMissingFormatSpecifier">

</member>
<member name="P:Microsoft.FSharp.Core.SR.printfNotAFunType">

</member>
<member name="P:Microsoft.FSharp.Core.SR.firstClassUsesOfSplice">

</member>
<member name="P:Microsoft.FSharp.Core.SR.keyNotFoundAlt">

</member>
<member name="P:Microsoft.FSharp.Core.SR.objIsNotARecord">

</member>
<member name="P:Microsoft.FSharp.Core.SR.nullsNotAllowedInArray">

</member>
<member name="P:Microsoft.FSharp.Core.SR.notARecordType">

</member>
<member name="P:Microsoft.FSharp.Core.SR.privateRecordType">

</member>
<member name="P:Microsoft.FSharp.Core.SR.notAnExceptionType">

</member>
<member name="P:Microsoft.FSharp.Core.SR.privateExceptionType">

</member>
<member name="P:Microsoft.FSharp.Core.SR.notAUnionType">

</member>
<member name="P:Microsoft.FSharp.Core.SR.privateUnionType">

</member>
<member name="P:Microsoft.FSharp.Core.SR.objIsNullAndNoType">

</member>
<member name="P:Microsoft.FSharp.Core.SR.tupleIndexOutOfRange">

</member>
<member name="P:Microsoft.FSharp.Core.SR.notAFunctionType">

</member>
<member name="P:Microsoft.FSharp.Core.SR.notATupleType">

</member>
<member name="P:Microsoft.FSharp.Core.SR.invalidTupleTypes">

</member>
<member name="P:Microsoft.FSharp.Core.SR.delegateExpected">

</member>
<member name="P:Microsoft.FSharp.Core.SR.noNegateMinValue">

</member>
<member name="P:Microsoft.FSharp.Core.SR.checkStaticInit">

</member>
<member name="P:Microsoft.FSharp.Core.SR.checkInit">

</member>
<member name="P:Microsoft.FSharp.Core.SR.endCannotBeNaN">

</member>
<member name="P:Microsoft.FSharp.Core.SR.stepCannotBeNaN">

</member>
<member name="P:Microsoft.FSharp.Core.SR.startCannotBeNaN">

</member>
<member name="P:Microsoft.FSharp.Core.SR.stepCannotBeZero">

</member>
<member name="P:Microsoft.FSharp.Core.SR.keyNotFound">

</member>
<member name="P:Microsoft.FSharp.Core.SR.dyInvOpMultOverload">

</member>
<member name="P:Microsoft.FSharp.Core.SR.dyInvOpMultCoerce">

</member>
<member name="P:Microsoft.FSharp.Core.SR.dyInvOpAddOverload">

</member>
<member name="P:Microsoft.FSharp.Core.SR.dyInvOpAddCoerce">

</member>
<member name="P:Microsoft.FSharp.Core.SR.dyInvDivByIntCoerce">

</member>
<member name="P:Microsoft.FSharp.Core.SR.badFormatString">

</member>
<member name="P:Microsoft.FSharp.Core.SR.notUsedForHashing">

</member>
<member name="P:Microsoft.FSharp.Core.SR.genericCompareFail1">

</member>
<member name="P:Microsoft.FSharp.Core.SR.addressOpNotFirstClass">

</member>
<member name="P:Microsoft.FSharp.Core.SR.failedReadEnoughBytes">

</member>
<member name="P:Microsoft.FSharp.Core.SR.notAPermutation">

</member>
<member name="P:Microsoft.FSharp.Core.SR.cannotMutate">

</member>
<member name="P:Microsoft.FSharp.Core.SR.mailboxProcessorPostAndAsyncReplyTimedOut">

</member>
<member name="P:Microsoft.FSharp.Core.SR.mailboxProcessorPostAndReplyTimedOut">

</member>
<member name="P:Microsoft.FSharp.Core.SR.mailboxProcessorAlreadyStarted">

</member>
<member name="P:Microsoft.FSharp.Core.SR.mailboxReceiveTimedOut">

</member>
<member name="P:Microsoft.FSharp.Core.SR.mailboxScanTimedOut">

</member>
<member name="P:Microsoft.FSharp.Core.SR.syncContextNull">

</member>
<member name="P:Microsoft.FSharp.Core.SR.mismatchIARCancel">

</member>
<member name="P:Microsoft.FSharp.Core.SR.mismatchIAREnd">

</member>
<member name="P:Microsoft.FSharp.Core.SR.nonZeroBasedDisallowed">

</member>
<member name="P:Microsoft.FSharp.Core.SR.arrayWasEmpty">

</member>
<member name="P:Microsoft.FSharp.Core.SR.arraysHadDifferentLengths">

</member>
<member name="P:Microsoft.FSharp.Core.SR.outOfRange">

</member>
<member name="P:Microsoft.FSharp.Core.SR.notComparable">

</member>
<member name="P:Microsoft.FSharp.Core.SR.mapCannotBeMutated">

</member>
<member name="P:Microsoft.FSharp.Core.SR.inputSequenceEmpty">

</member>
<member name="P:Microsoft.FSharp.Core.SR.enumerationPastIntMaxValue">

</member>
<member name="P:Microsoft.FSharp.Core.SR.inputMustBeNonNegative">

</member>
<member name="P:Microsoft.FSharp.Core.SR.notEnoughElements">

</member>
<member name="P:Microsoft.FSharp.Core.SR.pickElementNotFound">

</member>
<member name="P:Microsoft.FSharp.Core.SR.findIndexElementNotFound">

</member>
<member name="P:Microsoft.FSharp.Core.SR.findElementNotFound">

</member>
<member name="P:Microsoft.FSharp.Core.SR.enumerationAlreadyFinished">

</member>
<member name="P:Microsoft.FSharp.Core.SR.setContainsNoElements">

</member>
<member name="P:Microsoft.FSharp.Core.SR.enumerationNotStarted">

</member>
<member name="P:Microsoft.FSharp.Core.SR.inputListWasEmpty">

</member>
<member name="P:Microsoft.FSharp.Core.SR.listsHadDifferentLengths">

</member>
<member name="P:Microsoft.FSharp.Core.SR.indexOutOfBounds">

</member>
<member name="P:Microsoft.FSharp.Core.SR.resetNotSupported">

</member>
<member name="P:Microsoft.FSharp.Core.SR.matchCasesIncomplete">

</member>
<member name="P:Microsoft.FSharp.Core.SR.resources">

</member>
<member name="T:Microsoft.FSharp.Core.SR">

</member>
<member name="M:Microsoft.FSharp.Core.StringModule.CompatibleForAll(Microsoft.FSharp.Core.FSharpFunc`2{System.Char,System.Boolean},System.String)">

</member>
<member name="M:Microsoft.FSharp.Core.StringModule.CompatibleMapConcat(Microsoft.FSharp.Core.FSharpFunc`2{System.Char,System.String},System.String)">

</member>
<member name="M:Microsoft.FSharp.Core.StringModule.Length(System.String)">
<summary>
 Return the length of the string.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.StringModule.Replicate(System.Int32,System.String)">
<summary>
 Return a string by concatenating &lt;c&gt;count&lt;/c&gt; instances of &lt;c&gt;str&lt;/c&gt;.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.StringModule.Exists(Microsoft.FSharp.Core.FSharpFunc`2{System.Char,System.Boolean},System.String)">
<summary>
 Test if any character of the string satisfies the given predicate.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.StringModule.ForAll(Microsoft.FSharp.Core.FSharpFunc`2{System.Char,System.Boolean},System.String)">
<summary>
 Test if all characters in the string satisfy the given predicate.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.StringModule.Initialize(System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,System.String})">
<summary>
 Build a new string whose characters are the results of applying the function &lt;c&gt;mapping&lt;/c&gt;
 to each index from &lt;c&gt;0&lt;/c&gt; to &lt;c&gt;count-1&lt;/c&gt; and concatenating the resulting
 strings.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.StringModule.Collect(Microsoft.FSharp.Core.FSharpFunc`2{System.Char,System.String},System.String)">
<summary>
 Build a new string whose characters are the results of applying the function &lt;c&gt;mapping&lt;/c&gt;
 to each of the characters of the input string and concatenating the resulting
 strings.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.StringModule.MapIndexed(Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{System.Char,System.Char}},System.String)">
<summary>
 Build a new string whose characters are the results of applying the function &lt;c&gt;mapping&lt;/c&gt;
 to each character in the string and the character itself.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.StringModule.Map(Microsoft.FSharp.Core.FSharpFunc`2{System.Char,System.Char},System.String)">
<summary>
 Build a new string whose characters are the results of applying the function &lt;c&gt;mapping&lt;/c&gt;
 to each of the characters of the input string.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.StringModule.IterateIndexed(Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{System.Char,Microsoft.FSharp.Core.Unit}},System.String)">
<summary>
 Apply the function &lt;c&gt;action&lt;/c&gt; to the index of each character in the string and the character itself.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.StringModule.Iterate(Microsoft.FSharp.Core.FSharpFunc`2{System.Char,Microsoft.FSharp.Core.Unit},System.String)">
<summary>
 Apply the function &lt;c&gt;action&lt;/c&gt; to each character in the string.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.StringModule.Concat(System.String,System.Collections.Generic.IEnumerable{System.String})">
<summary>
 Return a new string made by concatenating the given strings
 with separator &apos;sep&apos;, i.e. &apos;a1 + sep + ... + sep + aN&apos;
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.StringModule">
<summary>
 Functional programming operators for string processing.  Further string operations
 are available via the member functions on strings and other functionality in
  &lt;a href=&quot;http://msdn2.microsoft.com/en-us/library/system.string.aspx&quot;&gt;System.String&lt;/a&gt; 
 and &lt;a href=&quot;http://msdn2.microsoft.com/library/system.text.regularexpressions.aspx&quot;&gt;System.Text.RegularExpressions&lt;/a&gt; types.
</summary>
</member>
<member name="T:Microsoft.FSharp.Math.BigInt">

</member>
<member name="T:Microsoft.FSharp.Math.BigNat">
<summary>
 Abstract internal type
</summary>
</member>
<member name="T:Microsoft.FSharp.Math.bigint">

</member>
<member name="M:Microsoft.FSharp.Math.BigNatModule.getSmall(Microsoft.FSharp.Math.BigNat)">

</member>
<member name="M:Microsoft.FSharp.Math.BigNatModule.isSmall(Microsoft.FSharp.Math.BigNat)">

</member>
<member name="M:Microsoft.FSharp.Math.BigNatModule.bits(Microsoft.FSharp.Math.BigNat)">

</member>
<member name="M:Microsoft.FSharp.Math.BigNatModule.factorial(Microsoft.FSharp.Math.BigNat)">

</member>
<member name="M:Microsoft.FSharp.Math.BigNatModule.toUInt64(Microsoft.FSharp.Math.BigNat)">

</member>
<member name="M:Microsoft.FSharp.Math.BigNatModule.toUInt32(Microsoft.FSharp.Math.BigNat)">

</member>
<member name="M:Microsoft.FSharp.Math.BigNatModule.ofString(System.String)">

</member>
<member name="M:Microsoft.FSharp.Math.BigNatModule.toString(Microsoft.FSharp.Math.BigNat)">

</member>
<member name="M:Microsoft.FSharp.Math.BigNatModule.ofInt64(System.Int64)">

</member>
<member name="M:Microsoft.FSharp.Math.BigNatModule.ofInt32(System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Math.BigNatModule.toFloat(Microsoft.FSharp.Math.BigNat)">

</member>
<member name="M:Microsoft.FSharp.Math.BigNatModule.hash(Microsoft.FSharp.Math.BigNat)">

</member>
<member name="M:Microsoft.FSharp.Math.BigNatModule.gte(Microsoft.FSharp.Math.BigNat,Microsoft.FSharp.Math.BigNat)">

</member>
<member name="M:Microsoft.FSharp.Math.BigNatModule.lte(Microsoft.FSharp.Math.BigNat,Microsoft.FSharp.Math.BigNat)">

</member>
<member name="M:Microsoft.FSharp.Math.BigNatModule.gt(Microsoft.FSharp.Math.BigNat,Microsoft.FSharp.Math.BigNat)">

</member>
<member name="M:Microsoft.FSharp.Math.BigNatModule.lt(Microsoft.FSharp.Math.BigNat,Microsoft.FSharp.Math.BigNat)">

</member>
<member name="M:Microsoft.FSharp.Math.BigNatModule.compare(Microsoft.FSharp.Math.BigNat,Microsoft.FSharp.Math.BigNat)">

</member>
<member name="M:Microsoft.FSharp.Math.BigNatModule.equal(Microsoft.FSharp.Math.BigNat,Microsoft.FSharp.Math.BigNat)">

</member>
<member name="M:Microsoft.FSharp.Math.BigNatModule.isOne(Microsoft.FSharp.Math.BigNat)">

</member>
<member name="M:Microsoft.FSharp.Math.BigNatModule.isZero(Microsoft.FSharp.Math.BigNat)">

</member>
<member name="M:Microsoft.FSharp.Math.BigNatModule.IsZero(Microsoft.FSharp.Math.BigNat)">

</member>
<member name="M:Microsoft.FSharp.Math.BigNatModule.pow(Microsoft.FSharp.Math.BigNat,Microsoft.FSharp.Math.BigNat)">

</member>
<member name="M:Microsoft.FSharp.Math.BigNatModule.powi(Microsoft.FSharp.Math.BigNat,System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Math.BigNatModule.scale(System.Int32,Microsoft.FSharp.Math.BigNat)">

</member>
<member name="M:Microsoft.FSharp.Math.BigNatModule.max(Microsoft.FSharp.Math.BigNat,Microsoft.FSharp.Math.BigNat)">

</member>
<member name="M:Microsoft.FSharp.Math.BigNatModule.min(Microsoft.FSharp.Math.BigNat,Microsoft.FSharp.Math.BigNat)">

</member>
<member name="M:Microsoft.FSharp.Math.BigNatModule.hcf(Microsoft.FSharp.Math.BigNat,Microsoft.FSharp.Math.BigNat)">

</member>
<member name="M:Microsoft.FSharp.Math.BigNatModule.rem(Microsoft.FSharp.Math.BigNat,Microsoft.FSharp.Math.BigNat)">

</member>
<member name="M:Microsoft.FSharp.Math.BigNatModule.div(Microsoft.FSharp.Math.BigNat,Microsoft.FSharp.Math.BigNat)">

</member>
<member name="M:Microsoft.FSharp.Math.BigNatModule.divmod(Microsoft.FSharp.Math.BigNat,Microsoft.FSharp.Math.BigNat)">

</member>
<member name="M:Microsoft.FSharp.Math.BigNatModule.mul(Microsoft.FSharp.Math.BigNat,Microsoft.FSharp.Math.BigNat)">

</member>
<member name="M:Microsoft.FSharp.Math.BigNatModule.sub(Microsoft.FSharp.Math.BigNat,Microsoft.FSharp.Math.BigNat)">

</member>
<member name="M:Microsoft.FSharp.Math.BigNatModule.add(Microsoft.FSharp.Math.BigNat,Microsoft.FSharp.Math.BigNat)">

</member>
<member name="P:Microsoft.FSharp.Math.BigNatModule.two">

</member>
<member name="P:Microsoft.FSharp.Math.BigNatModule.one">

</member>
<member name="P:Microsoft.FSharp.Math.BigNatModule.zero">

</member>
<member name="T:Microsoft.FSharp.Math.BigNatModule">

</member>
<member name="M:Microsoft.FSharp.NativeInterop.NativePtrModule.StackAllocate``1(System.Int32)">
<summary>
 Allocate a region of memory on the stack.
</summary>
</member>
<member name="M:Microsoft.FSharp.NativeInterop.NativePtrModule.GetArray2DAddressInlined``1(``0[,]`1,System.Int32,System.Int32)">
<summary>
 Get the address of an element of a pinned 2-dimensional array
</summary>
</member>
<member name="M:Microsoft.FSharp.NativeInterop.NativePtrModule.GetArray2AddressInlined``1(``0[,]`1,System.Int32,System.Int32)">
<summary>
 Get the address of an element of a pinned 2-dimensional array
</summary>
</member>
<member name="M:Microsoft.FSharp.NativeInterop.NativePtrModule.GetArrayAddressInlined``1(``0[]`1,System.Int32)">
<summary>
 Get the address of an element of a pinned array
</summary>
</member>
<member name="M:Microsoft.FSharp.NativeInterop.NativePtrModule.SetPointerInlined``1(Microsoft.FSharp.Core.nativeptr{``0},System.Int32,``0)">
<summary>
 Assign the &lt;c&gt;value&lt;/c&gt; into the memory location referenced by the typed native 
 pointer computed by adding index * sizeof&lt;&apos;T&gt; to the given input pointer 
</summary>
</member>
<member name="M:Microsoft.FSharp.NativeInterop.NativePtrModule.WritePointerInlined``1(Microsoft.FSharp.Core.nativeptr{``0},``0)">
<summary>
 Assign the &lt;c&gt;value&lt;/c&gt; into the memory location referenced by the given typed native pointer 
</summary>
</member>
<member name="M:Microsoft.FSharp.NativeInterop.NativePtrModule.ReadPointerInlined``1(Microsoft.FSharp.Core.nativeptr{``0})">
<summary>
 Dereference the given typed native pointer 
</summary>
</member>
<member name="M:Microsoft.FSharp.NativeInterop.NativePtrModule.GetPointerInlined``1(Microsoft.FSharp.Core.nativeptr{``0},System.Int32)">
<summary>
 Dereference the typed native pointer computed by adding index * sizeof&lt;&apos;T&gt; to the 
 given input pointer 
</summary>
</member>
<member name="M:Microsoft.FSharp.NativeInterop.NativePtrModule.AddPointerInlined``1(Microsoft.FSharp.Core.nativeptr{``0},System.Int32)">
<summary>
 Return a typed native pointer by adding index * sizeof&lt;&apos;T&gt; to the 
 given input pointer 
</summary>
</member>
<member name="M:Microsoft.FSharp.NativeInterop.NativePtrModule.ToNativeIntInlined``1(Microsoft.FSharp.Core.nativeptr{``0})">
<summary>
 Return a machine address for a given typed native pointer 
</summary>
</member>
<member name="M:Microsoft.FSharp.NativeInterop.NativePtrModule.OfNativeIntInlined``1(System.IntPtr)">
<summary>
 Return a typed native pointer for a given machine address
</summary>
</member>
<member name="M:Microsoft.FSharp.NativeInterop.NativePtrModule.CompatibleToNativeIntInlined``1(Microsoft.FSharp.Core.nativeptr{``0})">
<summary>
 Return a machine address for a given typed native pointer 
</summary>
</member>
<member name="M:Microsoft.FSharp.NativeInterop.NativePtrModule.CompatibleOfNativeIntInlined``1(System.IntPtr)">
<summary>
 Return a typed native pointer for a given machine address
</summary>
</member>
<member name="T:Microsoft.FSharp.NativeInterop.NativePtrModule">
<summary>
 Contains operations on native pointers.  Use of these operators may
 result in the generation of unverifiable code.
</summary>
</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.Array.stableSortInPlace``1(``0[]`1)">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.Array.stableSortInPlaceBy``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},``0[]`1)">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.Array.unstableSortInPlace``1(``0[]`1)">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.Array.unstableSortInPlaceBy``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},``0[]`1)">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.Array.permute``1(Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,System.Int32},``0[]`1)">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.Array.init``1(System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,``0})">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.Array.zeroCreateUnchecked``1(System.Int32)">

</member>
<member name="T:Microsoft.FSharp.Primitives.Basics.Array">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.List.sortWith``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Int32}},Microsoft.FSharp.Collections.FSharpList{``0})">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.List.toArray``1(Microsoft.FSharp.Collections.FSharpList{``0})">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.List.ofArray``1(``0[]`1)">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.List.zip3``3(Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``1},Microsoft.FSharp.Collections.FSharpList{``2})">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.List.zip``2(Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``1})">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.List.unzip3``3(Microsoft.FSharp.Collections.FSharpList{System.Tuple`3{``0,``1,``2}})">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.List.unzip``2(Microsoft.FSharp.Collections.FSharpList{System.Tuple`2{``0,``1}})">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.List.iteri``1(Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.Unit}},Microsoft.FSharp.Collections.FSharpList{``0})">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.List.concat``1(System.Collections.Generic.IEnumerable{Microsoft.FSharp.Collections.FSharpList{``0}})">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.List.rev``1(Microsoft.FSharp.Collections.FSharpList{``0})">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.List.exists``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Boolean},Microsoft.FSharp.Collections.FSharpList{``0})">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.List.forall``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Boolean},Microsoft.FSharp.Collections.FSharpList{``0})">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.List.mapi``2(Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{``0,``1}},Microsoft.FSharp.Collections.FSharpList{``0})">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.List.map2``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,``2}},Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``1})">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.List.map``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},Microsoft.FSharp.Collections.FSharpList{``0})">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.List.partition``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Boolean},Microsoft.FSharp.Collections.FSharpList{``0})">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.List.collect``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Collections.FSharpList{``1}},Microsoft.FSharp.Collections.FSharpList{``0})">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.List.filter``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Boolean},Microsoft.FSharp.Collections.FSharpList{``0})">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.List.iter``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Collections.FSharpList{``0})">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.List.init``1(System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,``0})">

</member>
<member name="T:Microsoft.FSharp.Primitives.Basics.List">

</member>
<member name="P:Microsoft.FSharp.Quotations.FSharpExpr`1.Raw">
<summary>
 Get the raw expression associated with this type-carrying expression
</summary>
</member>
<member name="T:Microsoft.FSharp.Quotations.FSharpExpr`1">
<summary>
 Type-carrying quoted expressions.  Expressions are generated either
 by quotations in source text or programatically
</summary>
</member>
<member name="P:Microsoft.FSharp.Quotations.FSharpExpr.Type">
<summary>
 Returns type of an expression
</summary>
</member>
<member name="P:Microsoft.FSharp.Quotations.FSharpExpr.CustomAttributes">
<summary>
 Returns the custom attributes of an expression
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.WhileLoop(Microsoft.FSharp.Quotations.FSharpExpr,Microsoft.FSharp.Quotations.FSharpExpr)">
<summary>
 Build an expression that represents a while loop
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.VarSet(Microsoft.FSharp.Quotations.FSharpVar,Microsoft.FSharp.Quotations.FSharpExpr)">
<summary>
 Build an expression that represents setting a mutable variable
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.Var(Microsoft.FSharp.Quotations.FSharpVar)">
<summary>
 Build an expression that represents a variable
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.Value``1(``0)">
<summary>
 Build an expression that represents a constant value 
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.Value(System.Object,System.Type)">
<summary>
 Build an expression that represents a constant value of a particular type
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.UnionCaseTest(Microsoft.FSharp.Quotations.FSharpExpr,Microsoft.FSharp.Reflection.UnionCaseInfo)">
<summary>
 Build an expression that represents a test of a value is of a particular union case
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.TypeTest(Microsoft.FSharp.Quotations.FSharpExpr,System.Type)">
<summary>
 Build an expression that represents a type test
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.TupleGet(Microsoft.FSharp.Quotations.FSharpExpr,System.Int32)">
<summary>
 Build an expression that represents getting a field of a tuple
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.TryWith(Microsoft.FSharp.Quotations.FSharpExpr,Microsoft.FSharp.Quotations.FSharpVar,Microsoft.FSharp.Quotations.FSharpExpr,Microsoft.FSharp.Quotations.FSharpVar,Microsoft.FSharp.Quotations.FSharpExpr)">
<summary>
 Build an expression that represents a try/with construct for exception filtering and catching 
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.TryGetReflectedDefinition(System.Reflection.MethodBase)">
<summary>
 Try and find a stored reflection definition for the given method. Stored reflection
 definitions are added to an F# assembly through the use of the [&lt;ReflectedDefinition&gt;] attribute.
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.TryFinally(Microsoft.FSharp.Quotations.FSharpExpr,Microsoft.FSharp.Quotations.FSharpExpr)">
<summary>
 Build an expression that represents a try/finally construct 
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.Substitute(Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Quotations.FSharpVar,Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Quotations.FSharpExpr}})">
<summary>
 Substitute through the given expression using the given functions
 to map variables to new values.  The functions must give consistent results
 at each application.  Variable renaming may occur on the target expression
 if variable capture occurs.
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.Sequential(Microsoft.FSharp.Quotations.FSharpExpr,Microsoft.FSharp.Quotations.FSharpExpr)">
<summary>
 Build an expression that represents the sequential execution of one expression followed by another
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.RegisterReflectedDefinitions(System.Reflection.Assembly,System.String,System.Byte[]`1)">
<summary>
 Permit interactive environments such as F# Interactive
 to explicitly register new pickled resources that represent persisted 
 top level definitions. The string indicates a unique name for the resources
 being added. The format for the bytes is the encoding generated by the F# compiler.
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.Quote(Microsoft.FSharp.Quotations.FSharpExpr)">
<summary>
 Build an expression that represents a nested quotation literal
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.PropertySet(System.Reflection.PropertyInfo,Microsoft.FSharp.Quotations.FSharpExpr,Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Quotations.FSharpExpr}})">
<summary>
 Build an expression that represents writing to a static property 
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.PropertySet(Microsoft.FSharp.Quotations.FSharpExpr,System.Reflection.PropertyInfo,Microsoft.FSharp.Quotations.FSharpExpr,Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Quotations.FSharpExpr}})">
<summary>
 Build an expression that represents writing to a property of an object
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.PropertyGet(System.Reflection.PropertyInfo,Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Quotations.FSharpExpr}})">
<summary>
 Build an expression that represents reading a static property 
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.PropertyGet(Microsoft.FSharp.Quotations.FSharpExpr,System.Reflection.PropertyInfo,Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Quotations.FSharpExpr}})">
<summary>
 Build an expression that represents reading a property of an object
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.NewUnionCase(Microsoft.FSharp.Reflection.UnionCaseInfo,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Quotations.FSharpExpr})">
<summary>
 Build an expression that represents the creation of a union case value
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.NewTuple(Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Quotations.FSharpExpr})">
<summary>
 Build an expression that represents the creation of an F# tuple value
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.NewRecord(System.Type,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Quotations.FSharpExpr})">
<summary>
 Build record-construction expressions 
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.NewObject(System.Reflection.ConstructorInfo,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Quotations.FSharpExpr})">
<summary>
 Build an expression that represents the invocation of an object constructor
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.NewDelegate(System.Type,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Quotations.FSharpVar},Microsoft.FSharp.Quotations.FSharpExpr)">
<summary>
 Build an expression that represents the creation of a delegate value for the given type
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.NewArray(System.Type,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Quotations.FSharpExpr})">
<summary>
 Build an expression that represents the creation of an array value initialized with the given elements
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.LetRecursive(Microsoft.FSharp.Collections.FSharpList{System.Tuple`2{Microsoft.FSharp.Quotations.FSharpVar,Microsoft.FSharp.Quotations.FSharpExpr}},Microsoft.FSharp.Quotations.FSharpExpr)">
<summary>
 Build recursives expressions associated with &apos;let rec&apos; constructs
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.Let(Microsoft.FSharp.Quotations.FSharpVar,Microsoft.FSharp.Quotations.FSharpExpr,Microsoft.FSharp.Quotations.FSharpExpr)">
<summary>
 Build expressions associated with &apos;let&apos; constructs
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.Lambda(Microsoft.FSharp.Quotations.FSharpVar,Microsoft.FSharp.Quotations.FSharpExpr)">
<summary>
 Build an expression that represents the constrution of an F# function value
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.IfThenElse(Microsoft.FSharp.Quotations.FSharpExpr,Microsoft.FSharp.Quotations.FSharpExpr,Microsoft.FSharp.Quotations.FSharpExpr)">
<summary>
 Build &apos;if ... then ... else&apos; expressions    
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.GlobalVar``1(System.String)">
<summary>
 Fetch or create a new variable with the given name and type from a global pool of shared variables
 indexed by name and type. The type is given by the expicit or inferred type parameter
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.GetFreeVars">
<summary>
 Get the free expression variables of an expression as a list
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.ForIntegerRangeLoop(Microsoft.FSharp.Quotations.FSharpVar,Microsoft.FSharp.Quotations.FSharpExpr,Microsoft.FSharp.Quotations.FSharpExpr,Microsoft.FSharp.Quotations.FSharpExpr)">
<summary>
 Build a &apos;for i = ... to ... do ...&apos; expression that represent loops over integer ranges
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.FieldSet(Microsoft.FSharp.Quotations.FSharpExpr,System.Reflection.FieldInfo,Microsoft.FSharp.Quotations.FSharpExpr)">
<summary>
 Build an expression that represents writing to a field of an object
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.FieldSet(System.Reflection.FieldInfo,Microsoft.FSharp.Quotations.FSharpExpr)">
<summary>
 Build an expression that represents writing to a static field 
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.FieldGet(Microsoft.FSharp.Quotations.FSharpExpr,System.Reflection.FieldInfo)">
<summary>
 Build an expression that represents the access of a field of an object
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.FieldGet(System.Reflection.FieldInfo)">
<summary>
 Build an expression that represents the access of a static field 
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.Equals(System.Object)">

</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.Deserialize(System.Type,Microsoft.FSharp.Collections.FSharpList{System.Type},Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Quotations.FSharpExpr},System.Byte[]`1)">
<summary>
 This function is called automatically when quotation syntax (&lt;@ @&gt;) and related typed-expression
 quotations are used. The bytes are a pickled binary representation of an unlinked form of the qutoed expression,
 and the System.Type argument is any type in the assembly where the quoted
 expression occurs, i.e. it helps scope the interpretation of the cross-assembly
 references in the bytes.
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.DefaultValue(System.Type)">
<summary>
 Build an expression that represents the invocation of a default object constructor
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.Coerce(Microsoft.FSharp.Quotations.FSharpExpr,System.Type)">
<summary>
 Build an expression that represents the coercion of an expression to a type
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.Cast``1(Microsoft.FSharp.Quotations.FSharpExpr)">
<summary>
 Return a new typed expression given an underlying runtime-typed expression.
 A type annotation is usually required to use this function, and 
 using an incorrect type annotation may result in a later runtime exception.
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.Call(Microsoft.FSharp.Quotations.FSharpExpr,System.Reflection.MethodInfo,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Quotations.FSharpExpr})">
<summary>
 Build an expression that represents a call to an instance method associated with an object
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.Call(System.Reflection.MethodInfo,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Quotations.FSharpExpr})">
<summary>
 Build an expression that represents a call to an static method or module-bound function
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.Applications(Microsoft.FSharp.Quotations.FSharpExpr,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Quotations.FSharpExpr}})">
<summary>
 Build an expression that represents the application of a first class function value to multiple arguments
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.Application(Microsoft.FSharp.Quotations.FSharpExpr,Microsoft.FSharp.Quotations.FSharpExpr)">
<summary>
 Build an expression that represents the application of a first class function value to a single argument
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.AddressSet(Microsoft.FSharp.Quotations.FSharpExpr,Microsoft.FSharp.Quotations.FSharpExpr)">
<summary>
 Build an expression that represents setting the value held at a particular address
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpExpr.AddressOf(Microsoft.FSharp.Quotations.FSharpExpr)">
<summary>
 Build an expression that represents getting the address of a value
</summary>
</member>
<member name="T:Microsoft.FSharp.Quotations.FSharpExpr">
<summary>
 Quoted expressions annotated with System.Type values. 
</summary>
</member>
<member name="P:Microsoft.FSharp.Quotations.FSharpVar.Type">
<summary>
 The type associated with the variable
</summary>
</member>
<member name="P:Microsoft.FSharp.Quotations.FSharpVar.Name">
<summary>
 The declared name of the variable
</summary>
</member>
<member name="P:Microsoft.FSharp.Quotations.FSharpVar.IsMutable">
<summary>
 Indicates if the variable represents a mutable storage location
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpVar.Global(System.String,System.Type)">
<summary>
 Fetch or create a new variable with the given name and type from a global pool of shared variables
 indexed by name and type
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.FSharpVar..ctor(System.String,System.Type,Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
<summary>
 Create a new variable with the given name, type and mutability
</summary>
</member>
<member name="T:Microsoft.FSharp.Quotations.FSharpVar">
<summary>
 Information at the binding site of a variable
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.ExprShapeModule.RebuildShapeCombination(System.Object,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Quotations.FSharpExpr})">
<summary>
 Re-build combination expressions. The first parameter should be an object
 returned by the &lt;c&gt;ShapeCombination&lt;/c&gt; case of the active pattern in this module.
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.ExprShapeModule.ShapePattern(Microsoft.FSharp.Quotations.FSharpExpr)">
<summary>
 An active pattern that performs a complete decomposition viewing the expression tree as a binding structure
</summary>
</member>
<member name="T:Microsoft.FSharp.Quotations.ExprShapeModule">
<summary>
 Active patterns for traversing, visiting, rebuilding and tranforming expressions in a generic way
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatternsModule.PropertySetterWithReflectedDefinitionPattern(System.Reflection.PropertyInfo)">
<summary>
 An active pattern to recognize property setters that have an associated ReflectedDefinition
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatternsModule.PropertyGetterWithReflectedDefinitionPattern(System.Reflection.PropertyInfo)">
<summary>
 An active pattern to recognize property getters or values in modules that have an associated ReflectedDefinition
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatternsModule.MethodWithReflectedDefinitionPattern(System.Reflection.MethodBase)">
<summary>
 An active pattern to recognize methods that have an associated ReflectedDefinition
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatternsModule.SpecificCallPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
<summary>
 A parameterized active pattern to recognize calls to a specified function or method.
 The returned elements are the optional target object (present if the target is an 
 instance method), the generic type instantation (non-empty if the target is a generic
 instantiation), and the arguments to the function or method.
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatternsModule.UInt64Pattern(Microsoft.FSharp.Quotations.FSharpExpr)">
<summary>
 An active pattern to recognize constant unsigned int64 expressions
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatternsModule.Int64Pattern(Microsoft.FSharp.Quotations.FSharpExpr)">
<summary>
 An active pattern to recognize constant int64 expressions
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatternsModule.UInt32Pattern(Microsoft.FSharp.Quotations.FSharpExpr)">
<summary>
 An active pattern to recognize constant unsigned int32 expressions
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatternsModule.Int32Pattern(Microsoft.FSharp.Quotations.FSharpExpr)">
<summary>
 An active pattern to recognize constant int32 expressions
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatternsModule.UInt16Pattern(Microsoft.FSharp.Quotations.FSharpExpr)">
<summary>
 An active pattern to recognize constant unsigned int16 expressions
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatternsModule.Int16Pattern(Microsoft.FSharp.Quotations.FSharpExpr)">
<summary>
 An active pattern to recognize constant int16 expressions
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatternsModule.BytePattern(Microsoft.FSharp.Quotations.FSharpExpr)">
<summary>
 An active pattern to recognize constant byte expressions
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatternsModule.SBytePattern(Microsoft.FSharp.Quotations.FSharpExpr)">
<summary>
 An active pattern to recognize constant signed byte expressions
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatternsModule.CharPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
<summary>
 An active pattern to recognize constant unicode character expressions
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatternsModule.DoublePattern(Microsoft.FSharp.Quotations.FSharpExpr)">
<summary>
 An active pattern to recognize constant 64-bit floating point number expressions
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatternsModule.SinglePattern(Microsoft.FSharp.Quotations.FSharpExpr)">
<summary>
 An active pattern to recognize constant 32-bit floating point number expressions
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatternsModule.StringPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
<summary>
 An active pattern to recognize constant string expressions
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatternsModule.BoolPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
<summary>
 An active pattern to recognize constant boolean expressions
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatternsModule.UnitPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
<summary>
 An active pattern to recognize &lt;c&gt;()&lt;/c&gt; constant expressions
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatternsModule.OrElsePattern(Microsoft.FSharp.Quotations.FSharpExpr)">
<summary>
 An active pattern to recognize expressions of the form &lt;c&gt;a || b&lt;/c&gt; 
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatternsModule.AndAlsoPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
<summary>
 An active pattern to recognize expressions of the form &lt;c&gt;a &amp;&amp; b&lt;/c&gt; 
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatternsModule.ApplicationsPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
<summary>
 An active pattern to recognize expressions that represent the application of a (possibly curried or tupled) first class function value
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.DerivedPatternsModule.LambdasPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
<summary>
 An active pattern to recognize expressions that represent a (possibly curried or tupled) first class function value
</summary>
</member>
<member name="T:Microsoft.FSharp.Quotations.DerivedPatternsModule">
<summary>
 Contains a set of derived F# active patterns to analyze F# expression objects
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.VarSetPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
<summary>
 An active pattern to recognize expressions that represent setting a mutable variable
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.VarPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
<summary>
 An active pattern to recognize expressions that represent a variable
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.ValuePattern(Microsoft.FSharp.Quotations.FSharpExpr)">
<summary>
 An active pattern to recognize expressions that represent a constant value
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.UnionCaseTestPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
<summary>
 An active pattern to recognize expressions that represent a test if a value is of a particular union case
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.TypeTestPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
<summary>
 An active pattern to recognize expressions that represent a dynamic type test
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.TupleGetPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
<summary>
 An active pattern to recognize expressions that represent getting a tuple field
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.TryFinallyPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
<summary>
 An active pattern to recognize expressions that represent a try/finally construct 
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.TryWithPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
<summary>
 An active pattern to recognize expressions that represent a try/with construct for exception filtering and catching 
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.SequentialPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
<summary>
 An active pattern to recognize expressions that represent sequential exeuction of one expression followed by another
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.QuotePattern(Microsoft.FSharp.Quotations.FSharpExpr)">
<summary>
 An active pattern to recognize expressions that represent a nested quotation literal
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.PropertySetPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
<summary>
 An active pattern to recognize expressions that represent setting a static or instance property, or a non-function value declared in a module
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.PropertyGetPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
<summary>
 An active pattern to recognize expressions that represent the read of a static or instance property, or a non-function value declared in a module
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.NewTuplePattern(Microsoft.FSharp.Quotations.FSharpExpr)">
<summary>
 An active pattern to recognize expressions that represent construction of tuple values
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.NewUnionCasePattern(Microsoft.FSharp.Quotations.FSharpExpr)">
<summary>
 An active pattern to recognize expressions that represent construction of particular union case values
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.NewRecordPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
<summary>
 An active pattern to recognize expressions that represent construction of record values
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.NewObjectPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
<summary>
 An active pattern to recognize expressions that represent invocation of object constructors
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.NewDelegatePattern(Microsoft.FSharp.Quotations.FSharpExpr)">
<summary>
 An active pattern to recognize expressions that represent construction of delegate values
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.DefaultValuePattern(Microsoft.FSharp.Quotations.FSharpExpr)">
<summary>
 An active pattern to recognize expressions that represent invocations of a default constructor of a struct
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.NewArrayPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
<summary>
 An active pattern to recognize expressions that represent the construction of arrays 
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.LetRecursivePattern(Microsoft.FSharp.Quotations.FSharpExpr)">
<summary>
 An active pattern to recognize expressions that represent recursive let bindings of one or more variables
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.LetPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
<summary>
 An active pattern to recognize expressions that represent let bindings
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.LambdaPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
<summary>
 An active pattern to recognize expressions that represent first class function values
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.IfThenElsePattern(Microsoft.FSharp.Quotations.FSharpExpr)">
<summary>
 An active pattern to recognize expressions that represent conditionals
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.WhileLoopPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
<summary>
 An active pattern to recognize expressions that represent while loops 
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.ForIntegerRangeLoopPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
<summary>
 An active pattern to recognize expressions that represent loops over integer ranges
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.FieldSetPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
<summary>
 An active pattern to recognize expressions that represent setting a static or instance field 
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.FieldGetPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
<summary>
 An active pattern to recognize expressions that represent getting a static or instance field 
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.CoercePattern(Microsoft.FSharp.Quotations.FSharpExpr)">
<summary>
 An active pattern to recognize expressions that represent coercions from one type to another
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.CallPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
<summary>
 An active pattern to recognize expressions that represent calls to static and instance methods, and functions defined in modules
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.ApplicationPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
<summary>
 An active pattern to recognize expressions that represent applications of first class function values
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.AddressSetPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
<summary>
 An active pattern to recognize expressions that represent setting the value held at an address 
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.PatternsModule.AddressOfPattern(Microsoft.FSharp.Quotations.FSharpExpr)">
<summary>
 An active pattern to recognize expressions that represent getting the address of a value
</summary>
</member>
<member name="T:Microsoft.FSharp.Quotations.PatternsModule">
<summary>
 Contains a set of primitive F# active patterns to analyze F# expression objects
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpType.MakeTupleType(System.Type[]`1)">
<summary>
 Return a &lt;c&gt;System.Type&lt;/c&gt; representing an F# tuple type with the given element types
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpType.MakeFunctionType(System.Type,System.Type)">
<summary>
 Return a &lt;c&gt;System.Type&lt;/c&gt; representing the F# function type with the given domain and range
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpType.IsUnion(System.Type,Microsoft.FSharp.Core.FSharpOption{System.Reflection.BindingFlags})">
<summary>
 Return true if the &lt;c&gt;typ&lt;/c&gt; is a representation of an F# union type or the runtime type of a value of that type
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpType.IsTuple(System.Type)">
<summary>
 Return true if the &lt;c&gt;typ&lt;/c&gt; is a representation of an F# tuple type 
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpType.IsRecord(System.Type,Microsoft.FSharp.Core.FSharpOption{System.Reflection.BindingFlags})">
<summary>
 Return true if the &lt;c&gt;typ&lt;/c&gt; is a representation of an F# record type 
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpType.IsModule(System.Type)">
<summary>
 Return true if the &lt;c&gt;typ&lt;/c&gt; is a &lt;c&gt;System.Type&lt;/c&gt; value corresponding to the compiled form of an F# module 
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpType.IsFunction(System.Type)">
<summary>
 Return true if the &lt;c&gt;typ&lt;/c&gt; is a representation of an F# function type or the runtime type of a closure implementing an F# function type
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpType.IsExceptionRepresentation(System.Type,Microsoft.FSharp.Core.FSharpOption{System.Reflection.BindingFlags})">
<summary>
 Return true if the &lt;c&gt;typ&lt;/c&gt; is a representation of an F# exception declaration
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpType.GetUnionCases(System.Type,Microsoft.FSharp.Core.FSharpOption{System.Reflection.BindingFlags})">
<summary>
 Get the cases of a union type.

 Assumes the given type is a union type. If not, ArgumentException is raised during pre-computation.
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpType.GetTupleElements(System.Type)">
<summary>
 Get the tuple elements from the representation of an F# tuple type  
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpType.GetRecordFields(System.Type,Microsoft.FSharp.Core.FSharpOption{System.Reflection.BindingFlags})">
<summary>
 Read all the fields from a record value, in declaration order

 Assumes the given input is a record value. If not, ArgumentException is raised.
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpType.GetFunctionElements(System.Type)">
<summary>
 Get the domain and range types from an F# function type  or from the runtime type of a closure implementing an F# type
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpType.GetExceptionFields(System.Type,Microsoft.FSharp.Core.FSharpOption{System.Reflection.BindingFlags})">
<summary>
 Read all the fields from an F# exception declaration, in declaration order

 Assumes &lt;c&gt;exceptionType&lt;/c&gt; is an exception representation type. If not, ArgumentException is raised.
</summary>
</member>
<member name="T:Microsoft.FSharp.Reflection.FSharpType">
<summary>
 Contains operations associated with constructing and analyzing F# types such as records, unions and tuples
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.PreComputeUnionTagReader(System.Type,Microsoft.FSharp.Core.FSharpOption{System.Reflection.BindingFlags})">
<summary>
 Assumes the given type is a union type. 
 If not, ArgumentException is raised during pre-computation.

 Using the computed function is more efficient than calling GetUnionCase
 because the path executed by the computed function is optimized given the knowledge that it will be
 used to read values of the given type.
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.PreComputeUnionTagMemberInfo(System.Type,Microsoft.FSharp.Core.FSharpOption{System.Reflection.BindingFlags})">
<summary>
 Precompute a property or static method for reading an integer representing the case tag of a union type.
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.PreComputeUnionReader(Microsoft.FSharp.Reflection.UnionCaseInfo,Microsoft.FSharp.Core.FSharpOption{System.Reflection.BindingFlags})">
<summary>
 Precompute a function for reading all the fields for a particular discriminator case of a union type

 Using the computed function will typically be faster than executing a corresponding call to GetFields
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.PreComputeUnionConstructorInfo(Microsoft.FSharp.Reflection.UnionCaseInfo,Microsoft.FSharp.Core.FSharpOption{System.Reflection.BindingFlags})">
<summary>
 A method that constructs objects of the given case
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.PreComputeUnionConstructor(Microsoft.FSharp.Reflection.UnionCaseInfo,Microsoft.FSharp.Core.FSharpOption{System.Reflection.BindingFlags})">
<summary>
 Precompute a function for constructing a discriminated union value for a particular union case. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.PreComputeTupleReader(System.Type)">
<summary>
 Precompute a function for reading the values of a particular tuple type

 Assumes the given type is a TupleType.
 If not, ArgumentException is raised during pre-computation.
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.PreComputeTuplePropertyInfo(System.Type,System.Int32)">
<summary>
 Get information that indicates how to read a field of a tuple
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.PreComputeTupleConstructorInfo(System.Type)">
<summary>
 Get a method that constructs objects of the given tuple type. 
 For small tuples, no additional typoe will be returned.
 
 For large tuples, an additional type is returned indicating that
 a nested encoding has been used for the tuple type. In this case
 the suffix portion of the tuple type has the given type and an
 object of this type must be created and passed as the last argument 
 to the ConstructorInfo. A recursive call to PreComputeTupleConstructorInfo 
 can be used to determine the constructor for that the suffix type.
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.PreComputeTupleConstructor(System.Type)">
<summary>
 Precompute a function for reading the values of a particular tuple type

 Assumes the given type is a TupleType.
 If not, ArgumentException is raised during pre-computation.
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.PreComputeRecordReader(System.Type,Microsoft.FSharp.Core.FSharpOption{System.Reflection.BindingFlags})">
<summary>
 Precompute a function for reading all the fields from a record. The fields are returned in the
 same order as the fields reported by a call to Microsoft.FSharp.Reflection.Type.GetInfo for
 this type.

 Assumes the given type is a RecordType. 
 If not, ArgumentException is raised during pre-computation.

 Using the computed function will typically be faster than executing a corresponding call to Value.GetInfo
 because the path executed by the computed function is optimized given the knowledge that it will be
 used to read values of the given type.
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.PreComputeRecordFieldReader(System.Reflection.PropertyInfo)">
<summary>
 Precompute a function for reading a particular field from a record.
 Assumes the given type is a RecordType with a field of the given name. 
 If not, ArgumentException is raised during pre-computation.

 Using the computed function will typically be faster than executing a corresponding call to Value.GetInfo
 because the path executed by the computed function is optimized given the knowledge that it will be
 used to read values of the given type.
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.PreComputeRecordConstructorInfo(System.Type,Microsoft.FSharp.Core.FSharpOption{System.Reflection.BindingFlags})">
<summary>
 Get a ConstructorInfo for a record type
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.PreComputeRecordConstructor(System.Type,Microsoft.FSharp.Core.FSharpOption{System.Reflection.BindingFlags})">
<summary>
 Precompute a function for constructing a record value. 

 Assumes the given type is a RecordType.
 If not, ArgumentException is raised during pre-computation.
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.MakeUnion(Microsoft.FSharp.Reflection.UnionCaseInfo,System.Object[]`1,Microsoft.FSharp.Core.FSharpOption{System.Reflection.BindingFlags})">
<summary>
 Create a union case value
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.MakeTuple(System.Object[]`1,System.Type)">
<summary>
 Create an instance of a tuple type

 Assumes at least one element is given. If not, ArgumentException is raised.
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.MakeRecord(System.Type,System.Object[]`1,Microsoft.FSharp.Core.FSharpOption{System.Reflection.BindingFlags})">
<summary>
 Create an instance of a record type

 Assumes the given input is a record type. If not, ArgumentException is raised.
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.MakeFunction(System.Type,Microsoft.FSharp.Core.FSharpFunc`2{System.Object,System.Object})">
<summary>
 Build a typed function from object from a dynamic function implementation
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.GetUnionFields(System.Object,System.Type,Microsoft.FSharp.Core.FSharpOption{System.Reflection.BindingFlags})">
<summary>
 Identify the union case and its fields for an object

 Assumes the given input is a union case value. If not, ArgumentException is raised.

 If the type is not given, then the runtime type of the input object is used to identify the
 relevant union type. The type should always be given if the input object may be null. For example, 
 option values may be represented using the &apos;null&apos;.
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.GetTupleFields(System.Object)">
<summary>
 Read all fields from a tuple 

 Assumes the given input is a tuple value. If not, ArgumentException is raised.
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.GetTupleField(System.Object,System.Int32)">
<summary>
 Read a field from a tuple value

 Assumes the given input is a tuple value. If not, ArgumentException is raised.
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.GetRecordFields(System.Object,Microsoft.FSharp.Core.FSharpOption{System.Reflection.BindingFlags})">
<summary>
 Read all the fields from a record value

 Assumes the given input is a record value. If not, ArgumentException is raised.
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.GetRecordField(System.Object,System.Reflection.PropertyInfo)">
<summary>
 Read a field from a record value

 Assumes the given input is a record value. If not, ArgumentException is raised.
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.FSharpValue.GetExceptionFields(System.Object,Microsoft.FSharp.Core.FSharpOption{System.Reflection.BindingFlags})">
<summary>
 Read all the fields from a value built using an instance of an F# exception declaration

 Assumes the given input is an F# exception value. If not, ArgumentException is raised.
</summary>
</member>
<member name="T:Microsoft.FSharp.Reflection.FSharpValue">
<summary>
 Contains operations associated with constructing and analyzing values associated with F# types such as records, unions and tuples
</summary>
</member>
<member name="P:Microsoft.FSharp.Reflection.UnionCaseInfo.Tag">
<summary>
 The integer tag for the case
</summary>
</member>
<member name="P:Microsoft.FSharp.Reflection.UnionCaseInfo.Name">
<summary>
 The name of the case
</summary>
</member>
<member name="P:Microsoft.FSharp.Reflection.UnionCaseInfo.DeclaringType">
<summary>
 The type in which the case occurs
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.UnionCaseInfo.GetFields">
<summary>
 The fields associated with the case, represented by a PropertyInfo 
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.UnionCaseInfo.GetCustomAttributes(System.Type)">
<summary>
 Return the custom attributes associated with the case matching the given attribute type
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.UnionCaseInfo.GetCustomAttributes">
<summary>
 Return the custom attributes associated with the case
</summary>
</member>
<member name="T:Microsoft.FSharp.Reflection.UnionCaseInfo">
<summary>
Represents a case of a discriminated union type
</summary>
</member>
<member name="P:Microsoft.FSharp.Text.StructuredPrintfImpl.FormatOptions.Default">

</member>
<member name="T:Microsoft.FSharp.Text.StructuredPrintfImpl.FormatOptions">
<summary>
 A record of options to control structural formatting.
 For F# Interactive properties matching those of this value can be accessed via the &apos;fsi&apos;
 value.
 
 Floating Point format given in the same format accepted by System.Double.ToString,
 e.g. f6 or g15.

 If ShowProperties is set the printing process will evaluate properties of the values being
 displayed.  This may cause additional computation.  

 The ShowIEnumerable is set the printing process will force the evalution of IEnumerable objects
 to a small, finite depth, as determined by the printing parameters.
 This may lead to additional computation being performed during printing.

 &lt;example&gt;
 From F# Interactive the default settings can be adjusted using, for example, 
 &lt;pre&gt;
   open Microsoft.FSharp.Compiler.Interactive.Settings;;
   setPrintWidth 120;;
 &lt;/pre&gt;
 &lt;/example&gt;
</summary>
</member>
<member name="T:Microsoft.FSharp.Text.StructuredPrintfImpl.Layout">
<summary>
 Data representing structured layouts of terms.  
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.Display.layout_to_string(Microsoft.FSharp.Text.StructuredPrintfImpl.FormatOptions,Microsoft.FSharp.Text.StructuredPrintfImpl.Layout)">
<summary>
 Convert any value to a layout using the given formatting options.  The
 layout can then be processed using formatting display engines such as
 those in the LayoutOps module.  any_to_string and output_any are
 built using any_to_layout with default format options.
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.Display.anyToStringForPrintf``1(Microsoft.FSharp.Text.StructuredPrintfImpl.FormatOptions,System.Reflection.BindingFlags,``0)">

</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.Display.output_any``1(System.IO.TextWriter,``0)">
<summary>
 Ouput any value to a channel using the same set of formatting rules
 as any_to_string
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.Display.any_to_string``1(``0)">
<summary>
 Convert any value to a string using a standard formatter
 Data is typically formatted in a structured format, e.g.
 lists are formatted using the &quot;[1;2]&quot; notation.
 The details of the format are not specified and may change
 from version to version and according to the flags given
 to the F# compiler.  The format is intended to be human-readable,
 not machine readable.  If alternative generic formats are required
 you should develop your own formatter, using the code in the
 implementation of this file as a starting point.

 Data from other .NET languages is formatted using a virtual
 call to Object.ToString() on the boxed version of the input.
</summary>
</member>
<member name="T:Microsoft.FSharp.Text.StructuredPrintfImpl.Display">

</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.unfoldL``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Text.StructuredPrintfImpl.Layout},Microsoft.FSharp.Core.FSharpFunc`2{``1,Microsoft.FSharp.Core.FSharpOption{System.Tuple`2{``0,``1}}},``1,System.Int32)">
<summary>
 For limitting layout of list-like sequences (lists,arrays,etc).
 unfold a list of items using (project and z) making layout list via itemL.
 If reach maxLength (before exhausting) then truncate.
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.tagAttrL(System.String,Microsoft.FSharp.Collections.FSharpList{System.Tuple`2{System.String,System.String}},Microsoft.FSharp.Text.StructuredPrintfImpl.Layout)">
<summary>
 See tagL
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.listL``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Text.StructuredPrintfImpl.Layout},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Layout like an F# list.    
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.optionL``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Text.StructuredPrintfImpl.Layout},Microsoft.FSharp.Core.FSharpOption{``0})">
<summary>
 Layout like an F# option.
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.aboveListL(Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Text.StructuredPrintfImpl.Layout})">
<summary>
 Layout list vertically.    
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.aboveL(Microsoft.FSharp.Text.StructuredPrintfImpl.Layout,Microsoft.FSharp.Text.StructuredPrintfImpl.Layout)">
<summary>
 Layout two vertically.
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.tupleL(Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Text.StructuredPrintfImpl.Layout})">
<summary>
 Form tuple of layouts.            
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.braceL(Microsoft.FSharp.Text.StructuredPrintfImpl.Layout)">
<summary>
 Wrap braces around layout.        
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.squareBracketL(Microsoft.FSharp.Text.StructuredPrintfImpl.Layout)">
<summary>
 Wrap square brackets around layout.    
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.bracketL(Microsoft.FSharp.Text.StructuredPrintfImpl.Layout)">
<summary>
 Wrap round brackets around Layout.
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.sepListL(Microsoft.FSharp.Text.StructuredPrintfImpl.Layout,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Text.StructuredPrintfImpl.Layout})">
<summary>
 Join layouts into a list separated using the given Layout.
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.semiListL(Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Text.StructuredPrintfImpl.Layout})">
<summary>
 Join layouts into a semi-colon separated list.
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.spaceListL(Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Text.StructuredPrintfImpl.Layout})">
<summary>
 Join layouts into a space separated list.    
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.commaListL(Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Text.StructuredPrintfImpl.Layout})">
<summary>
 Join layouts into a comma separated list.
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.op_AtAtMinusMinus(Microsoft.FSharp.Text.StructuredPrintfImpl.Layout,Microsoft.FSharp.Text.StructuredPrintfImpl.Layout)">
<summary>
 Join broken with ident=2 
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.op_AtAtMinus(Microsoft.FSharp.Text.StructuredPrintfImpl.Layout,Microsoft.FSharp.Text.StructuredPrintfImpl.Layout)">
<summary>
 Join broken with ident=1 
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.op_AtAt(Microsoft.FSharp.Text.StructuredPrintfImpl.Layout,Microsoft.FSharp.Text.StructuredPrintfImpl.Layout)">
<summary>
 Join broken with ident=0
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.op_MinusMinusMinus(Microsoft.FSharp.Text.StructuredPrintfImpl.Layout,Microsoft.FSharp.Text.StructuredPrintfImpl.Layout)">
<summary>
 Join, possible break with indent=2 
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.op_MinusMinus(Microsoft.FSharp.Text.StructuredPrintfImpl.Layout,Microsoft.FSharp.Text.StructuredPrintfImpl.Layout)">
<summary>
 Join, possible break with indent=1
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.op_PlusPlus(Microsoft.FSharp.Text.StructuredPrintfImpl.Layout,Microsoft.FSharp.Text.StructuredPrintfImpl.Layout)">
<summary>
 Join, possible break with indent=0
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.op_HatHat(Microsoft.FSharp.Text.StructuredPrintfImpl.Layout,Microsoft.FSharp.Text.StructuredPrintfImpl.Layout)">
<summary>
 Join, unbreakable. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.leftL(System.String)">
<summary>
 An string which is left  parenthesis (no space on the right).
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.rightL(System.String)">
<summary>
 An string which is right parenthesis (no space on the left).
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.sepL(System.String)">
<summary>
 An string which requires no spaces either side.
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.wordL(System.String)">
<summary>
 An string leaf 
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.objL(System.Object)">
<summary>
 An uninterpreted leaf, to be interpreted into a string
 by the layout engine. This allows leaf layouts for numbers, strings and
 other atoms to be customized according to culture.
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.isEmptyL(Microsoft.FSharp.Text.StructuredPrintfImpl.Layout)">
<summary>
 Is it the empty layout?
</summary>
</member>
<member name="P:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps.emptyL">
<summary>
 The empty layout
</summary>
</member>
<member name="T:Microsoft.FSharp.Text.StructuredPrintfImpl.LayoutOps">
<summary>
 A layout is a sequence of strings which have been joined together.
 The strings are classified as words, separators and left and right parenthesis.
 This classification determines where spaces are inserted.
 A joint is either unbreakable, breakable or broken.
 If a joint is broken the RHS layout occurs on the next line with optional indentation.
 A layout can be squashed to for given width which forces breaks as required.
</summary>
</member>
<member name="P:System.AggregateException.InnerExceptions">

</member>
<member name="T:System.AggregateException">

</member>
<member name="M:System.IObservable`1.Subscribe(System.IObserver{`0})">
<summary>
 Subscribe an observer to the source of results
</summary>
</member>
<member name="T:System.IObservable`1">
<summary>
 A source of observable results
</summary>
</member>
<member name="M:System.IObserver`1.OnNext(`0)">
<summary>
 Notify an observer of a new result
</summary>
</member>
<member name="M:System.IObserver`1.OnError(System.Exception)">
<summary>
 Notify an observer of an error 
</summary>
</member>
<member name="M:System.IObserver`1.OnCompleted">
<summary>
 Notify an observer that no more results will be produced
</summary>
</member>
<member name="T:System.IObserver`1">
<summary>
 A client that mat be subscribed to observe the results from an IObservable
</summary>
</member>
<member name="P:System.Lazy`1.Value">

</member>
<member name="P:System.Lazy`1.IsValueCreated">

</member>
<member name="T:System.Lazy`1">

</member>
<member name="P:System.Tuple`1.Item1">

</member>
<member name="M:System.Tuple`1..ctor(`0)">

</member>
<member name="T:System.Tuple`1">
<summary>
 Compiled versions of F# tuple types. These are not used directly, though
 these compiled forms are seen by other CLI languages.
</summary>
</member>
<member name="P:System.Tuple`2.Item2">

</member>
<member name="P:System.Tuple`2.Item1">

</member>
<member name="M:System.Tuple`2..ctor(`0,`1)">

</member>
<member name="T:System.Tuple`2">

</member>
<member name="P:System.Tuple`3.Item3">

</member>
<member name="P:System.Tuple`3.Item2">

</member>
<member name="P:System.Tuple`3.Item1">

</member>
<member name="M:System.Tuple`3..ctor(`0,`1,`2)">

</member>
<member name="T:System.Tuple`3">

</member>
<member name="P:System.Tuple`4.Item4">

</member>
<member name="P:System.Tuple`4.Item3">

</member>
<member name="P:System.Tuple`4.Item2">

</member>
<member name="P:System.Tuple`4.Item1">

</member>
<member name="M:System.Tuple`4..ctor(`0,`1,`2,`3)">

</member>
<member name="T:System.Tuple`4">

</member>
<member name="P:System.Tuple`5.Item5">

</member>
<member name="P:System.Tuple`5.Item4">

</member>
<member name="P:System.Tuple`5.Item3">

</member>
<member name="P:System.Tuple`5.Item2">

</member>
<member name="P:System.Tuple`5.Item1">

</member>
<member name="M:System.Tuple`5..ctor(`0,`1,`2,`3,`4)">

</member>
<member name="T:System.Tuple`5">

</member>
<member name="P:System.Tuple`6.Item6">

</member>
<member name="P:System.Tuple`6.Item5">

</member>
<member name="P:System.Tuple`6.Item4">

</member>
<member name="P:System.Tuple`6.Item3">

</member>
<member name="P:System.Tuple`6.Item2">

</member>
<member name="P:System.Tuple`6.Item1">

</member>
<member name="M:System.Tuple`6..ctor(`0,`1,`2,`3,`4,`5)">

</member>
<member name="T:System.Tuple`6">

</member>
<member name="P:System.Tuple`7.Item7">

</member>
<member name="P:System.Tuple`7.Item6">

</member>
<member name="P:System.Tuple`7.Item5">

</member>
<member name="P:System.Tuple`7.Item4">

</member>
<member name="P:System.Tuple`7.Item3">

</member>
<member name="P:System.Tuple`7.Item2">

</member>
<member name="P:System.Tuple`7.Item1">

</member>
<member name="M:System.Tuple`7..ctor(`0,`1,`2,`3,`4,`5,`6)">

</member>
<member name="T:System.Tuple`7">

</member>
<member name="P:System.Tuple`8.Rest">

</member>
<member name="P:System.Tuple`8.Item7">

</member>
<member name="P:System.Tuple`8.Item6">

</member>
<member name="P:System.Tuple`8.Item5">

</member>
<member name="P:System.Tuple`8.Item4">

</member>
<member name="P:System.Tuple`8.Item3">

</member>
<member name="P:System.Tuple`8.Item2">

</member>
<member name="P:System.Tuple`8.Item1">

</member>
<member name="M:System.Tuple`8..ctor(`0,`1,`2,`3,`4,`5,`6,`7)">

</member>
<member name="T:System.Tuple`8">

</member>
<member name="M:System.Collections.IStructuralComparable.CompareTo(System.Object,System.Collections.IComparer)">

</member>
<member name="T:System.Collections.IStructuralComparable">

</member>
<member name="M:System.Collections.IStructuralEquatable.GetHashCode(System.Collections.IEqualityComparer)">

</member>
<member name="M:System.Collections.IStructuralEquatable.Equals(System.Object,System.Collections.IEqualityComparer)">

</member>
<member name="T:System.Collections.IStructuralEquatable">

</member>
<member name="T:System.Numerics.bigint">

</member>
<member name="M:System.Numerics.BigInteger.op_UnaryPlus(System.Numerics.BigInteger)">
<summary>
 Return the given big integer
</summary>
</member>
<member name="M:System.Numerics.BigInteger.op_UnaryNegation(System.Numerics.BigInteger)">
<summary>
 Return the negation of a big integer
</summary>
</member>
<member name="M:System.Numerics.BigInteger.op_Subtraction(System.Numerics.BigInteger,System.Numerics.BigInteger)">
<summary>
 Return the difference of two big integers
</summary>
</member>
<member name="M:System.Numerics.BigInteger.op_RangeStep(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger)">
<summary>
 Generate a range of big integers, with a step
</summary>
</member>
<member name="M:System.Numerics.BigInteger.op_Range(System.Numerics.BigInteger,System.Numerics.BigInteger)">
<summary>
 Generate a range of big integers
</summary>
</member>
<member name="M:System.Numerics.BigInteger.op_Multiply(System.Numerics.BigInteger,System.Numerics.BigInteger)">
<summary>
 Return the product of big integers
</summary>
</member>
<member name="M:System.Numerics.BigInteger.op_Modulus(System.Numerics.BigInteger,System.Numerics.BigInteger)">
<summary>
 Return the modulus of big integers
</summary>
</member>
<member name="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.Numerics.BigInteger,System.Numerics.BigInteger)">
<summary>
 This operator is for consistency when this type be used from other CLI languages
</summary>
</member>
<member name="M:System.Numerics.BigInteger.op_LessThan(System.Numerics.BigInteger,System.Numerics.BigInteger)">
<summary>
 This operator is for consistency when this type be used from other CLI languages
</summary>
</member>
<member name="M:System.Numerics.BigInteger.op_Inequality(System.Numerics.BigInteger,System.Numerics.BigInteger)">
<summary>
 This operator is for consistency when this type be used from other CLI languages
</summary>
</member>
<member name="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.Numerics.BigInteger,System.Numerics.BigInteger)">
<summary>
 This operator is for consistency when this type be used from other CLI languages
</summary>
</member>
<member name="M:System.Numerics.BigInteger.op_GreaterThan(System.Numerics.BigInteger,System.Numerics.BigInteger)">
<summary>
 This operator is for consistency when this type be used from other CLI languages
</summary>
</member>
<member name="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)">
<summary>
 Convert a big integer to a 32-bit signed integer
</summary>
</member>
<member name="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)">
<summary>
 Convert a big integer to a 64-bit signed integer
</summary>
</member>
<member name="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)">
<summary>
 Convert a big integer to a floating point number
</summary>
</member>
<member name="M:System.Numerics.BigInteger.op_Equality(System.Numerics.BigInteger,System.Numerics.BigInteger)">
<summary>
 This operator is for consistency when this type be used from other CLI languages
</summary>
</member>
<member name="M:System.Numerics.BigInteger.op_Division(System.Numerics.BigInteger,System.Numerics.BigInteger)">
<summary>
 Return the ratio of two big integers
</summary>
</member>
<member name="M:System.Numerics.BigInteger.op_Addition(System.Numerics.BigInteger,System.Numerics.BigInteger)">
<summary>
 Return the sum of two big integers
</summary>
</member>
<member name="P:System.Numerics.BigInteger.Zero">
<summary>
 Get the big integer for zero
</summary>
</member>
<member name="P:System.Numerics.BigInteger.Sign">
<summary>
 Return the sign of a big integer: 0, +1 or -1
</summary>
</member>
<member name="P:System.Numerics.BigInteger.One">
<summary>
 Get the big integer for one
</summary>
</member>
<member name="P:System.Numerics.BigInteger.IsZero">
<summary>
 Return true if a big integer is &apos;zero&apos;
</summary>
</member>
<member name="P:System.Numerics.BigInteger.IsOne">
<summary>
 Return true if a big integer is &apos;one&apos;
</summary>
</member>
<member name="M:System.Numerics.BigInteger.ToString">

</member>
<member name="M:System.Numerics.BigInteger.ToInt64(System.Numerics.BigInteger)">

</member>
<member name="M:System.Numerics.BigInteger.ToInt32(System.Numerics.BigInteger)">

</member>
<member name="M:System.Numerics.BigInteger.ToDouble(System.Numerics.BigInteger)">

</member>
<member name="M:System.Numerics.BigInteger.Pow(System.Numerics.BigInteger,System.Int32)">

</member>
<member name="M:System.Numerics.BigInteger.Pow(System.Numerics.BigInteger,System.Numerics.BigInteger)">
<summary>
 Return n^m for two big integers
</summary>
</member>
<member name="M:System.Numerics.BigInteger.Parse(System.String)">
<summary>
 Parse a big integer from a string format
</summary>
</member>
<member name="M:System.Numerics.BigInteger.GreatestCommonDivisor(System.Numerics.BigInteger,System.Numerics.BigInteger)">
<summary>
 Return the greatest common divisor of two big integers
</summary>
</member>
<member name="M:System.Numerics.BigInteger.GetHashCode">

</member>
<member name="M:System.Numerics.BigInteger.Factorial(System.Numerics.BigInteger)">
<summary>
 Compute the factorial function as a big integer
</summary>
</member>
<member name="M:System.Numerics.BigInteger.Equals(System.Object)">

</member>
<member name="M:System.Numerics.BigInteger.DivRem(System.Numerics.BigInteger,System.Numerics.BigInteger,Microsoft.FSharp.Core.byref{System.Numerics.BigInteger})">

</member>
<member name="M:System.Numerics.BigInteger.DivRem(System.Numerics.BigInteger,System.Numerics.BigInteger)">
<summary>
 Compute the ratio and remainder of two big integers
</summary>
</member>
<member name="M:System.Numerics.BigInteger.Abs(System.Numerics.BigInteger)">
<summary>
 Compute the absolute value of a big integer 
</summary>
</member>
<member name="M:System.Numerics.BigInteger..ctor(System.Int64)">
<summary>
 Construct a BigInteger value for the given 64-bit integer
</summary>
</member>
<member name="M:System.Numerics.BigInteger..ctor(System.Int32)">
<summary>
 Construct a BigInteger value for the given integer
</summary>
</member>
<member name="T:System.Numerics.BigInteger">
<summary>
 The type of arbitrary-sized integers
</summary>
</member>
<member name="P:System.Threading.CancellationTokenSource.Token">

</member>
<member name="M:System.Threading.CancellationTokenSource.Dispose">

</member>
<member name="M:System.Threading.CancellationTokenSource.CreateLinkedTokenSource(System.Threading.CancellationToken,System.Threading.CancellationToken)">

</member>
<member name="M:System.Threading.CancellationTokenSource.Cancel">

</member>
<member name="M:System.Threading.CancellationTokenSource..ctor">

</member>
<member name="T:System.Threading.CancellationTokenSource">

</member>
<member name="M:System.Threading.CancellationToken.op_EqualsEquals(System.Threading.CancellationToken,System.Threading.CancellationToken)">

</member>
<member name="M:System.Threading.CancellationToken.op_BangEquals(System.Threading.CancellationToken,System.Threading.CancellationToken)">

</member>
<member name="P:System.Threading.CancellationToken.IsCancellationRequested">

</member>
<member name="M:System.Threading.CancellationToken.Register(System.Action{System.Object},System.Object)">

</member>
<member name="M:System.Threading.CancellationToken.Equals(System.Threading.CancellationToken)">

</member>
<member name="T:System.Threading.CancellationToken">

</member>
<member name="M:System.Threading.CancellationTokenRegistration.op_EqualsEquals(System.Threading.CancellationTokenRegistration,System.Threading.CancellationTokenRegistration)">

</member>
<member name="M:System.Threading.CancellationTokenRegistration.op_BangEquals(System.Threading.CancellationTokenRegistration,System.Threading.CancellationTokenRegistration)">

</member>
<member name="M:System.Threading.CancellationTokenRegistration.Equals(System.Threading.CancellationTokenRegistration)">

</member>
<member name="M:System.Threading.CancellationTokenRegistration.Dispose">

</member>
<member name="T:System.Threading.CancellationTokenRegistration">

</member>
</members>
</doc>
